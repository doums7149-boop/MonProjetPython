import tkinter as tk
from tkinter import messagebox, font, filedialog
import re
import json
from pynput import keyboard, mouse
import pyautogui
import time
import threading
import winsound  # Pour le beep d'alerte
# === 2. D√âCLARATIONS GLOBALES SIMPLES ===
# Variables normales (pas Tkinter)
detected_numbers = []
detected_numbers_label = None  # AJOUTEZ CETTE LIGNE

# Cr√©ation de la fen√™tre principale
root = tk.Tk()
root.title("G R P  A3")
root.configure(bg='DarkSalmon')  # Changer la couleur de fond de la fen√™tre principale

# === 3. D√âCLARATIONS DES VARIABLES TKINTER ===
# (Doivent √™tre apr√®s la cr√©ation de root)
det_ecart_counter = tk.IntVar(value=0)  # CHANG√â StringVar ‚Üí IntVar

# Variables pour les compteurs (garder StringVar pour ceux-ci)
red_counter = tk.StringVar(value="0")
black_counter = tk.StringVar(value="0")
pair_counter = tk.StringVar(value="0")
impair_counter = tk.StringVar(value="0")
manque_counter = tk.StringVar(value="0")
passe_counter = tk.StringVar(value="0")

# D√©finir les couleurs et les num√©ros
RED_NUMBERS = {1, 3, 5, 7, 9, 12, 14, 16, 18, 19, 21, 23, 25, 27, 30, 32, 34, 36}
BLACK_NUMBERS = {2, 4, 6, 8, 10, 11, 13, 15, 17, 20, 22, 24, 26, 28, 29, 31, 33, 35}
ZERO_NUMBER = {0}

# D√©finir les ensembles de num√©ros pour chaque cat√©gorie
PAIR_NUMBERS = {2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36}
IMPAIR_NUMBERS = {1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35}
MANQUE_NUMBERS = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18}
PASSE_NUMBERS = {19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36}

# D√©finir les s√©ries de num√©ros
SERIES = {
    "VOISIN": [0, 2, 3, 4, 7, 12, 15, 18, 19, 21, 22, 25, 26, 28, 29, 32, 35],
    "TIERS": [5, 8, 10, 11, 13, 16, 23, 24, 27, 30, 33, 36],
    "ORPH": [1, 6, 9, 14, 17, 20, 31, 34],
    "COL 3": [3, 6, 9, 12, 15, 18, 21, 24, 27, 30, 33, 36],
    "COL 2": [2, 5, 8, 11, 14, 17, 20, 23, 26, 29, 32, 35],
    "COL 1": [1, 4, 7, 10, 13, 16, 19, 22, 25, 28, 31, 34],
    "DZ   3": [25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36],
    "DZ   2": [13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24],
    "DZ   1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12],
    "18 GA": [26, 3, 35, 12, 28, 7, 29, 18, 22, 9, 31, 14, 20, 1, 33, 16, 24, 5],
    "18 DR": [32, 15, 19, 4, 21, 2, 25, 17, 34, 6, 27, 13, 36, 11, 30, 8, 23, 10],
    "DOZ 1": [0, 2, 9, 10, 12, 13, 16, 19, 20, 29, 30, 34],
    "DOZ 2": [4, 5, 6, 7, 8, 14, 22, 25, 32, 33, 35, 36],
    "DOZ 3": [1, 3, 11, 15, 17, 18, 21, 23, 24, 27, 28, 31],
    "ROUG ": list(RED_NUMBERS),
    "NOIR  ": list(BLACK_NUMBERS),
    "PAIR  ": list(PAIR_NUMBERS),
    "IMP    ": list(IMPAIR_NUMBERS),
    "MAQ  ": list(MANQUE_NUMBERS),
    "PAS   ": list(PASSE_NUMBERS),
    "SIX   1": [1, 2, 3, 4, 5, 6, 13, 14, 15, 16, 17, 18, 25, 26, 27, 28, 29, 30],
    "SIX   2": [7, 8, 9, 10, 11, 12, 19, 20, 21, 22, 23, 24, 31, 32, 33, 34, 35, 36],
    "TRA  1": [1, 2, 3, 7, 8, 9, 13, 14, 15, 19, 20, 21, 25, 26, 27, 31, 32, 33],
    "TRA  2": [4, 5, 6, 10, 11, 12, 16, 17, 18, 22, 23, 24, 28, 29, 30, 34, 35, 36],
    "ZON  4": [7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30],
    "LA 369": [3, 6, 9, 13, 16, 19, 23, 26, 29, 30, 33, 36],
    "1 3 4 7": [31, 1, 3, 4, 7, 11, 13, 14, 17, 21, 23, 24, 27, 31, 33, 34],
    "FIN 0 5": [0, 5, 10, 15, 20, 25, 30, 35],
    "B K C": [0, 2, 8, 11, 17, 20, 26, 29, 35]
}

# Ajoutez ceci apr√®s la d√©finition de SERIES
NR_SERIES = {
    "NR1": [13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36],
    "NR2": [1, 2, 4, 5, 7, 8, 10, 11, 13, 14, 16, 17, 19, 20, 22, 23, 25, 26, 28, 29, 31, 32, 34, 35],
    "NR3": [1, 3, 4, 6, 7, 9, 10, 12, 13, 15, 16, 18, 19, 21, 22, 24, 25, 27, 28, 30, 31, 33, 34, 36],
    "NR4": [2, 3, 5, 6, 8, 9, 11, 12, 14, 15, 17, 18, 20, 21, 23, 24, 26, 27, 29, 30, 32, 33, 35, 36]
}

# D√©clarer keyboard_listener globalement
keyboard_listener = None
cadre_sous_tableaux = None

# Cr√©ation du cadre principal (main_frame)
main_frame = tk.Frame(root)
main_frame.pack(fill="both", expand=True)
main_frame.configure(bg='DarkSalmon')  # Changer la couleur de fond du cadre principal

# === üî∑ D√âFINITION DE LA POLICE PAR D√âFAUT (AVANT TOUTE UTILISATION) ===
default_font = font.Font(family="Helvetica", size=9, weight="bold")

# Emp√™cher le redimensionnement automatique
root.geometry("4365x1355")  # Remplacez par vos dimensions id√©ales
root.resizable(False, False)  # Bloque le redimensionnement manuel

# ===================================================
# === CR√âATION DU CADRE PARENT POUR LES 3 √âL√âMENTS ===
# ===================================================
# Cr√©ation du nouveau cadre parent qui regroupera Series, Clavier et Historique , REctangulo , Deversoir,ETC....
# Cr√©ation du cadre principal avec une colonne suppl√©mentaire pour les nouveaux cadres
main_group_frame = tk.Frame(main_frame, borderwidth=2, relief="groove", bg='Ghostwhite')
main_group_frame.grid(row=0, column=0, padx=10, pady=10, sticky="nw")
main_group_frame.columnconfigure(1, weight=1)  # Pour permettre l'expansion

# Valeurs d'alerte par d√©faut
alert_values = {
    "VOISIN": 7,
    "TIERS": 17,
    "ORPH": 12,
    "COL 3": 11,
    "COL 2": 11,
    "COL 1": 11,
    "DZ   3": 9,
    "DZ   2": 9,
    "DZ   1": 9,
    "18 GA": 6,
    "18 DR": 6,
    "DOZ 1": 7,
    "DOZ 2": 7,
    "DOZ 3": 7,
    "ROUG ": 7,
    "NOIR  ": 7,
    "PAIR  ": 7,
    "IMP    ": 7,
    "MAQ  ": 7,
    "PAS   ": 7,
    "SIX   1": 7,
    "SIX   2": 7,
    "TRA  1": 7,
    "TRA  2": 7,
    "ZON  4": 4,
    "LA 369": 6,
    "1 3 4 7": 4,
    "FIN 0 5": 4,
    "B K C": 5
}

# =========================================================
# CADRE UNIQUE : S√âRIE M√âMOIRES + ASK/TCA/D2D3 + FIN 2 DERN
# =========================================================
bloc_complet = tk.Frame(main_group_frame, bg='MediumTurquoise', borderwidth=6, relief="groove")
bloc_complet.grid(row=0, column=0, padx=(10, 5), pady=10, sticky="nw")

# --- 1. SOUS-BLOC : SERIES MEMOIRES ---
series_frame = tk.Frame(bloc_complet, borderwidth=4, relief="ridge", bg="DarkOliveGreen")
series_frame.pack(fill="x", padx=5, pady=5)

# D√©finit le style de police
font_style = ("Helvetica", 11, "bold")

# Couleur de fond pour les colonnes 1, 3 et 4
colored_bg = "peachpuff"

# Colonne 1 : Nombre de sorties (NS)
tk.Label(series_frame, text="NS", font=font_style, borderwidth=1, relief="solid", width=4, bg=colored_bg).grid(row=0,
                                                                                                               column=0)
ns_labels = {
    serie: tk.Label(series_frame, text="0", font=font_style, borderwidth=1, relief="solid", width=4, bg=colored_bg) for
    serie in SERIES.keys()}
for i, (serie_name, label) in enumerate(ns_labels.items()):
    label.grid(row=i + 1, column=0)

# Colonne 2 : S√©ries en m√©moire
tk.Label(series_frame, text="SE ME", font=font_style, borderwidth=1, relief="solid", width=7).grid(row=0, column=1)
series_labels = {serie: tk.Label(series_frame, text=serie, font=font_style, borderwidth=1, relief="solid", width=6) for
                 serie in SERIES.keys()}
for i, (serie_name, label) in enumerate(series_labels.items()):
    label.grid(row=i + 1, column=1)

# --- TABLES DE PROGRESSION MTGY PAR TYPE DE SERIE ---
MTGY_ORPH = [1, 1, 1, 1, 2, 2, 3, 4, 5, 6, 8, 10, 13, 17, 22, 28, 36, 46, 59, 76]
MTGY_CLASSIQUE = [1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072, 262144,
                  524288]
MTGY_TIERS = [1, 1, 2, 3, 4, 6, 9, 14, 21, 31, 37, 70, 105, 158, 237, 355, 533, 799, 1199, 1798]
MTGY_ZONE4 = [1, 3, 9, 27, 81, 243, 729, 2187, 6561, 19683, 59049, 177147, 531441, 1594323, 4782969, 4782969, 4782969,
              4782969, 4782969, 4782969]
MTGY_1347 = [1, 1, 2, 3, 6, 10, 17, 29, 50, 86, 147, 252, 432, 741, 1270, 2177, 3732, 6398, 10968, 21000]

MTGY_TABLE_BY_SERIE = {
    "ORPH": MTGY_ORPH,
    "VOISIN": MTGY_CLASSIQUE,
    "18 GA": MTGY_CLASSIQUE,
    "18 DR": MTGY_CLASSIQUE,
    "ROUG ": MTGY_CLASSIQUE,
    "NOIR  ": MTGY_CLASSIQUE,
    "PAIR  ": MTGY_CLASSIQUE,
    "IMP    ": MTGY_CLASSIQUE,
    "MAQ  ": MTGY_CLASSIQUE,
    "PAS   ": MTGY_CLASSIQUE,
    "SIX   1": MTGY_CLASSIQUE,
    "SIX   2": MTGY_CLASSIQUE,
    "TRA  1": MTGY_CLASSIQUE,
    "TRA  2": MTGY_CLASSIQUE,
    "TIERS": MTGY_TIERS,
    "COL 3": MTGY_TIERS,
    "COL 2": MTGY_TIERS,
    "COL 1": MTGY_TIERS,
    "DZ   3": MTGY_TIERS,
    "DZ   2": MTGY_TIERS,
    "DZ   1": MTGY_TIERS,
    "DOZ 1": MTGY_TIERS,
    "DOZ 2": MTGY_TIERS,
    "DOZ 3": MTGY_TIERS,
    "LA 369": MTGY_TIERS,
    "ZON  4": MTGY_ZONE4,
    "1 3 4 7": MTGY_1347,
}

# --- VARIABLES GLOBALES POUR MTGY ---
mtgy_values = {serie: 1 for serie in SERIES.keys()}
mtgy_labels = {}

# Colonne 3 : MTGY (Martingale)
tk.Label(series_frame, text="MTGY", font=font_style, borderwidth=1, relief="solid", width=6, bg="lightyellow",
         fg="darkblue").grid(row=0, column=2)
for i, serie_name in enumerate(SERIES.keys()):
    label = tk.Label(series_frame, text="1", font=font_style, borderwidth=1, relief="solid", width=6, bg="lightyellow",
                     fg="darkblue")
    label.grid(row=i + 1, column=2)
    mtgy_labels[serie_name] = label

# Colonne 4 : √âcart actuel (Ec)
colored_bg = "snow"
tk.Label(series_frame, text="Ec", font=font_style, borderwidth=1, relief="solid", width=4, bg=colored_bg).grid(row=0,
                                                                                                               column=3)
ec_labels = {
    serie: tk.Label(series_frame, text="0", font=("Helvetica", 14, "bold"), borderwidth=1, relief="solid", width=4,
                    bg=colored_bg) for serie in SERIES.keys()}
for i, (serie_name, label) in enumerate(ec_labels.items()):
    label.grid(row=i + 1, column=3)

# Colonne 5 : √âcart maximum (Ecmx)
colored_bg = "linen"
tk.Label(series_frame, text="Ecmx", font=font_style, borderwidth=1, relief="solid", width=4, bg=colored_bg).grid(row=0,
                                                                                                                 column=4)
ecmx_labels = {
    serie: tk.Label(series_frame, text="0", font=("Helvetica", 14, "bold"), borderwidth=1, relief="solid", width=4,
                    bg=colored_bg) for serie in SERIES.keys()}
for i, (serie_name, label) in enumerate(ecmx_labels.items()):
    label.grid(row=i + 1, column=4)

# Colonne 6 : Boutons Bet
tk.Label(series_frame, text="Bet", font=font_style).grid(row=0, column=5)
bet_buttons = {
    serie: tk.Button(series_frame, text=f"Bet {serie}", font=font_style, borderwidth=2, command=lambda s=serie: jouer_serie(s)) for
    serie in SERIES.keys()}
for i, (serie_name, button) in enumerate(bet_buttons.items()):
    button.grid(row=i + 1, column=5)

# Colonne 7 : Valeurs d'alerte (Alt)
tk.Label(series_frame, text="Alt", font=font_style).grid(row=0, column=6)
alt_entries = {serie: tk.Entry(series_frame, width=3, font=font_style, justify="center") for serie in SERIES.keys()}
for i, (serie_name, entry) in enumerate(alt_entries.items()):
    entry.grid(row=i + 1, column=6)
    entry.insert(0, str(alert_values[serie_name]))

# === üî¥ APPLICATION DES COULEURS SELON LES BLOCS ===
# Liste des blocs √† colorer
color_mapping = [
    (["VOISIN", "TIERS", "ORPH"], "orange", "black"),
    (["COL 3", "COL 2", "COL 1"], "darkblue", "white"),
    (["DZ   3", "DZ   2", "DZ   1"], "darkgreen", "white"),
    (["18 GA", "18 DR"], "cyan", "black"),
    (["DOZ 1", "DOZ 2", "DOZ 3"], "brown4", "white"),
    (["ROUG "], "red", "white"),
    (["NOIR  "], "black", "white"),
    (["PAIR  ", "IMP    "], "deepskyblue", "white"),
    (["MAQ  ", "PAS   "], "magenta", "white"),
    (["SIX   1", "SIX   2"], "salmon4", "white"),
    (["TRA  1", "TRA  2"], "yellow", "black"),
]

# Ne pas toucher ces s√©ries
excluded_series = ["ZON  4", "LA 369", "1 3 4 7", "FIN 0 5", "A R C"]

for series_list, bg_color, fg_color in color_mapping:
    for serie in series_list:
        if serie in series_labels and serie not in excluded_series:
            series_labels[serie].config(bg=bg_color, fg=fg_color)
            ns_labels[serie].config(bg=bg_color, fg=fg_color)

# Appliquer aussi la couleur sur les labels NS
for serie in SERIES.keys():
    if serie in excluded_series:
        # R√©initialiser ou laisser par d√©faut si besoin (optionnel)
        pass  # On laisse tel quel

# --- 2. SOUS-BLOC : LES ASK TCA D2D3 ---
detection_control_frame = tk.Frame(bloc_complet, borderwidth=4, relief="raised", bg='MediumTurquoise', width=15,
                                   height=130)
detection_control_frame.pack(fill="x", padx=5, pady=5)
detection_control_frame.grid_propagate(False)
detection_control_frame.columnconfigure(0, weight=1)

# --- 2.1. CADRE "ASK" ---
ask_frame = tk.Frame(detection_control_frame, borderwidth=2, relief="groove", bg="lightyellow", width=30, height=40)
ask_frame.grid(row=1, column=0, padx=5, pady=(2, 2), sticky="ew")
ask_frame.grid_propagate(False)
ask_frame.columnconfigure(0, weight=1)

for i in range(5):
    btn = tk.Button(ask_frame, text=f"ASK{i + 1}", font=default_font,
                    command=lambda idx=i: play_associated_numbers(history[-(idx + 1):]))
    btn.pack(side="left", padx=5, pady=5)

# --- 2.2. CADRE "TCA" ---
tca_frame = tk.Frame(detection_control_frame, borderwidth=2, relief="groove", bg="lightgray", width=30, height=40)
tca_frame.grid(row=2, column=0, padx=5, pady=(2, 2), sticky="ew")
tca_frame.grid_propagate(False)
tca_frame.columnconfigure(0, weight=1)

for i in range(5):
    btn = tk.Button(tca_frame, text=f"TCA{i + 1}", font=default_font,
                    command=lambda idx=i: play_remaining_numbers(history[-(idx + 1):]))
    btn.pack(side="left", padx=5, pady=5)

# --- 2.3. CADRE "D2D3 / C2C3 / etc" ---
d2d3_frame = tk.Frame(detection_control_frame, borderwidth=2, relief="groove", bg="lightgray", width=30, height=40)
d2d3_frame.grid(row=3, column=0, padx=5, pady=(2, 5), sticky="ew")
d2d3_frame.grid_propagate(False)
d2d3_frame.columnconfigure(0, weight=1)

tk.Button(d2d3_frame, text="D2D3", font=default_font, command=lambda: jouer_category(NR_SERIES["NR1"], "NR1")).pack(
    side="left", padx=3)
tk.Button(d2d3_frame, text="C2C3", font=default_font, command=lambda: jouer_category(NR_SERIES["NR4"], "NR4")).pack(
    side="left", padx=3)
tk.Button(d2d3_frame, text="C1C2", font=default_font, command=lambda: jouer_category(NR_SERIES["NR2"], "NR2")).pack(
    side="left", padx=3)
tk.Button(d2d3_frame, text="C1C3", font=default_font, command=lambda: jouer_category(NR_SERIES["NR3"], "NR3")).pack(
    side="left", padx=3)

# --- 3. SOUS-BLOC : FIN 2 DERN ---
fin2dern_frame = tk.Frame(bloc_complet, bg='lightblue', borderwidth=2, relief="solid")
fin2dern_frame.pack(fill="x", padx=5, pady=5)

# Variable d'affichage
fin2dern_var = tk.StringVar(value="FIN 2 DERN")

# Label tr√®s visible
label_fin2dern = tk.Label(
    fin2dern_frame,
    textvariable=fin2dern_var,
    font=("Arial", 12, "bold"),
    bg="lightgray",
    fg="black",
    width=25,
    height=2,
    anchor="center",
    relief="sunken"
)
label_fin2dern.pack(pady=5, padx=10)


# Fonction de mise √† jour
def update_fin2dern(last_number):
    global fin2dern_ec, fin2dern_last_finales
    if len(history) < 2:
        fin2dern_ec = 0
        fin2dern_var.set("FIN 2 DERN")
        label_fin2dern.config(bg="lightgray")
        return
    if len(history) >= 3:
        cible1 = history[-3]
        cible2 = history[-2]
        final_cible1 = cible1 % 10
        final_cible2 = cible2 % 10
    else:
        fin2dern_ec = 0
        fin2dern_var.set("FIN 2 DERN")
        return
    final_last = last_number % 10
    if final_last == final_cible1 or final_last == final_cible2:
        fin2dern_ec = 0
        fin2dern_var.set("FIN 2 DERN")
        label_fin2dern.config(bg="lightgray", fg="black")
    else:
        fin2dern_ec += 1
        final_prev = history[-2] % 10
        final_curr = history[-1] % 10
        fin2dern_last_finales = (final_prev, final_curr)
        if fin2dern_ec >= 7:
            text = f"FIN 2 DERN: ({final_prev}‚Äì{final_curr}) Ec={fin2dern_ec}"
            fin2dern_var.set(text)
            label_fin2dern.config(bg="red", fg="white")
        else:
            fin2dern_var.set("FIN 2 DERN")


# Fonction pour le bouton de jeu
def play_fin2dern():
    if fin2dern_ec >= 7 and fin2dern_last_finales != (None, None):
        f1, f2 = fin2dern_last_finales
        numbers = list(set(FINALES[f1] + FINALES[f2]))
        play_numbers(numbers)


# Bouton de jeu
tk.Button(
    fin2dern_frame,
    text="FIN 2 DERN",
    font=("Arial", 10, "bold"),
    bg="blue",
    fg="white",
    borderwidth=7,
    command=play_fin2dern
).pack(pady=5, padx=10, ipadx=10)

# =================================================
# --- Variables globales ---[ code mosaique debut]
# =================================================

f23_numbers = []
f14_numbers = []
high_numbers = []
low_numbers = []

f23_ec = 0
f14_ec = 0
high_ec = 0
low_ec = 0

f23_ecmx = 0
f14_ecmx = 0
high_ecmx = 0
low_ecmx = 0

# --- Variables d'affichage ---
f23_display_var = tk.StringVar(value="f23")
f14_display_var = tk.StringVar(value="f14")
high_display_var = tk.StringVar(value="high")
low_display_var = tk.StringVar(value="low")

f23_ec_var = tk.StringVar(value="Ec: 0")
f14_ec_var = tk.StringVar(value="Ec: 0")
high_ec_var = tk.StringVar(value="Ec: 0")
low_ec_var = tk.StringVar(value="Ec: 0")

f23_ecmx_var = tk.StringVar(value="Ecmx: 0")
f14_ecmx_var = tk.StringVar(value="Ecmx: 0")
high_ecmx_var = tk.StringVar(value="Ecmx: 0")
low_ecmx_var = tk.StringVar(value="Ecmx: 0")

# Compteurs de nombres
high_count_var = tk.StringVar(value="0")
low_count_var = tk.StringVar(value="0")

# Dictionnaire des compteurs pour chaque num√©ro (0 √† 36)
compteurs = {num: 0 for num in range(37)}
ecart = {num: 0 for num in range(37)}
counter_labels = {}
ecart_labels = {}

# Variables globales pour les distances
distance_counters = {f"T{i}": {"NS": 0, "Ec": 0, "Exmx": 0} for i in range(1, 14)}
distance_history = []
tx_numbers = []
tx_vars = {}  # Ajoutez cette ligne si elle n'existe pas d√©j√†

# Variables pour le syst√®me 3DEN
det_ecart_simple = 0
det_ecart_max = 0
# ‚≠ê AJOUTE CETTE LIGNE ICI ‚≠ê
ecart_max_prx = 0  # Variable pour l'√©cart max de PRX
det_alerte_seuil = 10
# Variables pour MontCG
montcg_current_gap = tk.StringVar(value="0")
montcg_numero_max = tk.StringVar(value="0")
montcg_sequence_var = tk.StringVar(value="")
montcg_spin_var = tk.StringVar(value="0")
montante_sequence_complete = []  # ‚≠ê AJOUTE CETTE LIGNE ‚≠ê
# Variable pour le bouton dynamique A/B
ab_alert_active = False
ab_blink_job = None  # Pour contr√¥ler le clignotement
# === FONCTIONS : CR√âATION ET MISE √Ä JOUR DES LABELS ===

def create_counter_label(parent, num, button_widget):
    """Cr√©e un petit label carr√© dans le coin sup√©rieur droit du bouton"""
    label = tk.Label(parent,
                     text=str(compteurs[num]),
                     font=("Arial", 9, "bold"),
                     bg="white",
                     fg="black",
                     width=3,
                     height=1,
                     relief="solid",
                     bd=1)
    x_offset = button_widget.winfo_x() + button_widget.winfo_width() - 30
    y_offset = button_widget.winfo_y() + 1
    label.place(x=x_offset, y=y_offset)
    counter_labels[num] = label


def update_counter_display(num):
    """Met √† jour l'affichage du compteur pour un num√©ro donn√©"""
    if num in counter_labels and counter_labels[num].winfo_exists():
        counter_labels[num].config(text=str(compteurs[num]))


def create_ecart_label(parent, num, button_widget):
    """Cr√©e un petit label carr√© dans le coin inf√©rieur gauche du bouton"""
    label = tk.Label(parent,
                     text=str(ecart[num]),
                     font=("Helvetica", 9, "bold"),
                     bg="#99FF99",
                     fg="black",
                     width=3,
                     height=1,
                     relief="solid",
                     bd=1)
    x_offset = button_widget.winfo_x() + 1
    y_offset = button_widget.winfo_y() + button_widget.winfo_height() - 24
    label.place(x=x_offset, y=y_offset)
    ecart_labels[num] = label


def update_ecart_display(num):
    """Met √† jour l'affichage de l'√©cart pour un num√©ro donn√©"""
    if num in ecart_labels and ecart_labels[num].winfo_exists():
        ecart_labels[num].config(text=str(ecart[num]))


# === MISE √Ä JOUR DES LABELS APR√àS AFFICHAGE ===
def setup_labels():
    keyboard_frame.update_idletasks()
    for num, btn in buttons.items():
        if btn.winfo_exists():
            create_counter_label(keyboard_frame, num, btn)
            create_ecart_label(keyboard_frame, num, btn)


root.after(300, setup_labels)


# ====== FIN DU BLOC ======

def jouer_category(numbers, category_name):
    # Impl√©mentez cette fonction si elle n'existe pas
    pass


# ==========================================================
# ------ 2. CADRE PRINCIPAL (conteneur des 2 cadres) ------
# ==========================================================

main_container_frame = tk.Frame(main_frame, bg="white", borderwidth=0)
main_container_frame.grid(row=2, column=2, padx=10, pady=10, sticky="nsew")

# ------ 4. CADRE "TCA" (au milieu) ------
tca_frame = tk.Frame(main_container_frame, borderwidth=2, relief="groove", bg="lightgray")

# Boutons TCA1 √† TCA5
for i in range(5):
    btn = tk.Button(tca_frame, text=f"TCA{i + 1}", font=default_font,
                    command=lambda idx=i: play_remaining_numbers(history[-(idx + 1):]))
    btn.grid(row=0, column=i, padx=5, pady=5)

# ------ 5. CADRE "D2D3/C1C2/etc" (en bas) ------
combos_frame = tk.Frame(main_container_frame, borderwidth=2, relief="groove", bg="lightgray")

# Boutons des combinaisons
buttons = [("D2D3", "NR1"), ("C2C3", "NR4"), ("C1C2", "NR2"), ("C1C3", "NR3")]
for col, (text, nr) in enumerate(buttons):
    tk.Button(combos_frame, text=text, font=default_font,
              command=lambda nr=nr: jouer_category(NR_SERIES[nr], nr)).grid(row=0, column=col, padx=5)

# ------ CONFIGURATION FINALE ------
main_container_frame.grid_columnconfigure(0, weight=1)  # √âtirement horizontal
for frame in [tca_frame, combos_frame]:  # On a enlev√© detection_frame de la liste
    frame.grid_propagate(False)  # D√©sactive le redimensionnement automatique
    frame.config(width=300, height=40)  # Dimensions fixes (ajustables)
# ====== FIN DU BLOC √Ä COPIER ======


# Appliquer la police par d√©faut √† tous les widgets
root.option_add("*Font", default_font)

# D√©finir la variable pour les boutons radio (R/B, E/O, L/H)
mode_var = tk.StringVar(value="RB")  # Valeur par d√©faut : "RB"

# Variables pour les compteurs
red_counter = tk.StringVar()
red_counter.set("0")

black_counter = tk.StringVar()
black_counter.set("0")

pair_counter = tk.StringVar()
pair_counter.set("0")

impair_counter = tk.StringVar()
impair_counter.set("0")

manque_counter = tk.StringVar()
manque_counter.set("0")

passe_counter = tk.StringVar()
passe_counter.set("0")

# Nouveaux compteurs pour les nouveaux boutons
vo_counter = tk.StringVar()
vo_counter.set("0")

tie_counter = tk.StringVar()
tie_counter.set("0")

oph_counter = tk.StringVar()
oph_counter.set("0")

# Ajoutez ceci apr√®s les autres compteurs et listes
# dlo_last_trigger = None  # ‚Üê ajoutez cette ligne

# Variable globale pour l'√©cart du cadre D√©t
det_ecart = 0

# Ajoutez ceci apr√®s les autres compteurs
det_ecart_counter = tk.StringVar()
det_ecart_counter.set("0")
# Compteurs pour NR1, NR2, NR3, NR4
nr1_counter = tk.StringVar()
nr1_counter.set("0")

nr2_counter = tk.StringVar()
nr2_counter.set("0")

nr3_counter = tk.StringVar()
nr3_counter.set("0")

nr4_counter = tk.StringVar()
nr4_counter.set("0")

# Listes pour stocker les num√©ros de chaque cat√©gorie
red_numbers_list = []
black_numbers_list = []
pair_numbers_list = []
impair_numbers_list = []
manque_numbers_list = []
passe_numbers_list = []

# Nouvelles listes pour les nouveaux boutons
vo_numbers_list = []
tie_numbers_list = []
oph_numbers_list = []
# Listes pour NR1, NR2, NR3, NR4
nr1_numbers_list = []
nr2_numbers_list = []
nr3_numbers_list = []
nr4_numbers_list = []

# Dictionnaire pour stocker les coordonn√©es (X, Y) des num√©ros et des chances simples
coordinates = {num: (0, 0) for num in range(37)}
# Ajouter les chances simples
for chance in ["R", "N", "PA", "IP", "Mq", "Pss", "D1", "D2", "D3", "C1", "C2", "C3"]:
    coordinates[chance] = (0, 0)
# Compteur d'affichage pour chaque num√©ro (0 √† 36)
compteurs = {num: 0 for num in range(37)}
# √âcart de sortie pour chaque num√©ro (0 √† 36)
ecart = {num: 0 for num in range(37)}
# Dictionnaire pour stocker les labels d'√©cart (petits carr√©s en bas √† gauche)
ecart_labels = {}

# S√©ries en m√©moire
series_memory = [[] for _ in range(28)]  # 28 s√©ries vides
series_names = list(SERIES.keys())  # Noms des s√©ries

# Compteurs NS, Ec, et Ecmx pour chaque s√©rie
ns_values = {serie: 0 for serie in SERIES.keys()}
ec_values = {serie: 0 for serie in SERIES.keys()}
ecmx_values = {serie: 0 for serie in SERIES.keys()}

# Cr√©ation du cadre principal SIXTUAL
sixtual_frame = tk.Frame(main_frame, borderwidth=2, relief="groove")
sixtual_frame.grid(row=0, column=70, padx=60, pady=10, sticky="nw")

# Ajouter un label pour le titre SIXTUAL
tk.Label(sixtual_frame, text="SIXTUAL", font=("Arial", 12, "bold")).grid(row=0, column=0, columnspan=20, pady=5)

# ===============================================
# BLOC UNIFI√â : DYZA + D√©t + RED/NR ‚Üí OPH/VO/TIE
# ===============================================

# --- CONTENEUR PRINCIPAL UNIFI√â ---
unified_frame = tk.Frame(main_group_frame, borderwidth=3, relief="ridge", bg="Darksalmon", width=250)
unified_frame.grid(row=0, column=5, padx=10, pady=10, sticky="n")
unified_frame.columnconfigure(0, weight=1)

# --- SOUS-CADRE DYZA (en haut) ---
dyza_frame = tk.Frame(unified_frame, borderwidth=2, relief="raised", bg="lightyellow")
dyza_frame.grid(row=0, column=0, padx=5, pady=(5, 2), sticky="ew")


# Cr√©ation des 3 cercles c√¥te √† c√¥te dans dyza_frame
# Cercle Rouge/Noir
rn_canvas = tk.Canvas(dyza_frame, width=60, height=60, bg="lightgray", highlightthickness=0)
rn_canvas.grid(row=0, column=1, padx=5, pady=5)

# Cercle Pair/Impair
pi_canvas = tk.Canvas(dyza_frame, width=60, height=60, bg="lightgray", highlightthickness=0)
pi_canvas.grid(row=1, column=1, padx=5, pady=5)

# Cercle Manque/Passe
mp_canvas = tk.Canvas(dyza_frame, width=60, height=60, bg="lightgray", highlightthickness=0)
mp_canvas.grid(row=2, column=1, padx=5, pady=5)

# --- SOUS-CADRE COMBIN√â (en bas) ---
combined_frame = tk.Frame(unified_frame, bg='lightgray', borderwidth=2, relief="groove",
                          height=220)
combined_frame.grid(row=1, column=0, padx=5, pady=(2, 5), sticky="ew")
combined_frame.pack_propagate(False)
combined_frame.columnconfigure(0, weight=1)


# Fonction pour copier et jouer les num√©ros d√©tect√©s (SEULE VERSION √Ä GARDER)
def play_detected_numbers():
    global det_ecart_counter

    detected_text = detected_numbers_label.cget("text")
    if detected_text:
        numbers = [int(num) for num in detected_text.split() if num.isdigit()]
        if numbers:
            print(f"üîç Num√©ros √† jouer: {numbers}")
            print(f"üìä √âcart avant: {det_ecart_counter.get()}")
            print(f"üìã Historique avant: {history[-5:] if len(history) > 5 else history}")

            # Jouer les num√©ros
            play_numbers(numbers)

            print(f"üìã Historique apr√®s: {history[-5:] if len(history) > 5 else history}")

            if history:
                last_played_number = history[-1]
                print(f"üî¢ Dernier num√©ro jou√©: {last_played_number}")
                print(f"üìã Liste des d√©tect√©s: {numbers}")
                print(f"‚ùì Le dernier est-il dans la liste? {last_played_number in numbers}")

                if last_played_number in numbers:
                    det_ecart_counter.set(0)
                    print("‚úÖ √âcart r√©initialis√© √† 0")
                else:
                    det_ecart_counter.set(det_ecart_counter.get() + 1)
                    print(f"‚û°Ô∏è √âcart incr√©ment√© √† {det_ecart_counter.get()}")
            else:
                print("‚ùå Historique vide!")

        else:
            messagebox.showwarning("Avertissement", "Aucun num√©ro d√©tect√© √† jouer.")
    else:
        messagebox.showwarning("Avertissement", "Aucun num√©ro d√©tect√© √† jouer.")




# --- COMPTEUR D'√âCART √Ä LA POSITION row=2, column=3 ---
# ecart_frame = tk.Frame(main_group_frame, bg="lightgray")
# ecart_frame.grid(row=2, column=3, padx=5, pady=(5, 10), sticky="ew")

# tk.Label(ecart_frame, text="√âcart Det:", bg="lightgray", font=default_font).pack(side="left", padx=5)
# ecart_label = tk.Label(ecart_frame, text="0", bg="white", font=default_font, width=5, relief="sunken")
# ecart_label.pack(side="left", padx=5)


# --- SOUS-CADRE VERTICAL COMPLET : RED/NR ‚Üí OPH/VO/TIE ---

# === NOUVEAU CONTENEUR HORIZONTAL POUR LES 9 BOUTONS + CLAVIER ===
horizontal_container = tk.Frame(combined_frame, bg='yellow')  # Couleur temporaire pour voir
horizontal_container.pack(fill="both", expand=True)

# ===================================================
# AJOUT : SYSTEME  VISION  - VERSION FINALE CORRIGEE
# ===================================================

# systeme vision
# Table de vision
VISION = {
    0: [0, 1, 2, 0, 1, 2, 20, 21, 25, 26, 32, 33, ],
    1: [1, 2, 3, 1, 2, 3, 20, 21, 25, 26, 33, 35, ],
    2: [2, 3, 4, 2, 3, 4, 11, 19, 21, 25, 26, 35, ],
    3: [3, 4, 5, 3, 4, 5, 10, 19, 21, 24, 26, 35, ],
    4: [4, 5, 6, 4, 5, 6, 10, 19, 21, 24, 27, 34, ],
    5: [5, 6, 7, 5, 6, 7, 10, 24, 27, 28, 29, 34, ],
    6: [6, 7, 8, 6, 7, 8, 23, 27, 28, 29, 30, 34, ],
    7: [7, 8, 9, 7, 8, 9, 22, 23, 28, 29, 30, 31, ],
    8: [8, 9, 10, 8, 9, 10, 5, 22, 23, 30, 31, 17, ],
    9: [9, 10, 11, 9, 10, 11, 5, 22, 23, 30, 31, 36, ],
    10: [10, 11, 12, 10, 11, 12, 5, 23, 28, 30, 35, 36, ],
    11: [11, 12, 13, 11, 12, 13, 27, 28, 30, 35, 36, 29, ],
    12: [12, 13, 14, 12, 13, 14, 20, 27, 28, 31, 35, 36, ],
    13: [13, 14, 15, 13, 14, 15, 19, 20, 27, 31, 32, 36, ],
    14: [14, 15, 16, 14, 15, 16, 19, 20, 24, 31, 32, 33, ],
    15: [15, 16, 17, 15, 16, 17, 19, 24, 25, 32, 33, 34, ],
    16: [16, 17, 18, 16, 17, 18, 22, 24, 25, 29, 33, 34, ],
    17: [17, 18, 19, 17, 18, 19, 4, 15, 22, 25, 29, 34, ],
    18: [18, 19, 20, 18, 19, 20, 1, 4, 14, 15, 22, 29, ],
    19: [19, 20, 21, 19, 20, 21, 1, 2, 4, 14, 15, 16, ],
    20: [20, 21, 22, 20, 21, 22, 1, 2, 4, 9, 14, 18, ],
    21: [21, 22, 23, 21, 22, 23, 2, 4, 8, 9, 10, 18, ],
    22: [22, 23, 24, 22, 23, 24, 5, 8, 9, 10, 16, 18, ],
    23: [23, 24, 25, 23, 24, 25, 2, 5, 8, 10, 16, 17, ],
    24: [24, 25, 26, 24, 25, 26, 0, 2, 3, 5, 16, 17, ],
    25: [25, 26, 27, 25, 26, 27, 0, 2, 3, 6, 13, 17, ],
    26: [26, 27, 28, 26, 27, 28, 0, 3, 6, 7, 12, 13, ],
    27: [27, 28, 29, 27, 28, 29, 6, 7, 12, 13, 18, 25, ],
    28: [28, 29, 30, 28, 29, 30, 7, 8, 11, 12, 18, 24, ],
    29: [29, 30, 31, 29, 30, 31, 7, 8, 9, 11, 14, 18, ],
    30: [30, 31, 32, 30, 31, 32, 0, 8, 9, 11, 14, 15, ],
    31: [31, 32, 33, 31, 32, 33, 0, 1, 9, 14, 15, 16, ],
    32: [32, 33, 34, 32, 33, 34, 0, 1, 6, 15, 16, 17, ],
    33: [33, 34, 35, 33, 34, 35, 1, 3, 6, 12, 16, 17, ],
    34: [34, 35, 36, 34, 35, 36, 3, 6, 11, 12, 13, 17, ],
    35: [35, 36, 35, 36, 3, 11, 12, 13, 32, 34, 17, ],
    36: [0, 36, 36, 11, 13, 1, 15, 33, 35, 9, ]
}


#  Systeme vision

# Fonction pour g√©rer le clic sur un bouton du clavier vision
def on_vision_click(number):
    associated_numbers = VISION.get(number, [])
    play_numbers(associated_numbers)


# Cr√©ation du mini-clavier vision
# Cr√©ation du mini-clavier vision
vision_frame = tk.Frame(horizontal_container)  # CORRECTION
vision_frame.pack(side="right",fill="both",padx=10)    # √Ä droite des 9 boutons

# D√©finir la disposition des boutons
button_layout = [
    [0, 1, 2, 3, 4, 5, 6],
    [7, 8, 9, 10, 11, 12, 13],
    [14, 15, 16, 17, 18, 19, 20],
    [21, 22, 23, 24, 25, 26, 27],
    [28, 29, 29, 30, 31, 32, 33],
    [34, 35, 36]
]

# Cr√©ation des boutons
for row_idx, row in enumerate(button_layout):
    for col_idx, num in enumerate(row):
        btn = tk.Button(
            vision_frame,
            text=str(num),
            width=3,
            height=1,
            font=default_font,
            command=lambda n=num: on_vision_click(n)
        )
        btn.grid(row=row_idx, column=col_idx, padx=1, pady=1)








# --- SOUS-CADRE VERTICAL COMPLET : RED/NR ‚Üí OPH/VO/TIE (√Ä GAUCHE) ---
vertical_group_frame = tk.Frame(horizontal_container, bg='lightblue')
vertical_group_frame.pack(side="left", fill="both", expand=True)



vertical_group_frame.pack_propagate(False)

# --- 1. LIGNE : RED / NOIR ---
red_nr_frame = tk.Frame(vertical_group_frame, bg='lightblue')
red_nr_frame.pack(fill="x", pady=1)

# Cadre RED
red_frame = tk.Frame(red_nr_frame, bg="black", width=85, height=35)  # Hauteur r√©duite
red_frame.pack(side="left", fill="y", padx=1)
red_frame.pack_propagate(False)

red_main_frame = tk.Frame(red_frame, bg="black")
red_main_frame.pack(fill="both", expand=True)
tk.Label(red_main_frame, textvariable=red_counter, bg="black", fg="white", font=default_font).pack(side="left", padx=2)
red_button = tk.Button(red_main_frame, text="Red", bg="red", fg="white", font=default_font,
                       command=lambda: jouer_category(red_numbers_list, "RED"), width=4)
red_button.pack(side="left", padx=2)

# Canvas RED
red_canvas = tk.Canvas(red_main_frame, bg="black", height=25, width=20)
red_scrollbar = tk.Scrollbar(red_frame, orient="horizontal", command=red_canvas.xview)
red_canvas.configure(xscrollcommand=red_scrollbar.set)
red_inner_frame = tk.Frame(red_canvas, bg="black")
red_canvas.create_window((0, 0), window=red_inner_frame, anchor="nw")
red_inner_frame.bind("<Configure>", lambda e: red_canvas.configure(scrollregion=red_canvas.bbox("all")))
red_canvas.pack(side="left", fill="both", expand=True)
red_scrollbar.pack(side="bottom", fill="x")

# Cadre NOIR
black_frame = tk.Frame(red_nr_frame, bg="black", width=85, height=35)
black_frame.pack(side="left", fill="y", padx=1)
black_frame.pack_propagate(False)

black_main_frame = tk.Frame(black_frame, bg="black")
black_main_frame.pack(fill="both", expand=True)
tk.Label(black_main_frame, textvariable=black_counter, bg="black", fg="white", font=default_font).pack(side="left",
                                                                                                       padx=2)
black_button = tk.Button(black_main_frame, text="NR", bg="black", fg="white", font=default_font,
                         command=lambda: jouer_category(black_numbers_list, "NOIRS"), width=4)
black_button.pack(side="left", padx=2)

# Canvas NOIR
black_canvas = tk.Canvas(black_main_frame, bg="black", height=25, width=20)
black_scrollbar = tk.Scrollbar(black_frame, orient="horizontal", command=black_canvas.xview)
black_canvas.configure(xscrollcommand=black_scrollbar.set)
black_inner_frame = tk.Frame(black_canvas, bg="black")
black_canvas.create_window((0, 0), window=black_inner_frame, anchor="nw")
black_inner_frame.bind("<Configure>", lambda e: black_canvas.configure(scrollregion=black_canvas.bbox("all")))
black_canvas.pack(side="left", fill="both", expand=True)
black_scrollbar.pack(side="bottom", fill="x")

# --- 2. LIGNE : PA / IMP ---
pa_imp_frame = tk.Frame(vertical_group_frame, bg='lightblue')
pa_imp_frame.pack(fill="x", pady=1)

# Cadre PA
pair_frame = tk.Frame(pa_imp_frame, bg="black", width=85, height=35)
pair_frame.pack(side="left", fill="y", padx=1)
pair_frame.pack_propagate(False)

pair_main_frame = tk.Frame(pair_frame, bg="black")
pair_main_frame.pack(fill="both", expand=True)
tk.Label(pair_main_frame, textvariable=pair_counter, bg="black", fg="white", font=default_font).pack(side="left",
                                                                                                     padx=2)
pair_button = tk.Button(pair_main_frame, text="PA", bg="black", fg="white", font=default_font,
                        command=lambda: jouer_category(pair_numbers_list, "PAIRS"), width=4)
pair_button.pack(side="left", padx=2)

# Canvas PA
pair_canvas = tk.Canvas(pair_main_frame, bg="black", height=25, width=20)
pair_scrollbar = tk.Scrollbar(pair_frame, orient="horizontal", command=pair_canvas.xview)
pair_canvas.configure(xscrollcommand=pair_scrollbar.set)
pair_inner_frame = tk.Frame(pair_canvas, bg="black")
pair_canvas.create_window((0, 0), window=pair_inner_frame, anchor="nw")
pair_inner_frame.bind("<Configure>", lambda e: pair_canvas.configure(scrollregion=pair_canvas.bbox("all")))
pair_canvas.pack(side="left", fill="both", expand=True)
pair_scrollbar.pack(side="bottom", fill="x")

# Cadre IMP
impair_frame = tk.Frame(pa_imp_frame, bg="black", width=85, height=35)
impair_frame.pack(side="left", fill="y", padx=1)
impair_frame.pack_propagate(False)

impair_main_frame = tk.Frame(impair_frame, bg="black")
impair_main_frame.pack(fill="both", expand=True)
tk.Label(impair_main_frame, textvariable=impair_counter, bg="black", fg="white", font=default_font).pack(side="left",
                                                                                                         padx=2)
impair_button = tk.Button(impair_main_frame, text="IMP", bg="black", fg="white", font=default_font,
                          command=lambda: jouer_category(impair_numbers_list, "IMPAIRS"), width=4)
impair_button.pack(side="left", padx=2)

# Canvas IMP
impair_canvas = tk.Canvas(impair_main_frame, bg="black", height=25, width=20)
impair_scrollbar = tk.Scrollbar(impair_frame, orient="horizontal", command=impair_canvas.xview)
impair_canvas.configure(xscrollcommand=impair_scrollbar.set)
impair_inner_frame = tk.Frame(impair_canvas, bg="black")
impair_canvas.create_window((0, 0), window=impair_inner_frame, anchor="nw")
impair_inner_frame.bind("<Configure>", lambda e: impair_canvas.configure(scrollregion=impair_canvas.bbox("all")))
impair_canvas.pack(side="left", fill="both", expand=True)
impair_scrollbar.pack(side="bottom", fill="x")

# --- 3. LIGNE : Maq / Pss ---
maq_pss_frame = tk.Frame(vertical_group_frame, bg='lightblue')
maq_pss_frame.pack(fill="x", pady=1)

# Cadre Maq
manque_frame = tk.Frame(maq_pss_frame, bg="black", width=85, height=35)
manque_frame.pack(side="left", fill="y", padx=1)
manque_frame.pack_propagate(False)

manque_main_frame = tk.Frame(manque_frame, bg="black")
manque_main_frame.pack(fill="both", expand=True)
tk.Label(manque_main_frame, textvariable=manque_counter, bg="black", fg="white", font=default_font).pack(side="left",
                                                                                                         padx=2)
manque_button = tk.Button(manque_main_frame, text="Maq", bg="black", fg="white", font=default_font,
                          command=lambda: jouer_category(manque_numbers_list, "MANQUES"), width=4)
manque_button.pack(side="left", padx=2)

# Canvas Maq
manque_canvas = tk.Canvas(manque_main_frame, bg="black", height=25, width=20)
manque_scrollbar = tk.Scrollbar(manque_frame, orient="horizontal", command=manque_canvas.xview)
manque_canvas.configure(xscrollcommand=manque_scrollbar.set)
manque_inner_frame = tk.Frame(manque_canvas, bg="black")
manque_canvas.create_window((0, 0), window=manque_inner_frame, anchor="nw")
manque_inner_frame.bind("<Configure>", lambda e: manque_canvas.configure(scrollregion=manque_canvas.bbox("all")))
manque_canvas.pack(side="left", fill="both", expand=True)
manque_scrollbar.pack(side="bottom", fill="x")

# Cadre Pss
passe_frame = tk.Frame(maq_pss_frame, bg="black", width=85, height=35)
passe_frame.pack(side="left", fill="y", padx=1)
passe_frame.pack_propagate(False)

passe_main_frame = tk.Frame(passe_frame, bg="black")
passe_main_frame.pack(fill="both", expand=True)
tk.Label(passe_main_frame, textvariable=passe_counter, bg="black", fg="white", font=default_font).pack(side="left",
                                                                                                       padx=2)
passe_button = tk.Button(passe_main_frame, text="Pss", bg="black", fg="white", font=default_font,
                         command=lambda: jouer_category(passe_numbers_list, "PASSES"), width=4)
passe_button.pack(side="left", padx=2)

# Canvas Pss
passe_canvas = tk.Canvas(passe_main_frame, bg="black", height=25, width=20)
passe_scrollbar = tk.Scrollbar(passe_frame, orient="horizontal", command=passe_canvas.xview)
passe_canvas.configure(xscrollcommand=passe_scrollbar.set)
passe_inner_frame = tk.Frame(passe_canvas, bg="black")
passe_canvas.create_window((0, 0), window=passe_inner_frame, anchor="nw")
passe_inner_frame.bind("<Configure>", lambda e: passe_canvas.configure(scrollregion=passe_canvas.bbox("all")))
passe_canvas.pack(side="left", fill="both", expand=True)
passe_scrollbar.pack(side="bottom", fill="x")

# --- 4. LIGNE : OPH / VO ---
oph_vo_frame = tk.Frame(vertical_group_frame, bg='lightblue')
oph_vo_frame.pack(fill="x", pady=1)

# Cadre OPH
oph_frame = tk.Frame(oph_vo_frame, bg="purple", width=85, height=35)
oph_frame.pack(side="left", fill="y", padx=1)
oph_frame.pack_propagate(False)

oph_main_frame = tk.Frame(oph_frame, bg="purple")
oph_main_frame.pack(fill="both", expand=True)
tk.Label(oph_main_frame, textvariable=oph_counter, bg="purple", fg="white", font=default_font).pack(side="left", padx=2)
oph_button = tk.Button(oph_main_frame, text="OPH", bg="purple", fg="white", font=default_font,
                       command=lambda: jouer_category(oph_numbers_list, "OPH"), width=4)
oph_button.pack(side="left", padx=2)

# Canvas OPH
oph_canvas = tk.Canvas(oph_main_frame, bg="purple", height=25, width=20)
oph_scrollbar = tk.Scrollbar(oph_frame, orient="horizontal", command=oph_canvas.xview)
oph_canvas.configure(xscrollcommand=oph_scrollbar.set)
oph_inner_frame = tk.Frame(oph_canvas, bg="purple")
oph_canvas.create_window((0, 0), window=oph_inner_frame, anchor="nw")
oph_inner_frame.bind("<Configure>", lambda e: oph_canvas.configure(scrollregion=oph_canvas.bbox("all")))
oph_canvas.pack(side="left", fill="both", expand=True)
oph_scrollbar.pack(side="bottom", fill="x")

# Cadre VO
vo_frame = tk.Frame(oph_vo_frame, bg="darkgreen", width=85, height=35)
vo_frame.pack(side="left", fill="y", padx=1)
vo_frame.pack_propagate(False)

vo_main_frame = tk.Frame(vo_frame, bg="darkgreen")
vo_main_frame.pack(fill="both", expand=True)
tk.Label(vo_main_frame, textvariable=vo_counter, bg="darkgreen", fg="white", font=default_font).pack(side="left",
                                                                                                     padx=2)
vo_button = tk.Button(vo_main_frame, text="VO", bg="darkgreen", fg="white", font=default_font,
                      command=lambda: jouer_category(vo_numbers_list, "VO"), width=4)
vo_button.pack(side="left", padx=2)

# Canvas VO
vo_canvas = tk.Canvas(vo_main_frame, bg="darkgreen", height=25, width=20)
vo_scrollbar = tk.Scrollbar(vo_frame, orient="horizontal", command=vo_canvas.xview)
vo_canvas.configure(xscrollcommand=vo_scrollbar.set)
vo_inner_frame = tk.Frame(vo_canvas, bg="darkgreen")
vo_canvas.create_window((0, 0), window=vo_inner_frame, anchor="nw")
vo_inner_frame.bind("<Configure>", lambda e: vo_canvas.configure(scrollregion=vo_canvas.bbox("all")))
vo_canvas.pack(side="left", fill="both", expand=True)
vo_scrollbar.pack(side="bottom", fill="x")

# --- 5. LIGNE : TIE ---
tie_frame_line = tk.Frame(vertical_group_frame, bg='lightblue')
tie_frame_line.pack(fill="x", pady=1)

# Cadre TIE
tie_frame = tk.Frame(tie_frame_line, bg="darkblue", width=85, height=35)
tie_frame.pack(side="left", fill="y", padx=1)
tie_frame.pack_propagate(False)

tie_main_frame = tk.Frame(tie_frame, bg="darkblue")
tie_main_frame.pack(fill="both", expand=True)
tk.Label(tie_main_frame, textvariable=tie_counter, bg="darkblue", fg="white", font=default_font).pack(side="left",
                                                                                                      padx=2)
tie_button = tk.Button(tie_main_frame, text="TIE", bg="darkblue", fg="white", font=default_font,
                       command=lambda: jouer_category(tie_numbers_list, "TIE"), width=4)
tie_button.pack(side="left", padx=2)

# Canvas TIE
tie_canvas = tk.Canvas(tie_main_frame, bg="darkblue", height=25, width=20)
tie_scrollbar = tk.Scrollbar(tie_frame, orient="horizontal", command=tie_canvas.xview)
tie_canvas.configure(xscrollcommand=tie_scrollbar.set)
tie_inner_frame = tk.Frame(tie_canvas, bg="darkblue")
tie_canvas.create_window((0, 0), window=tie_inner_frame, anchor="nw")
tie_inner_frame.bind("<Configure>", lambda e: tie_canvas.configure(scrollregion=tie_canvas.bbox("all")))
tie_canvas.pack(side="left", fill="both", expand=True)
tie_scrollbar.pack(side="bottom", fill="x")

# D√©clarer history comme une liste vide pour stocker l'historique des num√©ros
history = []

# Initialisation des zones de stockage et des compteurs pour le d√©versoir
stk_values = {i: set(range(37)) if i == 0 else set() for i in range(11)}  # STK0 contient tous les num√©ros au d√©part
stk_counters = {i: tk.StringVar(value=str(len(stk_values[i]))) for i in range(11)}  # Compteurs pour chaque STK

# Variables pour les fl√®ches
arrow_labels = [tk.StringVar(value="‚âà") for _ in range(11)]  # Fl√®ches par d√©faut : "‚âà"


# Fonction pour d√©placer un num√©ro entre les zones de stockage
def move_number(number):
    for i in range(10, -1, -1):  # Parcourir de STK10 √† STK0
        if number in stk_values[i]:
            stk_values[i].remove(number)  # Retirer le num√©ro de la zone actuelle
            if i < 10:  # Si ce n'est pas la derni√®re zone, d√©placer vers la suivante
                stk_values[i + 1].add(number)
            stk_counters[i].set(str(len(stk_values[i])))  # Mettre √† jour le compteur de la zone actuelle
            if i < 10:
                stk_counters[i + 1].set(str(len(stk_values[i + 1])))  # Mettre √† jour le compteur de la zone suivante
            break
    check_alerts()  # V√©rifier les alertes apr√®s chaque d√©placement


# Fonction pour v√©rifier les alertes
def check_alerts():
    # Condition 1 : STK1 >= 8 et STK2 = 0
    if int(stk_counters[1].get()) >= 8 and int(stk_counters[2].get()) == 0:
        stk_labels[1].config(bg="blue", fg="white")
    else:
        stk_labels[1].config(bg="SystemButtonFace", fg="black")

    # Condition 2 : STK2 = 1
    if int(stk_counters[2].get()) == 1:
        stk_labels[0].config(bg="blue", fg="white")
    else:
        stk_labels[0].config(bg="SystemButtonFace", fg="black")

    # Condition 3 : STK3 = 1
    if int(stk_counters[3].get()) == 1:
        stk_labels[2].config(bg="blue", fg="white")
    else:
        stk_labels[2].config(bg="SystemButtonFace", fg="black")

    # Condition 4 : Nombre de spins entre 20 et 35
    if 20 <= len(history) <= 35:
        stk_labels[2].config(bg="blue", fg="white")
    else:
        stk_labels[2].config(bg="SystemButtonFace", fg="black")

    # Condition 5 : STK0 = 21
    if int(stk_counters[0].get()) == 21:
        stk_labels[0].config(bg="blue", fg="white")
    else:
        stk_labels[0].config(bg="SystemButtonFace", fg="black")

    # Conditions 6 √† 9 : Nombre de spins sp√©cifiques
    if len(history) == 43:
        stk_labels[3].config(bg="blue", fg="white")
    else:
        stk_labels[3].config(bg="SystemButtonFace", fg="black")

    if len(history) == 63:
        stk_labels[4].config(bg="blue", fg="white")
    else:
        stk_labels[4].config(bg="SystemButtonFace", fg="black")

    if len(history) == 85:
        stk_labels[5].config(bg="blue", fg="white")
    else:
        stk_labels[5].config(bg="SystemButtonFace", fg="black")

    if len(history) == 109:
        stk_labels[6].config(bg="blue", fg="white")
    else:
        stk_labels[6].config(bg="SystemButtonFace", fg="black")

    # Conditions 10 √† 14 : Comparaisons entre STK
    for i in range(10):
        for j in range(i + 1, 11):
            count_i = int(stk_counters[i].get())
            count_j = int(stk_counters[j].get())
            if count_i > 0 and count_j > 0 and abs(count_i - count_j) <= 2:
                if count_i > count_j:
                    stk_labels[i].config(bg="blue", fg="white")
                elif count_j > count_i:
                    stk_labels[j].config(bg="blue", fg="white")
                else:
                    if i < j:
                        stk_labels[i].config(bg="blue", fg="white")
                    else:
                        stk_labels[j].config(bg="blue", fg="white")


# =========================================
# Cr√©ation du mini-tableau (D√©versoir 2)
# =========================================
# Cr√©ation du cadre principal pour regrouper les deux cadres
# Remplacer l'ancien code par :
main_container_frame = tk.Frame(sixtual_frame)  # Notez sixtual_frame au lieu de main_frame
main_container_frame.grid(row=1, column=1, columnspan=20, padx=10, pady=10)

# Cr√©ation du cadre parent pour regrouper "D√©versoir" et "Chances Simples"
grouped_frame = tk.Frame(dyza_frame, borderwidth=5, relief="groove")
grouped_frame.grid(row=11, column=0, rowspan=1, padx=10, pady=2, sticky="w")




# Cr√©ation du mini-tableau (D√©versoir 2)
# Cr√©ation du mini-tableau (D√©versoir 2) √† l'int√©rieur du cadre parent
deversoir_frame = tk.Frame(grouped_frame, borderwidth=2, relief="groove")
deversoir_frame.grid(row=0, column=0, padx=5, pady=2, sticky="w")

# Ligne 1 : Boutons de copie (N0 √† N10)
for i in range(11):
    btn = tk.Button(deversoir_frame, text=f"N{i}", font=default_font, borderwidth=2, command=lambda idx=i: copy_stk_numbers(idx))
    btn.grid(row=i, column=0, padx=5, pady=5)

# Ligne 2 : Libell√©s de stockage (STK0 √† STK10)
stk_labels = []
for i in range(11):
    label = tk.Label(deversoir_frame, text=f"STK{i}", font=default_font)
    label.grid(row=i, column=1, padx=5, pady=5)
    stk_labels.append(label)

# Ligne 3 : Fl√®ches (‚Üó, ‚Üò, ‚âà)
for i in range(11):
    arrow_label = tk.Label(deversoir_frame, textvariable=arrow_labels[i], font=default_font)
    arrow_label.grid(row=i, column=2, padx=5, pady=5)

# Ligne 4 : Compteurs
for i in range(11):
    counter_label = tk.Label(deversoir_frame, textvariable=stk_counters[i], font=default_font)
    counter_label.grid(row=i, column=3, padx=5, pady=5)


# Fonction pour mettre √† jour les fl√®ches
def update_arrows():
    for i in range(11):
        if i > 0 and int(stk_counters[i].get()) > int(stk_counters[i - 1].get()):
            arrow_labels[i].set("‚Üó")  # Fl√®che montante
        elif i > 0 and int(stk_counters[i].get()) < int(stk_counters[i - 1].get()):
            arrow_labels[i].set("‚Üò")  # Fl√®che descendante
        else:
            arrow_labels[i].set("‚âà")  # Stable


# Variable pour stocker la derni√®re doublette
last_doublette = tk.StringVar()
last_doublette.set("XX")  # Valeur par d√©faut

# Variables pour stocker les num√©ros adjacents √† la premi√®re borne de la doublette
adjacent_number_1 = tk.StringVar()
adjacent_number_2 = tk.StringVar()
adjacent_number_1.set("XX")
adjacent_number_2.set("XX")


# Fonction pour d√©tecter la derni√®re doublette
def update_last_doublette(number):
    global history, last_doublette, adjacent_number_1, adjacent_number_2
    if len(history) >= 2:
        # Parcourir l'historique √† l'envers pour trouver la derni√®re doublette
        for i in range(len(history) - 2, -1, -1):
            if history[i] == number:
                # Doublette trouv√©e
                last_doublette.set(str(number))
                # R√©cup√©rer les deux num√©ros adjacents √† la premi√®re borne
                if i > 0:
                    adjacent_number_1.set(str(history[i - 1]))
                else:
                    adjacent_number_1.set("XX")
                if i < len(history) - 1:
                    adjacent_number_2.set(str(history[i + 1]))
                else:
                    adjacent_number_2.set("XX")
                return

    # Mise √† jour des labels dans adjacent_subframe (remplace adjacent_frame)
    tk.Label(adjacent_subframe, textvariable=adjacent_number_1, font=("Arial", 9), width=5, bg="white").grid(row=0, column=1, padx=2, pady=2)
    tk.Label(adjacent_subframe, textvariable=adjacent_number_2, font=("Arial", 9), width=5, bg="white").grid(row=0, column=2, padx=2, pady=2)

    # Ne pas r√©initialiser last_doublette si aucune doublette n'est trouv√©e
    # print("Aucune nouvelle doublette trouv√©e.")  # Log pour d√©bogage


# Cadre pour la derni√®re doublette (RDBL)








# Modification de la fonction on_number_click pour inclure check_dbx
# Remplacez la d√©claration de det_ecart_counter
det_ecart_simple = 0  # Variable normale au lieu de IntVar



# Dans on_number_click
def on_number_click(number):
    global detected_numbers, detected_numbers_label, det_ecart_simple
    global dlo_active, dlo1_active, dlo2_active

    # --- D√©sactivation des cadres DLO au tour suivant ---
    dlo_active = False
    dlo1_active = False
    dlo2_active = False
    dlo_display_var.set("")
    dlo1_display_var.set("")
    dlo2_display_var.set("")

    # --- 0. V√âRIFICATION DU COMPTEUR D'√âCART ---
    detected_text = detected_numbers_label.cget("text")
    if detected_text:
        detected_numbers = [int(num) for num in detected_text.split() if num.isdigit()]
        if number in detected_numbers:
            det_ecart_simple = 0
            ecart_label.config(text="0")
        else:
            det_ecart_simple += 1
            ecart_label.config(text=str(det_ecart_simple))

    # --- 1. Ajouter le num√©ro √† l'historique ---
    history.append(number)
    update_history()

    # --- Mise √† jour des syst√®mes DLO (uniquement si pas d√©j√† actifs) ---
    if not dlo_active:
        update_dlo(number)
    if not dlo1_active:
        update_dlo1(number)
    if not dlo2_active:
        update_dlo2(number)

    # --- 2. Mettre √† jour les compteurs de sortie ---
    compteurs[number] += 1
    update_counter_display(number)

    # --- 3. Mettre √† jour les √©carts globaux ---
    for num in range(37):
        if num == number:
            ecart[num] = 0
        else:
            ecart[num] += 1
    for num in range(37):
        if num in ecart_labels:
            ecart_labels[num].config(text=str(ecart[num]))

    # --- 4. Mettre √† jour les affichages ---
    update_counters(number)
    update_all_columns(number)
    move_number(number)
    update_arrows()
    update_ecarts(number)
    update_sous_tableaux()
    check_dbx()
    update_last_doublette(number)
    update_mem_counter()
    update_f23_f14(number)
    update_high_low(number)
    update_distance(number)
    update_fin2dern(number)
    update_vfn(number)
    update_rectangulo(number)
    update_jeu_voisin(number)
    update_ab_series(number)
    update_rn_sequence(number)
    update_jc(number)
    update_detected_numbers(number)
    update_nineveh_display()
    update_pi_sequence(number)
    update_mp_sequence(number)
    check_ab_alert()  # V√©rifie l'√©tat des s√©ries A

    # --- 5. Mise √† jour des compteurs Mise et Tr ---
    previous_doublette = last_doublette.get()
    update_last_doublette(number)

    if last_doublette.get() != "XX":
        update_mise_tr_counters()

        # V√©rification s√©curis√©e pour √©viter ValueError
        if previous_doublette != "XX" and previous_doublette != "--":
            try:
                previous_doublette_int = int(previous_doublette)
                if number == previous_doublette_int:
                    reset_mise_tr_counters()
            except ValueError:
                pass  # Ignorer silencieusement si la conversion √©choue

    # --- 8. Supprimer le num√©ro des s√©ries NR1-NR4 ---
    for serie_name, serie_numbers in NR_SERIES.items():
        if number in serie_numbers:
            serie_numbers.remove(number)
            if serie_name == "NR1" and number in nr1_numbers_list:
                nr1_numbers_list.remove(number)
                nr1_counter.set(str(len(nr1_numbers_list)))
            elif serie_name == "NR2" and number in nr2_numbers_list:
                nr2_numbers_list.remove(number)
                nr2_counter.set(str(len(nr2_numbers_list)))
            elif serie_name == "NR3" and number in nr3_numbers_list:
                nr3_numbers_list.remove(number)
                nr3_counter.set(str(len(nr3_numbers_list)))
            elif serie_name == "NR4" and number in nr4_numbers_list:
                nr4_numbers_list.remove(number)
                nr4_counter.set(str(len(nr4_numbers_list)))

    # --- 9. METTRE √Ä JOUR TOUS LES SYST√àMES ---
    update_all_systems()

    # AJOUTE CETTE LIGNE √Ä LA FIN :
    if 'update_mat_system' in globals():
        update_mat_system(number)



# Fonction pour copier et jouer les num√©ros d'une zone de stockage
def copy_stk_numbers(index):
    numbers = list(stk_values[index])  # R√©cup√©rer les num√©ros de la zone de stockage
    if not numbers:
        messagebox.showwarning("Avertissement", f"STK{index} est vide.")
        return

    # R√©cup√©rer la vitesse de clic
    try:
        click_speed = int(speed_entry.get())
    except ValueError:
        messagebox.showerror("Erreur", "La vitesse de clic doit √™tre un nombre entier.")
        return

    # R√©cup√©rer le nombre de r√©p√©titions
    try:
        repetitions = int(repet_mollette.get())
    except ValueError:
        messagebox.showerror("Erreur", "La valeur de r√©p√©tition doit √™tre un nombre entier.")
        return

    # Cliquer sur chaque num√©ro de la zone de stockage, r√©p√©t√© selon la valeur de REPET
    for num in numbers:
        if num in coordinates:
            x, y = coordinates[num]
            if x > 0 and y > 0:  # V√©rifier que les coordonn√©es sont valides
                for _ in range(repetitions):  # R√©p√©ter le clic selon la valeur de REPET
                    pyautogui.click(x, y)  # Cliquer sur les coordonn√©es (X, Y)
                    time.sleep(click_speed / 1000)  # D√©lai entre les clics
            else:
                messagebox.showwarning("Avertissement", f"Coordonn√©es manquantes pour le num√©ro {num}.")
        else:
            messagebox.showwarning("Avertissement", f"Coordonn√©es manquantes pour le num√©ro {num}.")


# Fonction pour jouer les num√©ros d'une cat√©gorie sp√©cifique
def jouer_category(numbers_list, category_name):
    if not numbers_list:
        messagebox.showwarning("Avertissement", f"Aucun num√©ro dans la cat√©gorie {category_name}.")
        return

    # R√©cup√©rer la vitesse de clic
    try:
        click_speed = int(speed_entry.get())
    except ValueError:
        messagebox.showerror("Erreur", "La vitesse de clic doit √™tre un nombre entier.")
        return

    # R√©cup√©rer le nombre de r√©p√©titions
    try:
        repetitions = int(repet_mollette.get())
    except ValueError:
        messagebox.showerror("Erreur", "La valeur de r√©p√©tition doit √™tre un nombre entier.")
        return

    # Cliquer sur chaque num√©ro de la cat√©gorie, r√©p√©t√© selon la valeur de REPET
    for num in numbers_list:
        if num in coordinates:
            x, y = coordinates[num]
            if x > 0 and y > 0:  # V√©rifier que les coordonn√©es sont valides
                for _ in range(repetitions):  # R√©p√©ter le clic selon la valeur de REPET
                    pyautogui.click(x, y)  # Cliquer sur les coordonn√©es (X, Y)
                    time.sleep(click_speed / 1000)  # D√©lai entre les clics
            else:
                messagebox.showwarning("Avertissement", f"Coordonn√©es manquantes pour le num√©ro {num}.")
        else:
            messagebox.showwarning("Avertissement", f"Coordonn√©es manquantes pour le num√©ro {num}.")


# Fonction pour mettre √† jour les compteurs NS, Ec, et Ecmx
def update_counters(number, remove=False):
    update_montcg()  # ‚≠ê AJOUTE CETTE LIGNE AU D√âBUT ‚≠ê
    # ... [le reste du code existant de update_counters] ...
    for serie_name, serie_numbers in SERIES.items():
        if number in serie_numbers:
            if remove:
                ns_values[serie_name] -= 1
            else:
                ns_values[serie_name] += 1
            # R√©initialisation
            ec_values[serie_name] = 0
            mtgy_values[serie_name] = 1
            mtgy_labels[serie_name].config(text="1")
            ec_labels[serie_name].config(fg="black")
            ecmx_labels[serie_name].config(fg="black")
        else:
            # √âcart augmente
            ec_values[serie_name] += 1
            ec = ec_values[serie_name]  # Ex: Ec passe √† 3

            # Appliquer la progression MTGY
            if serie_name in MTGY_TABLE_BY_SERIE:
                table = MTGY_TABLE_BY_SERIE[serie_name]
                if ec < len(table):  # Si Ec=3 et len(table) > 3
                    mtgy_values[serie_name] = table[ec]  # ‚úÖ Prend la valeur √† l'index Ec
                else:
                    mtgy_values[serie_name] = table[-1]  # Plafond
            else:
                mtgy_values[serie_name] = 2 ** ec  # Pour coh√©rence

            mtgy_labels[serie_name].config(text=str(mtgy_values[serie_name]))

            # Mise √† jour Ecmx
            if ec_values[serie_name] > ecmx_values[serie_name]:
                ecmx_values[serie_name] = ec_values[serie_name]

            # Couleur alerte
            if ec_values[serie_name] >= alert_values.get(serie_name, 999):
                ec_labels[serie_name].config(fg="red")
                ecmx_labels[serie_name].config(fg="red")
            else:
                ec_labels[serie_name].config(fg="black")
                ecmx_labels[serie_name].config(fg="black")

        # Mise √† jour des labels
        ns_labels[serie_name].config(text=str(ns_values[serie_name]))
        ec_labels[serie_name].config(text=str(ec_values[serie_name]))
        ecmx_labels[serie_name].config(text=str(ecmx_values[serie_name]))


# Fonction pour mettre √† jour les labels NS, Ec, et Ecmx
def update_labels():
    for serie_name in SERIES.keys():
        ns_labels[serie_name].config(text=str(ns_values[serie_name]))
        ec_labels[serie_name].config(text=str(ec_values[serie_name]))
        ecmx_labels[serie_name].config(text=str(ecmx_values[serie_name]))

        # Mettre √† jour la couleur des compteurs Ec et Ecmx
        if abs(ec_values[serie_name] - ecmx_values[serie_name]) <= 2:
            ec_labels[serie_name].config(fg="red")
            ecmx_labels[serie_name].config(fg="red")
        else:
            ec_labels[serie_name].config(fg="black")
            ecmx_labels[serie_name].config(fg="black")

        # Mettre √† jour la couleur de la case d'alerte (ALT)
        if ec_values[serie_name] >= alert_values[serie_name]:
            alt_entries[serie_name].config(bg="green", fg="white")
        else:
            alt_entries[serie_name].config(bg="white", fg="black")


# Fonction pour mettre √† jour une colonne sp√©cifique
def update_column(number, category_list, category_counter, inner_frame, color):
    if number in category_list:
        # Si le num√©ro est d√©j√† pr√©sent, r√©initialiser la liste et l'affichage
        category_list.clear()  # Vider la liste
        for widget in inner_frame.winfo_children():  # Supprimer tous les widgets du cadre int√©rieur
            widget.destroy()
        category_counter.set("0")  # R√©initialiser le compteur
    else:
        # Ajouter le num√©ro √† la liste
        category_list.append(number)
        # Mettre √† jour l'affichage dans le cadre
        label = tk.Label(inner_frame, text=str(number), bg="black", fg=color, font=default_font)
        label.pack(side="left", padx=5)
        # Mettre √† jour le compteur
        category_counter.set(str(len(category_list)))


# Fonction pour mettre √† jour toutes les colonnes
def update_all_columns(number):
    if number in RED_NUMBERS:
        update_column(number, red_numbers_list, red_counter, red_inner_frame, "red")  # RED
    if number in BLACK_NUMBERS:
        update_column(number, black_numbers_list, black_counter, black_inner_frame, "white")  # NOIRS
    if number in PAIR_NUMBERS:
        update_column(number, pair_numbers_list, pair_counter, pair_inner_frame, "yellow")  # PAIRS
    if number in IMPAIR_NUMBERS:
        update_column(number, impair_numbers_list, impair_counter, impair_inner_frame, "yellow")  # IMPAIRS
    if number in MANQUE_NUMBERS:
        update_column(number, manque_numbers_list, manque_counter, manque_inner_frame, "yellow")  # MANQUES
    if number in PASSE_NUMBERS:
        update_column(number, passe_numbers_list, passe_counter, passe_inner_frame, "yellow")  # PASSES
    if number in SERIES["VOISIN"]:
        update_column(number, vo_numbers_list, vo_counter, vo_inner_frame, "yellow")  # VO
    if number in SERIES["TIERS"]:
        update_column(number, tie_numbers_list, tie_counter, tie_inner_frame, "yellow")  # TIE
    if number in SERIES["ORPH"]:
        update_column(number, oph_numbers_list, oph_counter, oph_inner_frame, "yellow")  # OPH
    if number in NR_SERIES["NR1"]:
        update_column(number, nr1_numbers_list, nr1_counter, nr1_inner_frame, "yellow")  # NR1
    if number in NR_SERIES["NR2"]:
        update_column(number, nr2_numbers_list, nr2_counter, nr2_inner_frame, "yellow")  # NR2
    if number in NR_SERIES["NR3"]:
        update_column(number, nr3_numbers_list, nr3_counter, nr3_inner_frame, "yellow")  # NR3
    if number in NR_SERIES["NR4"]:
        update_column(number, nr4_numbers_list, nr4_counter, nr4_inner_frame, "yellow")  # NR4


# ... (le reste de ton code reste inchang√© jusqu'√† la d√©finition des variables globales)

# D√©clarer limited_history comme une variable globale
limited_history = None


# Fonction pour mettre √† jour l'historique


def update_history():
    global limited_history
    history_text.config(state=tk.NORMAL)
    history_text.delete(1.0, tk.END)

    if limited_history is not None:
        current_history = limited_history
    else:
        current_history = history

    for num in reversed(current_history):
        if mode_var.get() == "RB":
            if num in RED_NUMBERS:
                history_text.insert(tk.END, f"{num:2d} \n", "left_red")
            elif num in BLACK_NUMBERS:
                history_text.insert(tk.END, f"{num:2d} \n", "right_black")
            elif num == 0:
                history_text.insert(tk.END, f"{num:2d} \n", "center_green")
            else:
                history_text.insert(tk.END, f"{num:2d} \n", "center")

        elif mode_var.get() == "EO":
            if num % 2 == 0 and num != 0:
                history_text.insert(tk.END, f"{num:2d} \n", "left_blue")
            elif num % 2 == 1:
                history_text.insert(tk.END, f"{num:2d} \n", "right_brown")
            elif num == 0:
                history_text.insert(tk.END, f"{num:2d} \n", "center_green")
            else:
                history_text.insert(tk.END, f"{num:2d} \n", "center")

        elif mode_var.get() == "LH":
            if num == 0:
                history_text.insert(tk.END, f"{num:2d} \n", "center_green")
            elif num <= 18:
                history_text.insert(tk.END, f"{num:2d} \n", "left_blue")
            else:
                history_text.insert(tk.END, f"{num:2d} \n", "right_brown")

        elif mode_var.get() == "S1S2":
            six1 = SERIES["SIX   1"]
            six2 = SERIES["SIX   2"]
            if num in six1:
                history_text.insert(tk.END, f"{num:2d} \n", "left_blue")
            elif num in six2:
                history_text.insert(tk.END, f"{num:2d} \n", "right_brown")
            elif num == 0:
                history_text.insert(tk.END, f"{num:2d} \n", "center_green")
            else:
                history_text.insert(tk.END, f"{num:2d} \n", "center")

        elif mode_var.get() == "T1T2":
            tra1 = SERIES["TRA  1"]
            tra2 = SERIES["TRA  2"]
            if num in tra1:
                history_text.insert(tk.END, f"{num:2d} \n", "left_magenta")
            elif num in tra2:
                history_text.insert(tk.END, f"{num:2d} \n", "right_cyan")
            elif num == 0:
                history_text.insert(tk.END, f"{num:2d} \n", "center_green")
            else:
                history_text.insert(tk.END, f"{num:2d} \n", "center")

        elif mode_var.get() == "DZ":
            d1 = SERIES["DZ   1"]
            d2 = SERIES["DZ   2"]
            d3 = SERIES["DZ   3"]
            if num in d1:
                history_text.insert(tk.END, f"{num:2d} \n", "left_black")
            elif num in d2:
                history_text.insert(tk.END, f"{num:2d} \n", "center_brown")
            elif num in d3:
                history_text.insert(tk.END, f"{num:2d} \n", "right_purple")
            elif num == 0:
                history_text.insert(tk.END, f"{num:2d} \n", "center_green")
            else:
                history_text.insert(tk.END, f"{num:2d} \n", "center")

        elif mode_var.get() == "CL":
            c1 = SERIES["COL 1"]
            c2 = SERIES["COL 2"]
            c3 = SERIES["COL 3"]
            if num in c1:
                history_text.insert(tk.END, f"{num:2d} \n", "left_black")
            elif num in c2:
                history_text.insert(tk.END, f"{num:2d} \n", "center_brown")
            elif num in c3:
                history_text.insert(tk.END, f"{num:2d} \n", "right_purple")
            elif num == 0:
                history_text.insert(tk.END, f"{num:2d} \n", "center_green")
            else:
                history_text.insert(tk.END, f"{num:2d} \n", "center")

    spins_count.set(f"Nombre de spins : {len(current_history)}")
    history_text.config(state=tk.DISABLED)
    history_text.see("1.0")  # Les plus r√©cents en haut


    # Compteur de spins
    spins_count.set(f"Nombre de spins : {len(current_history)}")
    history_text.config(state=tk.DISABLED)
    history_text.see("1.0")  # Pour montrer les plus r√©cents en haut



# ... (le reste de ton code reste inchang√©)

# Fonction pour limiter le nombre de spins pris en compte
def reduc_spins():
    try:
        reduc_value = int(reduc_entry.get())
        if reduc_value <= len(history):
            global limited_history
            limited_history = history[-reduc_value:]  # Limiter l'historique aux N derniers spins
            update_all_interface_elements()  # Mettre √† jour tous les √©l√©ments de l'interface
        else:
            messagebox.showwarning("Avertissement", "Le nombre saisi est sup√©rieur au nombre total de spins.")
    except ValueError:
        messagebox.showerror("Erreur", "Veuillez entrer un nombre valide.")


# Fonction pour jouer une s√©rie sur la table de jeu
def jouer_serie(serie_name):
    # R√©cup√©rer les num√©ros de la s√©rie
    serie_numbers = SERIES[serie_name]

    # V√©rifier si la s√©rie contient des num√©ros
    if not serie_numbers:
        messagebox.showwarning("Avertissement", f"La s√©rie {serie_name} ne contient aucun num√©ro.")
        return

    # R√©cup√©rer la vitesse de clic
    try:
        click_speed = int(speed_entry.get())
    except ValueError:
        messagebox.showerror("Erreur", "La vitesse de clic doit √™tre un nombre entier.")
        return

    # R√©cup√©rer le nombre de r√©p√©titions
    try:
        repetitions = int(repet_mollette.get())
    except ValueError:
        messagebox.showerror("Erreur", "La valeur de r√©p√©tition doit √™tre un nombre entier.")
        return

    # Cliquer sur chaque num√©ro de la s√©rie, r√©p√©t√© selon la valeur de REPET
    for num in serie_numbers:
        if num in coordinates:
            x, y = coordinates[num]
            if x > 0 and y > 0:  # V√©rifier que les coordonn√©es sont valides
                for _ in range(repetitions):  # R√©p√©ter le clic selon la valeur de REPET
                    pyautogui.click(x, y)  # Cliquer sur les coordonn√©es (X, Y)
                    time.sleep(click_speed / 1000)  # D√©lai entre les clics
            else:
                messagebox.showwarning("Avertissement", f"Coordonn√©es manquantes pour le num√©ro {num}.")
        else:
            messagebox.showwarning("Avertissement", f"Coordonn√©es manquantes pour le num√©ro {num}.")


# Fonction pour le bouton RETOUR
def retour():
    if history:  # V√©rifier si l'historique n'est pas vide
        # Supprimer le dernier num√©ro de l'historique
        dernier_numero = history.pop()
        print(f"Bouton RETOUR cliqu√© : le num√©ro {dernier_numero} a √©t√© supprim√©.")

        # Mettre √† jour l'affichage de l'historique
        update_history()

        # Mettre √† jour les compteurs
        update_counters(dernier_numero, remove=True)  # On passe `remove=True` pour indiquer qu'on retire un num√©ro
    else:
        print("L'historique est vide, rien √† supprim√©.")


# +++++++++++++++++++++++++++++++
# Fonction pour le bouton RESET
# ================================

def reset():
    global history, ns_values, ec_values, ecmx_values, series_memory, series_names, red_numbers_list,pld_numbers, f23_ec, f14_ec, high_ec, low_ec, f23_ecmx, f14_ecmx, high_ecmx, low_ecmx
    global sSIXAIN_list, sCARRE_list, sV1_list, sV2_list, sTVR_list, sCVX_list, sV3_list, sV4_list, s4PCA_list  # Ajout
    global adjacent_number_1, adjacent_number_2, str8v_display_numbers, str8v_active_series, str8v_tour_count
    global distance_history, tx_numbers, distance_counters
    global detected_numbers_list, dlo_numbers_list, f23_numbers_list, f14_numbers_list, high_numbers_list, low_numbers_list
    global rectangulo_series, persistent_green_numbers
    global captured_numbers, win_r_colored, diago_colored, diago_captured, last_highlighted_number, mises_cumulees
    global appl_numbers, fut_numbers, fccg_numbers
    global compteurs, ecart, counter_labels, ecart_labels
    global ecart_max_prx  # ‚≠ê AJOUTE CETTE LIGNE ‚≠ê
    global dlo_ecart_max, dlo1_ecart_max, dlo2_ecart_max  # ‚≠ê AJOUT ‚≠ê


    def reset_systems():
        global n0_150_numbers, n13_500_numbers, t29_1000_numbers

        # R√©initialiser les variables
        n0_150_numbers = []
        n13_500_numbers = []
        t29_1000_numbers = []
        # ‚≠ê R√âINITIALISATION PLD ‚≠ê
        pld_numbers = {"P1": None, "P2": None, "non_sortis": []}

        # Effacer l'affichage des nouveaux cadres (NOUVELLE M√âTHODE)
        for widget in n0_150_display_frame.winfo_children():
            widget.destroy()
        for widget in n13_500_display_frame.winfo_children():
            widget.destroy()
        for widget in t29_1000_display_frame.winfo_children():
            widget.destroy()

        # Afficher "Aucun" dans chaque cadre
        tk.Label(n0_150_display_frame, text="Aucun", font=("Courier", 9), bg="white", fg="black").pack()
        tk.Label(n13_500_display_frame, text="Aucun", font=("Courier", 9), bg="white", fg="black").pack()
        tk.Label(t29_1000_display_frame, text="Aucun", font=("Courier", 9), bg="white", fg="black").pack()

    reset_systems()
    reset_ab_series()
    reset_rn_sequence()
    # ‚úÖ AJOUT : R√©initialiser les DLO et leurs compteurs
    reset_dlo()  # ‚Üê C'est ici qu'on ajoute cette ligne !
    # R√©initialiser l'historique
    history.clear()
    update_history()

    # R√©initialiser les compteurs
    for serie_name in SERIES.keys():
        ns_values[serie_name] = 0
        ec_values[serie_name] = 0
        ecmx_values[serie_name] = 0
        mtgy_values[serie_name] = 1
        mtgy_labels[serie_name].config(text="1")

    # --- R√âINITIALISATION DU SYST√àME 3DEN ---
    # --- R√âINITIALISATION DU SYST√àME 3DEN ---
    global det_ecart_3den, det_ecart_max_3den, det_alerte_seuil_3den
    det_ecart_3den = 0
    det_ecart_max_3den = 0
    det_alerte_seuil_3den = 1
    ecart_label.config(text="0", bg="white", fg="black")
    ecart_max_label.config(text="0")
    alerte_entry.delete(0, tk.END)
    alerte_entry.insert(0, "1")

    # R√©initialiser les s√©ries en m√©moire
    series_memory = [[] for _ in range(28)]
    series_names = list(SERIES.keys())

    # R√©initialiser la colonne "Red"
    red_numbers_list.clear()
    for widget in red_inner_frame.winfo_children():
        widget.destroy()
    red_counter.set("0")

    # R√©initialiser les autres colonnes sp√©cifiques
    black_numbers_list.clear()
    for widget in black_inner_frame.winfo_children():
        widget.destroy()
    black_counter.set("0")

    pair_numbers_list.clear()
    for widget in pair_inner_frame.winfo_children():
        widget.destroy()
    pair_counter.set("0")

    impair_numbers_list.clear()
    for widget in impair_inner_frame.winfo_children():
        widget.destroy()
    impair_counter.set("0")

    manque_numbers_list.clear()
    for widget in manque_inner_frame.winfo_children():
        widget.destroy()
    manque_counter.set("0")

    passe_numbers_list.clear()
    for widget in passe_inner_frame.winfo_children():
        widget.destroy()
    passe_counter.set("0")

    vo_numbers_list.clear()
    for widget in vo_inner_frame.winfo_children():
        widget.destroy()
    vo_counter.set("0")

    tie_numbers_list.clear()
    for widget in tie_inner_frame.winfo_children():
        widget.destroy()
    tie_counter.set("0")

    oph_numbers_list.clear()
    for widget in oph_inner_frame.winfo_children():
        widget.destroy()
    oph_counter.set("0")

    # R√©initialiser les sous-tableaux
    sSIXAIN_list.clear()
    sCARRE_list.clear()
    sV1_list.clear()
    sV2_list.clear()
    sTVR_list.clear()
    sCVX_list.clear()
    sV3_list.clear()
    sV4_list.clear()

    # R√©initialiser les √©carts pour chaque tableau
    for tableau_name in ecarts.keys():
        ecarts[tableau_name] = [0] * len(globals()[tableau_name])

    # Effacer le contenu des canevas des sous-tableaux
    for frame in main_sous_tableaux_frame.winfo_children():
        canvas = frame.winfo_children()[1]
        canvas.delete("all")

    # Mettre √† jour les labels
    update_labels()

    # R√©initialiser le compteur de spins
    spins_count.set("Nombre de spins : 0")

    # R√©initialiser le d√©versoir
    for i in range(11):
        stk_values[i] = set(range(37)) if i == 0 else set()
        stk_counters[i].set(str(len(stk_values[i])))

    # V√©rifier les alertes apr√®s la r√©initialisation
    check_alerts()

    # R√©initialiser le compteur DBX
    dbx_counter.set("1")

    # ‚≠ê AJOUTE CES 3 LIGNES POUR R√âINITIALISER LES COMPTEURS PRX ‚≠ê
    dbx_counter.set("0")  # ‚¨ÖÔ∏è R√âINITIALISE L'√âCART NORMAL √Ä 0
    ecart_max_prx = 0  # ‚¨ÖÔ∏è R√âINITIALISE L'√âCART MAX
    ecpmx_counter.set("0")  # ‚¨ÖÔ∏è R√âINITIALISE L'AFFICHAGE DE L'√âCART MAX

    ecart_max_prx = 0
    ecpmx_counter.set("0")

    # ‚≠ê AJOUT POUR R√âINITIALISER LES 3 √âCARTS MAX DLO ‚≠ê
    dlo_ecart_max = 0
    dlo1_ecart_max = 0
    dlo2_ecart_max = 0
    update_dlo_ecarts()  # ‚≠ê MISE √Ä JOUR DES 6 COMPTEURS ‚≠ê
    # ‚≠ê R√âINITIALISATION DES 8 COMPTEURS (F23/F14 & HIGH/LOW) ‚≠ê
    f23_ec = 0
    f14_ec = 0
    high_ec = 0
    low_ec = 0
    f23_ecmx = 0
    f14_ecmx = 0
    high_ecmx = 0
    low_ecmx = 0

    # R√©initialiser la derni√®re doublette
    last_doublette.set("XX")

    # R√©initialiser les num√©ros adjacents
    adjacent_number_1.set("XX")
    adjacent_number_2.set("XX")

    # R√©initialiser les variables sp√©cifiques √† STR 8V
    str8v_display_numbers = []
    str8v_active_series = []
    str8v_tour_count = 0
    for name in str8v_counters.keys():
        str8v_counters[name] = 0

    # R√©initialiser les cadres des boutons sp√©cifiques
    for widget in str8v_active_frame.winfo_children():
        widget.destroy()

    # R√©initialiser les listes et les compteurs pour "Det", "D2D3", "C1C2", "C1C3", "C2C3"
    nr1_numbers_list.clear()
    nr1_counter.set("0")
    for widget in nr1_inner_frame.winfo_children():
        widget.destroy()

    nr2_numbers_list.clear()
    nr2_counter.set("0")
    for widget in nr2_inner_frame.winfo_children():
        widget.destroy()

    nr3_numbers_list.clear()
    nr3_counter.set("0")
    for widget in nr3_inner_frame.winfo_children():
        widget.destroy()

    nr4_numbers_list.clear()
    nr4_counter.set("0")
    for widget in nr4_inner_frame.winfo_children():
        widget.destroy()

    # --- R√âINITIALISATION DES √âL√âMENTS DE DISTANCE ---
    distance_history = []
    for label in distance_labels:
        label.config(text="")

    for i in range(1, 14):
        tx = f"T{i}"
        distance_counters[tx] = {"NS": 0, "Ec": 0, "Exmx": 0}
        tx_vars[tx]["NS"].set("0")
        tx_vars[tx]["Ec"].set("0")
        tx_vars[tx]["Exmx"].set("0")

    tx_numbers = []
    tx_display_var.set("TX")

    # --- R√âINITIALISATION DU CADRE WCAP ---
    captured_numbers.clear()
    win_r_colored = [[set() for _ in range(6)] for _ in range(15)]
    diago_colored = [set() for _ in range(30)]
    diago_captured = [set() for _ in range(30)]
    last_highlighted_number = None
    if 'wcap_display' in globals():
        wcap_display.config(text="")

    global win_r_window
    if win_r_window and win_r_window.winfo_exists():
        win_r_window.destroy()
    win_r_window = None

    # --- R√âINITIALISATION DES 3 CADRES (APPL, FUT KAC, FCCG) ---
    appl_numbers = []
    fut_numbers = []
    fccg_numbers = []
    if 'appl_label' in globals():
        appl_label.config(text="")
    if 'fut_label' in globals():
        fut_label.config(text="")
    if 'fccg_label' in globals():
        fccg_label.config(text="")
        # ‚≠ê R√âINITIALISATION AFFICHAGE PLD ‚≠ê
    if 'pld_display' in globals():
        pld_display.config(text="Historique\nvide")

    # --- R√âINITIALISATION DES PETITS CARR√âS COMPTEURS ---
    for num in range(37):
        compteurs[num] = 0
        ecart[num] = 0

    # Supprimer les anciens labels des compteurs et des √©carts
    for num in counter_labels:
        if counter_labels[num].winfo_exists():
            counter_labels[num].destroy()

    for num in ecart_labels:
        if ecart_labels[num].winfo_exists():
            ecart_labels[num].destroy()

    # Vider les dictionnaires de labels
    counter_labels = {}
    ecart_labels = {}

    # Recr√©er les labels des compteurs et des √©carts
    keyboard_frame.update_idletasks()
    for num, btn in buttons.items():
        if btn.winfo_exists():
            create_counter_label(keyboard_frame, num, btn)
            create_ecart_label(keyboard_frame, num, btn)

    # 3. Cadre "D√©t" (num√©ros d√©tect√©s)
    detected_numbers_list = []
    if 'detected_numbers_label' in globals():
        detected_numbers_label.config(text="Aucun num√©ro d√©tect√©")

    # 4. Cadre DLO
    dlo_numbers_list = []
    if 'dlo_display_var' in globals():
        dlo_display_var.set("")

    # 5. Cadres f23 et f14
    f23_numbers_list = []
    f14_numbers_list = []
    if 'f23_display_var' in globals():
        f23_display_var.set("F23")
    if 'f14_display_var' in globals():
        f14_display_var.set("F14")

    # 5. Cadres high et low
    high_numbers_list = []
    low_numbers_list = []
    if 'high_display_var' in globals():
        high_display_var.set("high")
    if 'low_display_var' in globals():
        low_display_var.set("low")

    # 6. Tableau Rectangulo
    rectangulo_series = []
    persistent_green_numbers.clear()
    for i in range(13):
        rectangulo_buttons[i].config(state="disabled", command=None)
        for j in range(6):
            rectangulo_labels[i][j].config(text="", bg="white", fg="black")
        # ‚≠ê MISE √Ä JOUR AFFICHAGE DES 8 COMPTEURS ‚≠ê
    if 'f23_ec_var' in globals():
        f23_ec_var.set("Ec: 0")
        f23_ecmx_var.set("Ecmx: 0")
    if 'f14_ec_var' in globals():
        f14_ec_var.set("Ec: 0")
        f14_ecmx_var.set("Ecmx: 0")
    if 'high_ec_var' in globals():
        high_ec_var.set("Ec: 0")
        high_ecmx_var.set("Ecmx: 0")
    if 'low_ec_var' in globals():
        low_ec_var.set("Ec: 0")
        low_ecmx_var.set("Ecmx: 0")

    # --- R√âINITIALISATION DE LA MONTANTE √âVOLUTIVE ---
    global mise_unitaire, mise_value_var
    mises_cumulees = 0
    mise_unitaire = 1
    mise_value_var.set("")

    # Afficher un message de confirmation
    messagebox.showinfo("RESET", "L'application a √©t√© r√©initialis√©e avec succ√®s.")


# Fonction pour le bouton QUITTER
def quitter():
    global keyboard_listener
    print("Bouton QUITTER cliqu√©")
    if keyboard_listener and keyboard_listener.is_alive():
        keyboard_listener.stop()
        keyboard_listener.join()
    root.quit()  # Arr√™ter la boucle principale de Tkinter
    root.destroy()  # Fermer la fen√™tre principale


# Fonction pour le bouton IMPORT

def importer():
    try:
        clipboard_data = root.clipboard_get()
        cleaned_data = re.sub(r"[{}\-,;]", " ", clipboard_data)
        cleaned_data = re.sub(r"\s+", " ", cleaned_data)
        numbers = cleaned_data.strip().split()

        for num in numbers:
            if num.isdigit():
                num = int(num)
                if num in RED_NUMBERS | BLACK_NUMBERS | ZERO_NUMBER:
                    history.append(num)
                    update_counters(num)  # Mettre √† jour les compteurs pour chaque num√©ro import√©
                    update_all_columns(num)  # Mettre √† jour les colonnes sp√©cifiques
                    move_number(num)  # D√©placer le num√©ro dans le d√©versoir
                    update_ecarts(num)  # Mettre √† jour les √©carts des tableaux de base
                    check_dbx()  # V√©rifier la fonctionnalit√© DBX et mettre √† jour le compteur PR
                    update_last_doublette(num)  # Mettre √† jour la derni√®re doublette et ses num√©ros amis
                    # --- MISE √Ä JOUR DES SYST√àMES A/B ---
                    update_ab_series(num)  # AJOUT CRITIQUE: Mettre √† jour les s√©ries A/B
                    # --- MISE √Ä JOUR DU SYST√àME JC ---
                    update_jc(num)  # AJOUT CRITIQUE: Mettre √† jour les tables JC
                    # --- AJOUT DES NOUVELLES MISE √Ä JOUR ---

                    # 1. Mettre √† jour les petits carr√©s compteurs et √©carts
                    if num in compteurs:
                        compteurs[num] += 1
                    if num in ecart:
                        ecart[num] = 0  # R√©initialiser l'√©cart quand le num√©ro sort
                    # Mettre √† jour les autres √©carts
                    for n in range(37):
                        if n != num and n in ecart:
                            ecart[n] += 1

                    # Mettre √† jour l'affichage des compteurs et √©carts
                    if num in counter_labels and counter_labels[num].winfo_exists():
                        counter_labels[num].config(text=str(compteurs[num]))
                    if num in ecart_labels and ecart_labels[num].winfo_exists():
                        ecart_labels[num].config(text=str(ecart[num]))

                    # 2. Mettre √† jour le cadre historique des distances
                    update_distance(num)

                    # 3. Les colonnes NS, Ec, Ecmx du Tableau des distances sont d√©j√† mises √† jour par update_distance()

                    # 4. Mettre √† jour le CADRE APPL
                    if 'update_appl_display' in globals():
                        update_appl_display()

                    # 5. Mettre √† jour le CADRE FUT KAC
                    if 'update_fut_display' in globals():
                        update_fut_display()

                    # 6. Mettre √† jour le CADRE FCCG
                    if 'update_fccg_display' in globals():
                        update_fccg_display()

                    # Mettre √† jour le syst√®me Win R si la fonction existe
                    if 'update_win_r_system' in globals():
                        update_win_r_system(num)

                    # Mettre √† jour le syst√®me RECTANGULO - AJOUT IMPORTANT
                    update_rectangulo(num)

                    # AJOUT: Mettre √† jour les syst√®mes 150, 500 et 1000
                    update_all_systems()  # Cette fonction met √† jour tous les syst√®mes

        # Mettre √† jour l'historique principal
        update_history()

        # Mettre √† jour les sous-tableaux
        update_sous_tableaux()

        # Mettre √† jour les √©carts de tous les num√©ros (pour l'affichage initial)
        for n in range(37):
            if n in ecart_labels and ecart_labels[n].winfo_exists():
                ecart_labels[n].config(text=str(ecart[n]))

        # ‚úÖ RAFRAICHISSEMENT FINAL UNIQUE
        root.update_idletasks()

        messagebox.showinfo("Import r√©ussi", "Les num√©ros ont √©t√© import√©s avec succ√®s.")

    except tk.TclError:
        messagebox.showerror("Erreur", "Aucune donn√©e valide dans le presse-papiers.")
    except Exception as e:
        messagebox.showerror("Erreur", f"Erreur lors de l'importation : {e}")


# Fonction pour le bouton J.H
def jouer_historique():
    if not history:
        messagebox.showwarning("Avertissement", "L'historique est vide.")
        return

    # R√©cup√©rer la vitesse de clic
    try:
        click_speed = int(speed_entry.get())
    except ValueError:
        messagebox.showerror("Erreur", "La vitesse de clic doit √™tre un nombre entier.")
        return

    # R√©cup√©rer le nombre de r√©p√©titions
    try:
        repetitions = int(repet_mollette.get())
    except ValueError:
        messagebox.showerror("Erreur", "La valeur de r√©p√©tition doit √™tre un nombre entier.")
        return

    # Cliquer sur chaque num√©ro de l'historique, r√©p√©t√© selon la valeur de REPET
    for num in history:
        if num in coordinates:
            x, y = coordinates[num]
            if x > 0 and y > 0:  # V√©rifier que les coordonn√©es sont valides
                for _ in range(repetitions):  # R√©p√©ter le clic selon la valeur de REPET
                    pyautogui.click(x, y)  # Cliquer sur les coordonn√©es (X, Y)
                    time.sleep(click_speed / 1000)  # D√©lai entre les clics
            else:
                messagebox.showwarning("Avertissement", f"Coordonn√©es manquantes pour le num√©ro {num}.")
        else:
            messagebox.showwarning("Avertissement", f"Coordonn√©es manquantes pour le num√©ro {num}.")


# Fonction pour le bouton REPET
def repeter():
    repetitions = int(repet_mollette.get())
    messagebox.showinfo("R√©p√©ter", f"Jouer {repetitions} fois les num√©ros: {history}")


# ======================================= ====================================
# Fonction pour le bouton Table Setup      NOUVELLE MEMORISATION
# ======================================= ====================================
def table_setup():
    global keyboard_listener
    setup_window = tk.Toplevel(root)
    setup_window.title("Table Setup")
    setup_window.geometry("800x700")

    # Frame principal avec scrollbar
    main_frame = tk.Frame(setup_window)
    main_frame.pack(fill="both", expand=True, padx=10, pady=10)

    # Canvas et scrollbar
    canvas = tk.Canvas(main_frame)
    scrollbar = tk.Scrollbar(main_frame, orient="vertical", command=canvas.yview)
    scrollable_frame = tk.Frame(canvas)

    scrollable_frame.bind("<Configure>", lambda e: canvas.configure(scrollregion=canvas.bbox("all")))
    canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
    canvas.configure(yscrollcommand=scrollbar.set)

    canvas.pack(side="left", fill="both", expand=True)
    scrollbar.pack(side="right", fill="y")

    # Titre
    tk.Label(scrollable_frame, text="ENREGISTREMENT DES COORDONNEES X Y", font=("Arial", 12, "bold")).pack(pady=10)

    # Frame pour les num√©ros 0-36
    numbers_frame = tk.Frame(scrollable_frame)
    numbers_frame.pack(pady=5)

    # Entr√©es pour les num√©ros 0-36
    entries = {}

    # Cr√©er 3 colonnes pour les num√©ros
    columns = []
    for i in range(3):
        col_frame = tk.Frame(numbers_frame)
        col_frame.pack(side="left", padx=15)
        columns.append(col_frame)

    # R√©partir les num√©ros dans les 3 colonnes
    for num in range(37):
        col_index = num // 13  # 0-12: col0, 13-25: col1, 26-36: col2
        row_index = num % 13

        frame = columns[col_index]

        tk.Label(frame, text=f"{num}:", font=default_font, width=3).grid(row=row_index, column=0, sticky="e", padx=2,
                                                                         pady=1)

        entry_x = tk.Entry(frame, width=6, font=default_font)
        entry_x.grid(row=row_index, column=1, padx=2, pady=1)

        entry_y = tk.Entry(frame, width=6, font=default_font)
        entry_y.grid(row=row_index, column=2, padx=2, pady=1)

        entries[num] = (entry_x, entry_y)

    # Frame pour les chances simples
    chances_frame = tk.Frame(scrollable_frame)
    chances_frame.pack(pady=20, fill="x")

    tk.Label(chances_frame, text="CHANCES SIMPLES", font=("Arial", 12, "bold")).pack(pady=10)

    # D√©finition des chances simples
    chances_simples = ["R", "N", "PA", "IP", "Mq", "Pss", "D1", "D2", "D3", "C1", "C2", "C3"]
    chances_entries = {}

    # Premi√®re ligne: R - N - PA
    line1_frame = tk.Frame(chances_frame)
    line1_frame.pack(pady=5)

    for i, chance in enumerate(["R", "N", "PA"]):
        tk.Label(line1_frame, text=chance, font=default_font, width=4).grid(row=0, column=i * 3, padx=5)
        entry_x = tk.Entry(line1_frame, width=6, font=default_font)
        entry_x.grid(row=0, column=i * 3 + 1, padx=2)
        entry_y = tk.Entry(line1_frame, width=6, font=default_font)
        entry_y.grid(row=0, column=i * 3 + 2, padx=2)
        chances_entries[chance] = (entry_x, entry_y)

    # Deuxi√®me ligne: IP - Mq - Pss
    line2_frame = tk.Frame(chances_frame)
    line2_frame.pack(pady=5)

    for i, chance in enumerate(["IP", "Mq", "Pss"]):
        tk.Label(line2_frame, text=chance, font=default_font, width=4).grid(row=0, column=i * 3, padx=5)
        entry_x = tk.Entry(line2_frame, width=6, font=default_font)
        entry_x.grid(row=0, column=i * 3 + 1, padx=2)
        entry_y = tk.Entry(line2_frame, width=6, font=default_font)
        entry_y.grid(row=0, column=i * 3 + 2, padx=2)
        chances_entries[chance] = (entry_x, entry_y)

    # Troisi√®me ligne: D1 - D2 - D3
    line3_frame = tk.Frame(chances_frame)
    line3_frame.pack(pady=5)

    for i, chance in enumerate(["D1", "D2", "D3"]):
        tk.Label(line3_frame, text=chance, font=default_font, width=4).grid(row=0, column=i * 3, padx=5)
        entry_x = tk.Entry(line3_frame, width=6, font=default_font)
        entry_x.grid(row=0, column=i * 3 + 1, padx=2)
        entry_y = tk.Entry(line3_frame, width=6, font=default_font)
        entry_y.grid(row=0, column=i * 3 + 2, padx=2)
        chances_entries[chance] = (entry_x, entry_y)

    # Quatri√®me ligne: C1 - C2 - C3
    line4_frame = tk.Frame(chances_frame)
    line4_frame.pack(pady=5)

    for i, chance in enumerate(["C1", "C2", "C3"]):
        tk.Label(line4_frame, text=chance, font=default_font, width=4).grid(row=0, column=i * 3, padx=5)
        entry_x = tk.Entry(line4_frame, width=6, font=default_font)
        entry_x.grid(row=0, column=i * 3 + 1, padx=2)
        entry_y = tk.Entry(line4_frame, width=6, font=default_font)
        entry_y.grid(row=0, column=i * 3 + 2, padx=2)
        chances_entries[chance] = (entry_x, entry_y)

    # Fonction utilitaire pour obtenir tous les widgets dans l'ordre
    def get_all_widgets_in_order():
        widgets = []
        # Num√©ros d'abord (X puis Y pour chaque num√©ro)
        for num in range(37):
            entry_x, entry_y = entries[num]
            widgets.append(entry_x)
            widgets.append(entry_y)
        # Chances simples ensuite (X puis Y pour chaque chance)
        for chance in ["R", "N", "PA", "IP", "Mq", "Pss", "D1", "D2", "D3", "C1", "C2", "C3"]:
            if chance in chances_entries:
                entry_x, entry_y = chances_entries[chance]
                widgets.append(entry_x)
                widgets.append(entry_y)
        return widgets

    # Fonction pour passer au widget suivant
    def focus_next_widget(current_widget):
        all_widgets = get_all_widgets_in_order()
        # Trouver l'index du widget actuel et passer au suivant
        try:
            current_index = all_widgets.index(current_widget)
            next_index = (current_index + 1) % len(all_widgets)
            all_widgets[next_index].focus_set()
        except ValueError:
            # Si le widget n'est pas trouv√© dans la liste, on ne fait rien
            pass

    # Fonction pour capturer les coordonn√©es
    def on_space_press(key):
        if key == keyboard.Key.space:
            x, y = mouse.Controller().position

            # V√©rifier d'abord les chances simples
            for chance, (entry_x, entry_y) in chances_entries.items():
                if entry_x.focus_get() == entry_x:
                    entry_x.delete(0, tk.END)
                    entry_x.insert(0, str(x))
                    # Passer automatiquement au champ Y
                    entry_y.focus_set()
                    return
                elif entry_y.focus_get() == entry_y:
                    entry_y.delete(0, tk.END)
                    entry_y.insert(0, str(y))
                    # Passer automatiquement √† l'√©l√©ment suivant
                    focus_next_widget(entry_y)
                    return

            # V√©rifier les num√©ros 0-36
            for num, (entry_x, entry_y) in entries.items():
                if entry_x.focus_get() == entry_x:
                    entry_x.delete(0, tk.END)
                    entry_x.insert(0, str(x))
                    # Passer automatiquement au champ Y
                    entry_y.focus_set()
                    return
                elif entry_y.focus_get() == entry_y:
                    entry_y.delete(0, tk.END)
                    entry_y.insert(0, str(y))
                    # Passer automatiquement √† l'√©l√©ment suivant
                    focus_next_widget(entry_y)
                    return

    # Fonction pour enregistrer les coordonn√©es
    def save_coordinates():
        # Sauvegarder les num√©ros 0-36
        for num, (entry_x, entry_y) in entries.items():
            try:
                x = int(entry_x.get())
                y = int(entry_y.get())
                coordinates[num] = (x, y)
            except ValueError:
                pass

        # Sauvegarder les chances simples
        for chance, (entry_x, entry_y) in chances_entries.items():
            try:
                x = int(entry_x.get())
                y = int(entry_y.get())
                coordinates[chance] = (x, y)
            except ValueError:
                pass

        # Sauvegarder dans un fichier JSON
        file_path = filedialog.asksaveasfilename(defaultextension=".json", filetypes=[("JSON files", "*.json")])
        if file_path:
            with open(file_path, "w") as file:
                json.dump(coordinates, file)
            messagebox.showinfo("Sauvegarde r√©ussie", f"Configuration sauvegard√©e dans {file_path}.")

    # Fonction pour charger les coordonn√©es
    def load_coordinates():
        file_path = filedialog.askopenfilename(filetypes=[("JSON files", "*.json")])
        if file_path:
            try:
                with open(file_path, "r") as file:
                    loaded_coordinates = json.load(file)

                # Mettre √† jour les num√©ros 0-36
                for num_str, coords in loaded_coordinates.items():
                    if num_str.isdigit():
                        num_int = int(num_str)
                        coordinates[num_int] = tuple(coords)
                        if num_int in entries:
                            entries[num_int][0].delete(0, tk.END)
                            entries[num_int][0].insert(0, str(coords[0]))
                            entries[num_int][1].delete(0, tk.END)
                            entries[num_int][1].insert(0, str(coords[1]))
                    else:
                        # C'est une chance simple
                        coordinates[num_str] = tuple(coords)
                        if num_str in chances_entries:
                            chances_entries[num_str][0].delete(0, tk.END)
                            chances_entries[num_str][0].insert(0, str(coords[0]))
                            chances_entries[num_str][1].delete(0, tk.END)
                            chances_entries[num_str][1].insert(0, str(coords[1]))

                messagebox.showinfo("Chargement r√©ussi", f"Configuration charg√©e depuis {file_path}.")
            except Exception as e:
                messagebox.showerror("Erreur", f"Erreur lors du chargement : {e}")

    # Fonction pour r√©initialiser les coordonn√©es
    def reset_coordinates():
        # R√©initialiser les num√©ros 0-36
        for num, (entry_x, entry_y) in entries.items():
            entry_x.delete(0, tk.END)
            entry_y.delete(0, tk.END)
            coordinates[num] = (0, 0)

        # R√©initialiser les chances simples
        for chance, (entry_x, entry_y) in chances_entries.items():
            entry_x.delete(0, tk.END)
            entry_y.delete(0, tk.END)
            coordinates[chance] = (0, 0)

        messagebox.showinfo("R√©initialisation r√©ussie", "Toutes les coordonn√©es ont √©t√© r√©initialis√©es.")

    # Boutons de contr√¥le
    button_frame = tk.Frame(scrollable_frame)
    button_frame.pack(pady=20)

    tk.Button(button_frame, text="Sauvegarder", font=default_font, command=save_coordinates).pack(side="left", padx=10)
    tk.Button(button_frame, text="Charger Config", font=default_font, command=load_coordinates).pack(side="left",
                                                                                                     padx=10)
    tk.Button(button_frame, text="R√©initialiser Coordinates", font=default_font, command=reset_coordinates).pack(
        side="left", padx=10)

    # D√©marrer l'√©couteur de clavier
    keyboard_listener = keyboard.Listener(on_press=on_space_press)
    keyboard_listener.start()


# Fonction pour le bouton COPY
def copier():
    root.clipboard_clear()
    root.clipboard_append(str(history))
    messagebox.showinfo("Copier", "Historique copi√© dans le presse-papiers.")


# Fonction pour sauvegarder les s√©lections de paris
def sauvegarder_selections():
    messagebox.showinfo("Sauvegarder", "S√©lections de paris sauvegard√©es.")


# Fonction pour effacer les s√©lections dans un cadre sp√©cifique
def effacer_selection(listboxes, counter_labels, active_frame_index):
    active_index = active_frame_index.get()
    if active_index != -1:
        listboxes[active_index].delete(0, tk.END)
        counter_labels[active_index].config(text="0")
        messagebox.showinfo("Effacer", f"Tous les num√©ros du cadre {active_index + 1} ont √©t√© effac√©s.")
    else:
        messagebox.showwarning("Avertissement", "Aucun cadre actif s√©lectionn√©.")


# Fonction pour r√©initialiser tous les cadres
def reinitialiser_cadres(listboxes, counter_labels, nom_entries, series_labels):
    for i in range(28):
        listboxes[i].delete(0, tk.END)
        counter_labels[i].config(text="0")
        nom_entries[i].delete(0, tk.END)
        nom_entries[i].insert(0, f"S√©rie {i + 1}")
        series_labels[i].config(text=f"S√©rie {i + 1}")
    messagebox.showinfo("RESET", "Tous les cadres ont √©t√© r√©initialis√©s.")


# =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =
# Fonction pour ouvrir le panneau secondaire
# =  =  =  =  == =  =  =  =  =  =  =  =  =  =  =

def ouvrir_panneau_secondaire():
    panneau_secondaire = tk.Toplevel(root)
    panneau_secondaire.title("Panneau Secondaire")

    # Variable pour suivre le cadre actif
    active_frame_index = tk.IntVar(value=-1)

    # Cr√©ation des 28 mini-cadres
    frames = []
    listboxes = []
    nom_entries = []
    check_vars = []
    counter_labels = []
    for i in range(28):
        frame = tk.Frame(panneau_secondaire, borderwidth=2, relief="groove")
        frame.grid(row=i // 5, column=i % 5, padx=5, pady=5)
        frames.append(frame)

        # Libell√© BET
        tk.Label(frame, text=f"BET{i + 1}", font=default_font).grid(row=0, column=0, columnspan=2)

        # Case √† cocher pour d√©signer le cadre actif
        check_var = tk.IntVar()
        check_button = tk.Checkbutton(frame, variable=check_var, command=lambda idx=i: active_frame_index.set(idx))
        check_button.grid(row=1, column=0)
        check_vars.append(check_var)

        # Ascenseur
        scrollbar = tk.Scrollbar(frame, orient="vertical")
        listbox = tk.Listbox(frame, yscrollcommand=scrollbar.set, width=10, height=3)  # Taille r√©duite
        scrollbar.config(command=listbox.yview)
        listbox.grid(row=2, column=0, columnspan=2)
        scrollbar.grid(row=2, column=2, sticky="ns")
        listboxes.append(listbox)

        # Compteur
        counter_label = tk.Label(frame, text="0", font=default_font)
        counter_label.grid(row=3, column=0, columnspan=2)
        counter_labels.append(counter_label)

        # Sous-cadre de nomination
        nom_entry = tk.Entry(frame, font=default_font, width=10)  # Taille r√©duite
        nom_entry.grid(row=4, column=0, columnspan=2)
        nom_entries.append(nom_entry)

    # Fonction pour mettre √† jour le compteur et le nom de la s√©rie
    def update_series_info(index):
        # Mettre √† jour le compteur
        counter_labels[index].config(text=f"{listboxes[index].size()}")
        # Mettre √† jour le nom de la s√©rie dans l'interface principale
        series_names[index] = nom_entries[index].get()
        series_labels[index].config(text=series_names[index])

    # Clavier num√©rique pour ins√©rer des num√©ros
    def on_key_press(number):
        active_index = active_frame_index.get()
        if active_index != -1:
            listboxes[active_index].insert(tk.END, number)
            update_series_info(active_index)
            # Ne pas mettre √† jour les compteurs NS, Ec, et Ecmx ici

    # ======================================
    # Cadre pour le clavier et les boutons
    # ======================================

    control_frame = tk.Frame(panneau_secondaire)
    control_frame.grid(row=0, column=5, rowspan=5, padx=10, pady=10)

    # Clavier num√©rique
    numbers = list(range(37))  # Tous les num√©ros de la roulette (0 √† 36)
    for i, num in enumerate(numbers):
        row = i % 13 + 1
        col = i // 13
        btn = tk.Button(control_frame, text=str(num), width=3, height=1, font=default_font,
                        command=lambda n=num: on_key_press(n))
        btn.grid(row=row, column=col, padx=2, pady=2)

    # Boutons suppl√©mentaires
    save_button = tk.Button(control_frame, text="Save my Bet Selections", font=default_font,
                            command=sauvegarder_selections)
    save_button.grid(row=6, column=0, columnspan=6, pady=5)

    effacer_button = tk.Button(control_frame, text="Effacer", font=default_font,
                               command=lambda: effacer_selection(listboxes, counter_labels, active_frame_index))
    effacer_button.grid(row=7, column=0, columnspan=6, pady=5)

    reset_button = tk.Button(control_frame, text="RESET", font=default_font,
                             command=lambda: reinitialiser_cadres(listboxes, counter_labels, nom_entries,
                                                                  series_labels))
    reset_button.grid(row=8, column=0, columnspan=6, pady=5)

    quit_button = tk.Button(control_frame, text="Quit", font=default_font, command=panneau_secondaire.destroy)
    quit_button.grid(row=9, column=0, columnspan=6, pady=5)


# 1. Clavier principal (rest√© √† sa place)
# 2. Cadre "Historique" (juste √† droite du clavier)

# ==================================
# BLOC UNIFI√â : Historique + STR 8V
# ==================================
# =========================================================
# --- CONTENEUR PRINCIPAL UNIFI√â [ HISTO N¬∞ ET STR 8V ]---
# =========================================================

history_str_frame = tk.Frame(main_group_frame, borderwidth=4, relief="ridge", bg="lightblue", width=7)
history_str_frame.grid(row=0, column=3, padx=(5, 10), pady=9, sticky="nw")
history_str_frame.columnconfigure(0, weight=1)

# --- SOUS-CADRE HISTORIQUE (en haut) ---
history_frame = tk.Frame(history_str_frame, bg='lightblue')
history_frame.grid(row=0, column=0, padx=2, pady=(2, 0), sticky="nw")

# Texte de l'historique
history_text = tk.Text(history_frame, bg="Lightyellow", fg="green", width=7, height=28,
                       font=("Arial", 12, "bold"), state=tk.DISABLED)
history_text.pack()

# === ASSURE-TOI QUE LES TAGS D'ALIGNEMENT SONT BIEN CONFIGUR√âS ICI ===


# === CONFIGURATION FINALE DES TAGS - UNIQUEMENT ICI ===
# Ne pas r√©p√©ter ailleurs !

# === CONFIGURATION FINALE DES TAGS - UNIQUEMENT ICI ===
history_text.tag_configure("left", justify="left")
history_text.tag_configure("center", justify="center")
history_text.tag_configure("right", justify="right")

history_text.tag_configure("red", foreground="red")
history_text.tag_configure("black", foreground="black")
history_text.tag_configure("green", foreground="green")
history_text.tag_configure("blue", foreground="blue")
history_text.tag_configure("magenta", foreground="magenta")
history_text.tag_configure("cyan", foreground="cyan")
history_text.tag_configure("brown", foreground="brown")
history_text.tag_configure("purple", foreground="purple")

# Combinaisons alignement + couleur
history_text.tag_configure("left_red", justify="left", foreground="red")
history_text.tag_configure("right_black", justify="right", foreground="black")
history_text.tag_configure("left_blue", justify="left", foreground="blue")
history_text.tag_configure("right_brown", justify="right", foreground="brown")
history_text.tag_configure("left_magenta", justify="left", foreground="magenta")
history_text.tag_configure("right_cyan", justify="right", foreground="cyan")
history_text.tag_configure("left_black", justify="left", foreground="black")
history_text.tag_configure("center_brown", justify="center", foreground="brown")
history_text.tag_configure("right_purple", justify="right", foreground="purple")
history_text.tag_configure("center_green", justify="center", foreground="green")


# --- SOUS-CADRE STR 8V (en bas) ---
huit_voies_frame = tk.Frame(history_str_frame, borderwidth=2, relief="groove", bg='lightblue')
huit_voies_frame.grid(row=1, column=0, padx=2, pady=(0, 2), sticky="nw")


# 3. Libell√© "Nombre de Spins" (juste en haut du cadre "Historique)

# ------ CADRE UNIQUE (3 √©l√©ments) ------
# 1. Cadre (nombre de spin-JH-repet)
button_frame = tk.Frame(main_frame)
button_frame.grid(row=0, column=0, padx=5, pady=5, sticky="w",in_=dyza_frame)


# Compteur "SPINS"
spins_count = tk.StringVar()
spins_count.set(" SPINS : 0")
tk.Label(button_frame, textvariable=spins_count, font=default_font).grid(row=0, column=0, padx=5, pady=2)

# Bouton "JH"
tk.Button(button_frame, text="J.H", font=default_font, bg="DarkGreen",fg="white", borderwidth=8, command=jouer_historique).grid(row=0, column=1, padx=5, pady=2)

# Bouton "REPET" + compteur
tk.Button(button_frame, text="REPET", font=default_font, bg="DarkBlue",fg="white", borderwidth=8,command=repeter).grid(row=1, column=0, padx=5, pady=2)
repet_mollette = tk.Spinbox(button_frame, from_=1, to=20, width=3, font=default_font)
repet_mollette.grid(row=1, column=1, padx=5, pady=2)

# ------ FIN DU CADRE ------

# 6. Libell√©s R/B, E/O, L/H (juste en bas du bouton "REPET")
# Remplacer par :



# Colonne 7 : Bouton Adjust Settings
# adjust_button = tk.Button(series_frame, text="Adjust Settings", font=default_font, command=ouvrir_panneau_secondaire)
# adjust_button.grid(row=29, column=1, rowspan=1)

# Cr√©ation du cadre principal qui contiendra les 4 √©l√©ments
categories_frame = tk.Frame(sixtual_frame, bg="black")
categories_frame.grid(row=3, column=11, padx=10, pady=10, sticky="ne")

# ------ Premi√®re ligne (D2D3 et C1C3) ------
top_frame = tk.Frame(categories_frame, bg="black")
top_frame.pack()

# 1. Cadre D2D3 (NR1)
nr1_frame = tk.Frame(top_frame, bg="black")
nr1_frame.pack(side="left", padx=5, pady=5)
nr1_main_frame = tk.Frame(nr1_frame, bg="black")
nr1_main_frame.pack(fill="both", expand=True)
tk.Label(nr1_main_frame, textvariable=nr1_counter, bg="black", fg="white", font=default_font).pack(side="left", padx=5)
nr1_button = tk.Button(nr1_main_frame, text="D2D3", bg="black", fg="white", font=default_font,
                       command=lambda: jouer_category(nr1_numbers_list, "NR1"))
nr1_button.pack(side="left", padx=5)
nr1_canvas = tk.Canvas(nr1_main_frame, bg="black", height=30, width=75)
nr1_scrollbar = tk.Scrollbar(nr1_frame, orient="horizontal", command=nr1_canvas.xview)
nr1_canvas.configure(xscrollcommand=nr1_scrollbar.set)
nr1_inner_frame = tk.Frame(nr1_canvas, bg="black")
nr1_canvas.create_window((0, 0), window=nr1_inner_frame, anchor="nw")
nr1_inner_frame.bind("<Configure>", lambda event: nr1_canvas.configure(scrollregion=nr1_canvas.bbox("all")))
nr1_canvas.pack(side="left", fill="both", expand=True)
nr1_scrollbar.pack(side="bottom", fill="x")

# 2. Cadre C1C3 (NR3)
nr3_frame = tk.Frame(top_frame, bg="black")
nr3_frame.pack(side="left", padx=5, pady=5)
nr3_main_frame = tk.Frame(nr3_frame, bg="black")
nr3_main_frame.pack(fill="both", expand=True)
tk.Label(nr3_main_frame, textvariable=nr3_counter, bg="black", fg="white", font=default_font).pack(side="left", padx=5)
nr3_button = tk.Button(nr3_main_frame, text="C1C3", bg="black", fg="white", font=default_font,
                       command=lambda: jouer_category(nr3_numbers_list, "NR3"))
nr3_button.pack(side="left", padx=5)
nr3_canvas = tk.Canvas(nr3_main_frame, bg="black", height=30, width=75)
nr3_scrollbar = tk.Scrollbar(nr3_frame, orient="horizontal", command=nr3_canvas.xview)
nr3_canvas.configure(xscrollcommand=nr3_scrollbar.set)
nr3_inner_frame = tk.Frame(nr3_canvas, bg="black")
nr3_canvas.create_window((0, 0), window=nr3_inner_frame, anchor="nw")
nr3_inner_frame.bind("<Configure>", lambda event: nr3_canvas.configure(scrollregion=nr3_canvas.bbox("all")))
nr3_canvas.pack(side="left", fill="both", expand=True)
nr3_scrollbar.pack(side="bottom", fill="x")

# ------ Deuxi√®me ligne (C1C2 et C2C3) ------
bottom_frame = tk.Frame(categories_frame, bg="black")
bottom_frame.pack()

# 3. Cadre C1C2 (NR2)
nr2_frame = tk.Frame(bottom_frame, bg="black")
nr2_frame.pack(side="left", padx=5, pady=5)
nr2_main_frame = tk.Frame(nr2_frame, bg="black")
nr2_main_frame.pack(fill="both", expand=True)
tk.Label(nr2_main_frame, textvariable=nr2_counter, bg="black", fg="white", font=default_font).pack(side="left", padx=5)
nr2_button = tk.Button(nr2_main_frame, text="C1C2", bg="black", fg="white", font=default_font,
                       command=lambda: jouer_category(nr2_numbers_list, "NR2"))
nr2_button.pack(side="left", padx=5)
nr2_canvas = tk.Canvas(nr2_main_frame, bg="black", height=30, width=75)
nr2_scrollbar = tk.Scrollbar(nr2_frame, orient="horizontal", command=nr2_canvas.xview)
nr2_canvas.configure(xscrollcommand=nr2_scrollbar.set)
nr2_inner_frame = tk.Frame(nr2_canvas, bg="black")
nr2_canvas.create_window((0, 0), window=nr2_inner_frame, anchor="nw")
nr2_inner_frame.bind("<Configure>", lambda event: nr2_canvas.configure(scrollregion=nr2_canvas.bbox("all")))
nr2_canvas.pack(side="left", fill="both", expand=True)
nr2_scrollbar.pack(side="bottom", fill="x")

# 4. Cadre C2C3 (NR4)
nr4_frame = tk.Frame(bottom_frame, bg="black")
nr4_frame.pack(side="left", padx=5, pady=5)
nr4_main_frame = tk.Frame(nr4_frame, bg="black")
nr4_main_frame.pack(fill="both", expand=True)
tk.Label(nr4_main_frame, textvariable=nr4_counter, bg="black", fg="white", font=default_font).pack(side="left", padx=5)
nr4_button = tk.Button(nr4_main_frame, text="C2C3", bg="black", fg="white", font=default_font,
                       command=lambda: jouer_category(nr4_numbers_list, "NR4"))
nr4_button.pack(side="left", padx=5)
nr4_canvas = tk.Canvas(nr4_main_frame, bg="black", height=30, width=75)
nr4_scrollbar = tk.Scrollbar(nr4_frame, orient="horizontal", command=nr4_canvas.xview)
nr4_canvas.configure(xscrollcommand=nr4_scrollbar.set)
nr4_inner_frame = tk.Frame(nr4_canvas, bg="black")
nr4_canvas.create_window((0, 0), window=nr4_inner_frame, anchor="nw")
nr4_inner_frame.bind("<Configure>", lambda event: nr4_canvas.configure(scrollregion=nr4_canvas.bbox("all")))
nr4_canvas.pack(side="left", fill="both", expand=True)
nr4_scrollbar.pack(side="bottom", fill="x")

# Ajouter un champ d'entr√©e pour la vitesse de clic

# Remplacer par :
speed_frame = tk.Frame(sixtual_frame)
speed_frame.grid(row=0, column=12, columnspan=10, padx=10, pady=5)
tk.Label(speed_frame, text="Vitesse de clic (ms):", font=default_font).grid(row=2, column=4, padx=5, pady=5)
speed_entry = tk.Entry(speed_frame, width=3, font=default_font)
speed_entry.grid(row=2, column=11, padx=5, pady=5)
speed_entry.insert(0, "75")  # Valeur par d√©faut pour la vitesse de clic




# Fonction pour mettre √† jour les √©carts
def update_ecarts(number):
    for tableau_name, tableau in [("SIXAIN", SIXAIN), ("CARRE", CARRE), ("V1", V1), ("V2", V2),
                                  ("TVR", TVR), ("CVX", CVX), ("V3", V3), ("V4", V4)]:
        for i, ligne in enumerate(tableau):
            if number in ligne:
                ecarts[tableau_name][i] = 0  # R√©initialiser l'√©cart si le num√©ro est dans la ligne
            else:
                ecarts[tableau_name][i] += 1  # Incr√©menter l'√©cart sinon


# =============================================
# FONCTIONS MODIFI√âES POUR LE BOUTON P18 (ancien P20)
# =============================================

# Fonction pour obtenir les 18 num√©ros les plus chauds (fr√©quents) dans tout l'historique
def get_hot_18_numbers():
    if len(history) < 37:
        return None  # Pas assez de donn√©es

    # Compter la fr√©quence de chaque num√©ro dans tout l'historique
    freq = {num: 0 for num in range(37)}
    for num in history:
        freq[num] += 1

    # Trier par fr√©quence d√©croissante
    sorted_freq = sorted(freq.items(), key=lambda x: x[1], reverse=True)

    # Prendre les 18 premiers num√©ros (les plus chauds)
    hot_18 = [num for num, count in sorted_freq[:18]]
    return hot_18


# Fonction pour jouer directement les 18 num√©ros les plus chauds
def play_hot_18_numbers():
    if len(history) < 37:
        messagebox.showinfo("P18", "Historique insuffisant : besoin d'au moins 37 num√©ros.")
        return

    hot_18 = get_hot_18_numbers()
    if not hot_18:
        messagebox.showinfo("P18", "Impossible d'extraire les 18 num√©ros chauds.")
        return

    # R√©cup√©rer la vitesse de clic
    try:
        click_speed = int(speed_entry.get())
    except ValueError:
        messagebox.showerror("Erreur", "La vitesse de clic doit √™tre un nombre entier.")
        return

    # R√©cup√©rer le nombre de r√©p√©titions
    try:
        repetitions = int(repet_mollette.get())
    except ValueError:
        messagebox.showerror("Erreur", "La valeur de r√©p√©tition doit √™tre un nombre entier.")
        return

    # Jouer chaque num√©ro avec r√©p√©tition
    played = []
    for num in hot_18:
        if num in coordinates:
            x, y = coordinates[num]
            if x > 0 and y > 0:
                for _ in range(repetitions):
                    pyautogui.click(x, y)
                    time.sleep(click_speed / 1000)
                played.append(num)
            else:
                messagebox.showwarning("Avertissement", f"Coordonn√©es manquantes pour le num√©ro {num}.")
        else:
            messagebox.showwarning("Avertissement", f"Coordonn√©es manquantes pour le num√©ro {num}.")

    print(f"[P18] Num√©ros jou√©s : {sorted(played)}")


# Fonction pour le bouton P18 (remplace P20)
def play_P18():
    play_hot_18_numbers()






# Int√©gration du code A dans le code principal
# ====================================================
# Fonction pour lancer la Martingale Classique (class)
# ====================================================
class Martingale:
    def __init__(self):
        self.spins = 0
        self.numbers_to_play = 0
        self.initial_bet = 1
        self.total_bet = 0
        self.cumulative_bets = 0
        self.initial_ratio = 36
        self.gain = 0
        self.profit = 0
        self.bet_multiplier = 1

    def setup_game(self):
        self.numbers_to_play = int(numbers_to_play_entry.get())
        self.initial_bet = float(initial_bet_entry.get())
        self.initial_ratio = float(initial_ratio_entry.get())
        self.reset_game()

    def reset_game(self):
        self.spins = 1
        self.bet_multiplier = 1
        self.total_bet = self.initial_bet * self.numbers_to_play * self.bet_multiplier
        self.cumulative_bets = 0
        self.update_profit()
        self.display_status()

    def update_profit(self):
        while True:
            gain = self.bet_multiplier * self.numbers_to_play * self.initial_bet * self.initial_ratio / self.numbers_to_play
            cumulative_bets = self.cumulative_bets + self.total_bet
            profit = gain - cumulative_bets

            if profit > 0:
                break
            else:
                self.bet_multiplier += 1
                self.total_bet = self.initial_bet * self.numbers_to_play * self.bet_multiplier

    def display_status(self):
        result_text.config(state=tk.NORMAL)
        result_text.delete(1.0, tk.END)
        gain = self.bet_multiplier * self.numbers_to_play * self.initial_bet * self.initial_ratio / self.numbers_to_play
        cumulative_bets = self.cumulative_bets + self.total_bet
        profit = gain - cumulative_bets

        result_text.insert(tk.END, f"Spins : {self.spins}\n")
        result_text.insert(tk.END, f"Nb de Num√©ro : {self.numbers_to_play}\n")
        result_text.insert(tk.END, f"Mise Initiale : {self.initial_bet}\n")
        result_text.insert(tk.END, f"Coeft de Mise : {self.bet_multiplier}\n")
        result_text.insert(tk.END, f"Mise Totale : {self.total_bet:.2f}\n")
        result_text.insert(tk.END, f"Mises Cumul : {cumulative_bets:.2f}\n")
        result_text.insert(tk.END, f"Rapport Init : 1 pour {self.initial_ratio}\n")
        result_text.insert(tk.END, f"Gain : {gain:.2f}\n")
        result_text.insert(tk.END, f"Profit : {profit:.2f}\n")
        result_text.config(state=tk.DISABLED)

    def play(self):
        self.setup_game()
        self.display_status()
        while True:
            root.wait_variable(action_var)
            action = action_var.get()
            if action == 'P':
                self.spins += 1
                self.cumulative_bets += self.total_bet
                self.update_profit()
                self.display_status()
                action_var.set('')  # R√©initialiser la variable d'action
            elif action == 'G':
                messagebox.showinfo("Pr√™t pour le prochain combat", "Pr√™t pour le prochain combat.")
                self.reset_game()
                break
            else:
                messagebox.showwarning("Action non reconnue", "Veuillez appuyer sur 'P' ou 'G'.")


# Fonction pour afficher les r√©sultats du code A dans l'interface principale
def display_martingale_results():
    global game
    game = Martingale()
    game.play()


# ===================================================
# Fonction pour lancer la Martingale Additive ( add )
# ===================================================
def start_martingale_additive():
    global add_numbers_to_play_entry, add_initial_bet_entry, add_initial_ratio_entry, add_action_var, add_result_text
    # Cr√©er une nouvelle fen√™tre pour les entr√©es de la Martingale Additive
    add_martingale_window = tk.Toplevel(root)
    add_martingale_window.title("Martingale Additive Input")

    # Variables pour les entr√©es
    add_numbers_to_play_entry = tk.Entry(add_martingale_window, font=default_font)
    add_initial_bet_entry = tk.Entry(add_martingale_window, font=default_font)
    add_initial_ratio_entry = tk.Entry(add_martingale_window, font=default_font)
    add_action_var = tk.StringVar(value="")
    add_result_text = tk.Text(main_frame, bg="#2E3440", fg="#D8DEE9", width=25, height=10,
                              font=("Consolas", 11), relief="raised", bd=3, padx=10, pady=10)

    # √âtiquettes et entr√©es pour les valeurs de la Martingale Additive
    tk.Label(add_martingale_window, text="Nombre de Num√©ros √† jouer:", font=default_font).pack(pady=5)
    add_numbers_to_play_entry.pack(pady=5)
    tk.Label(add_martingale_window, text="Mise Initiale (en euros):", font=default_font).pack(pady=5)
    add_initial_bet_entry.pack(pady=5)
    tk.Label(add_martingale_window, text="Rapport Initial (par d√©faut 36):", font=default_font).pack(pady=5)
    add_initial_ratio_entry.pack(pady=5)

    # Boutons pour les actions 'P' et 'G'
    tk.Button(add_martingale_window, text="Perdre (P)", font=default_font,
              command=lambda: add_action_var.set('P')).pack(side="left", padx=5, pady=5)
    tk.Button(add_martingale_window, text="Gagner (G)", font=default_font,
              command=lambda: add_action_var.set('G')).pack(side="left", padx=5, pady=5)

    # Bouton pour d√©marrer la Martingale Additive
    tk.Button(add_martingale_window, text="D√©marrer Martingale Additive", font=default_font,
              command=display_martingale_additive_results).pack(pady=5)

    # Afficher les r√©sultats dans l'interface principale
    add_result_text.grid(row=0, column=8, rowspan=2, padx=15, pady=15)


# Fonction pour r√©initialiser la Martingale Additive
def reset_martingale_additive():
    global add_game, add_numbers_to_play_entry, add_initial_bet_entry, add_initial_ratio_entry, add_action_var, add_result_text
    # R√©initialiser les variables de la Martingale Additive
    add_game = MartingaleAdditive()
    # Effacer le contenu du widget add_result_text
    add_result_text.config(state=tk.NORMAL)
    add_result_text.delete(1.0, tk.END)
    add_result_text.config(state=tk.DISABLED)
    # R√©initialiser les entr√©es de l'interface "Martingale Additive Input"
    add_numbers_to_play_entry.delete(0, tk.END)
    add_initial_bet_entry.delete(0, tk.END)
    add_initial_ratio_entry.delete(0, tk.END)
    add_action_var.set('')


# Fonction pour lancer le code A
def start_martingale():
    global numbers_to_play_entry, initial_bet_entry, initial_ratio_entry, action_var, result_text
    # Cr√©er une nouvelle fen√™tre pour les entr√©es de la Martingale
    martingale_window = tk.Toplevel(root)
    martingale_window.title("Martingale Input")

    # Variables pour les entr√©es
    numbers_to_play_entry = tk.Entry(martingale_window, font=default_font)
    initial_bet_entry = tk.Entry(martingale_window, font=default_font)
    initial_ratio_entry = tk.Entry(martingale_window, font=default_font)
    action_var = tk.StringVar(value="")
    result_text = tk.Text(main_frame, bg="#2E3440", fg="#D8DEE9", width=25, height=10,
                          font=("Consolas", 11), relief="raised", bd=3, padx=10, pady=5)

    # √âtiquettes et entr√©es pour les valeurs de la Martingale
    tk.Label(martingale_window, text="Nombre de Num√©ros √† jouer:", font=default_font).pack(pady=5)
    numbers_to_play_entry.pack(pady=5)
    tk.Label(martingale_window, text="Mise Initiale (en euros):", font=default_font).pack(pady=5)
    initial_bet_entry.pack(pady=5)
    tk.Label(martingale_window, text="Rapport Initial (par d√©faut 36):", font=default_font).pack(pady=5)
    initial_ratio_entry.pack(pady=5)

    # Boutons pour les actions 'P' et 'G'
    tk.Button(martingale_window, text="Perdre (P)", font=default_font, command=lambda: action_var.set('P')).pack(
        side="left", padx=5, pady=5)
    tk.Button(martingale_window, text="Gagner (G)", font=default_font, command=lambda: action_var.set('G')).pack(
        side="left", padx=5, pady=5)

    # Bouton pour d√©marrer la Martingale
    tk.Button(martingale_window, text="D√©marrer Martingale", font=default_font,
              command=display_martingale_results).pack(pady=5)

    # Afficher les r√©sultats dans l'interface principale
    result_text.grid(row=0, column=8, rowspan=2, padx=15, pady=15)


# Fonction pour r√©initialiser la Martingale
def reset_martingale():
    global game, numbers_to_play_entry, initial_bet_entry, initial_ratio_entry, action_var, result_text
    # R√©initialiser les variables de la Martingale
    game = Martingale()
    # Effacer le contenu du widget result_text
    result_text.config(state=tk.NORMAL)
    result_text.delete(1.0, tk.END)
    result_text.config(state=tk.DISABLED)
    # R√©initialiser les entr√©es de l'interface "Martingale Input"
    numbers_to_play_entry.delete(0, tk.END)
    initial_bet_entry.delete(0, tk.END)
    initial_ratio_entry.delete(0, tk.END)
    action_var.set('')


# ==================================
# CADRE UNIQUE : CLAVIER + MOSAIQUE
# ==================================
clavier_bloc = tk.Frame(main_group_frame, bg='green', borderwidth=6, relief="groove")
clavier_bloc.grid(row=0, column=1, padx=65, pady=10, sticky="nw")

# --- 1. SOUS-BLOC : CLAVIER PRINCIPAL ---
keyboard_frame = tk.Frame(clavier_bloc, height=740, width=230, bg="MediumTurquoise", borderwidth=4, relief="raised")
keyboard_frame.pack(padx=5, pady=5, anchor="center")
keyboard_frame.grid_propagate(False)

# Param√®tres pour chaque bouton
button_height = 15
button_width = 15
button_font = ("Helvetica", 17, "bold")

# Liste des num√©ros dans l'ordre des colonnes
numbers_in_order = [
    0, 1, 4, 7, 10, 13, 16, 19, 22, 25, 28, 31, 34,
    2, 5, 8, 11, 14, 17, 20, 23, 26, 29, 32, 35,
    3, 6, 9, 12, 15, 18, 21, 24, 27, 30, 33, 36
]

# Cr√©ation des boutons
buttons = {}
for i, num in enumerate(numbers_in_order):
    if num in RED_NUMBERS:
        bg_color, fg_color = "red", "white"
    elif num in BLACK_NUMBERS:
        bg_color, fg_color = "black", "white"
    elif num in ZERO_NUMBER:
        bg_color, fg_color = "green", "white"

    if num == 0:
        row, col = 0, 1
    else:
        row = (i - 1) % 12 + 1
        col = (i - 1) // 12
        if col < 0:
            col = 0

    btn = tk.Button(
        keyboard_frame,
        text=str(num),
        font=("Arial", 12, "bold"),
        bg=bg_color,
        fg=fg_color,
        borderwidth=2,
        width=6,
        height=2,
        command=lambda n=num: on_number_click(n)
    )
    btn.grid(row=row, column=col, padx=2, pady=2)
    buttons[num] = btn


# Fonction pour cr√©er les labels apr√®s affichage
def setup_labels():
    keyboard_frame.update_idletasks()
    for num, btn in buttons.items():
        if btn.winfo_exists():
            create_counter_label(keyboard_frame, num, btn)
            create_ecart_label(keyboard_frame, num, btn)


root.after(300, setup_labels)

# --- 2. SOUS-BLOC : MOSAIQUE (F23/F14 + HIGH/LOW + CARTER) ---
mosaique = tk.Frame(clavier_bloc, bg='lightblue', borderwidth=4, relief="groove")
mosaique.pack(fill="x", padx=5, pady=5)

# --- 2.1. F23/F14 + HIGH/LOW ---
f23_high_frame = tk.Frame(mosaique, bg="MediumTurquoise", borderwidth=4, relief="groove")
f23_high_frame.pack(fill="x", padx=5, pady=5)

for i in range(5):
    f23_high_frame.columnconfigure(i, weight=1)

tk.Label(f23_high_frame, text="F23/F14 & HIGH/LOW", font=("Helvetica", 13, "bold"), bg="lightyellow").grid(row=0,
                                                                                                           column=0,
                                                                                                           columnspan=5)

# Ligne F23
tk.Label(f23_high_frame, textvariable=f23_ec_var, font=("Helvetica", 13, "bold"), bg="lightgray").grid(row=1, column=0,
                                                                                                       sticky="w",
                                                                                                       padx=2)
tk.Label(f23_high_frame, textvariable=f23_display_var, font=("Courier", 9), width=5, anchor="w", bg="white").grid(row=1,
                                                                                                                  column=1,
                                                                                                                  padx=2)
tk.Label(f23_high_frame, textvariable=f23_ecmx_var, font=("Helvetica", 13, "bold"), bg="lightgray").grid(row=1,
                                                                                                         column=2,
                                                                                                         sticky="e",
                                                                                                         padx=2)
tk.Button(f23_high_frame, text="F23", font=("Helvetica", 13, "bold"),borderwidth=7, command=lambda: play_numbers(f23_numbers)).grid(
    row=1, column=4, padx=2)

# Ligne F14
tk.Label(f23_high_frame, textvariable=f14_ec_var, font=("Helvetica", 13, "bold"), bg="lightgray").grid(row=2, column=0,
                                                                                                       sticky="w",
                                                                                                       padx=2)
tk.Label(f23_high_frame, textvariable=f14_display_var, font=("Courier", 9), width=5, anchor="w", bg="white").grid(row=2,
                                                                                                                  column=1,
                                                                                                                  padx=2)
tk.Label(f23_high_frame, textvariable=f14_ecmx_var, font=("Helvetica", 13, "bold"), bg="lightgray").grid(row=2,
                                                                                                         column=2,
                                                                                                         sticky="e",
                                                                                                         padx=2)
tk.Button(f23_high_frame, text="F14", font=("Helvetica", 13, "bold"), borderwidth=7,command=lambda: play_numbers(f14_numbers)).grid(
    row=2, column=4, padx=2)

# Ligne HIGH
tk.Label(f23_high_frame, textvariable=high_count_var, font=("Helvetica", 13, "bold"), bg="black", fg="yellow",
         width=3).grid(row=3, column=0, padx=2, sticky="w")
tk.Label(f23_high_frame, textvariable=high_ec_var, font=("Helvetica", 13, "bold"), bg="lightgray").grid(row=3, column=1,
                                                                                                        sticky="w",
                                                                                                        padx=2)
tk.Label(f23_high_frame, textvariable=high_display_var, font=("Courier", 9), width=5, anchor="w", bg="white").grid(
    row=3, column=2, padx=2)
tk.Label(f23_high_frame, textvariable=high_ecmx_var, font=("Helvetica", 13, "bold"), bg="lightgray").grid(row=3,
                                                                                                          column=3,
                                                                                                          sticky="e",
                                                                                                          padx=2)
tk.Button(f23_high_frame, text="High", font=("Helvetica", 13, "bold"), borderwidth=7,command=lambda: play_numbers(high_numbers)).grid(
    row=3, column=4, padx=2)

# Ligne LOW
tk.Label(f23_high_frame, textvariable=low_count_var, font=("Helvetica", 13, "bold"), bg="black", fg="yellow",
         width=3).grid(row=4, column=0, padx=2, sticky="w")
tk.Label(f23_high_frame, textvariable=low_ec_var, font=("Helvetica", 13, "bold"), bg="lightgray").grid(row=4, column=1,
                                                                                                       sticky="w",
                                                                                                       padx=2)
tk.Label(f23_high_frame, textvariable=low_display_var, font=("Courier", 9), width=5, anchor="w", bg="white").grid(row=4,
                                                                                                                  column=2,
                                                                                                                  padx=2)
tk.Label(f23_high_frame, textvariable=low_ecmx_var, font=("Helvetica", 13, "bold"), bg="lightgray").grid(row=4,
                                                                                                         column=3,
                                                                                                         sticky="e",
                                                                                                         padx=2)
tk.Button(f23_high_frame, text="Low", font=("Helvetica", 13, "bold"), borderwidth=7,command=lambda: play_numbers(low_numbers)).grid(
    row=4, column=4, padx=2)

# --- 2.2. CARTER (Boutons) ---
carter = tk.Frame(mosaique, bg='Darkgray', borderwidth=4, relief="groove")
carter.pack(fill="x", padx=5, pady=5)

# Boutons RETOUR, IMPORT, etc.
tk.Button(carter, text="   RETOUR    ", font=default_font, borderwidth=7, command=retour).grid(row=0, column=0, padx=10, pady=2)
tk.Button(carter, text="   IMPORT    ", font=default_font, borderwidth=7,command=importer).grid(row=0, column=1, padx=10, pady=2)

tk.Button(carter, text="   RESET       ", font=default_font, borderwidth=7,command=reset).grid(row=1, column=0, padx=10, pady=2)
tk.Button(carter, text="    COPY       ", font=default_font, borderwidth=7,command=copier).grid(row=1, column=1, padx=10, pady=2)

tk.Button(carter, text="  QUITTER    ", font=default_font, borderwidth=7,command=quitter).grid(row=2, column=0, padx=10, pady=2)
tk.Button(carter, text="Table Setup", font=default_font, borderwidth=7,command=table_setup).grid(row=2, column=1, padx=10, pady=2)

# Boutons MTG
tk.Button(carter, text="    MTG N       ", font=default_font, borderwidth=7,command=start_martingale).grid(row=3, column=0, padx=10,
                                                                                             pady=2)
tk.Button(carter, text="    RT MTG    ", font=default_font, borderwidth=7,command=reset_martingale).grid(row=3, column=1, padx=10,
                                                                                           pady=2)

tk.Button(carter, text="  MTG ADD    ", font=default_font, borderwidth=7,command=start_martingale_additive).grid(row=4, column=0,
                                                                                                   padx=10, pady=2)
tk.Button(carter, text="    RT ADD     ", font=default_font, borderwidth=7,command=reset_martingale_additive).grid(row=4, column=1,
                                                                                                     padx=10, pady=2)


# NE PAS AJOUTER CETTE FONCTION - ELLE EXISTE D√âJ√Ä AILLEURS DANS TON CODE
# def on_number_click(num):
#     # Votre logique existante ici...
#     # Puis mettre √† jour les affichages
#     update_counter_display(num)
#     update_ecart_display(num)

# Cr√©ation d'un cadre pour les boutons MTG

# Int√©gration de la Martingale Additive
class MartingaleAdditive:
    def __init__(self):
        self.spins = 0
        self.initial_numbers_to_play = 0
        self.numbers_to_play = 0
        self.initial_bet = 1
        self.total_bet = 0
        self.cumulative_bets = 0
        self.initial_ratio = 36
        self.gain = 0
        self.profit = 0
        self.bet_multiplier = 1

    def setup_game(self):
        self.initial_numbers_to_play = int(add_numbers_to_play_entry.get())
        self.numbers_to_play = self.initial_numbers_to_play
        self.initial_bet = float(add_initial_bet_entry.get())
        self.initial_ratio = float(add_initial_ratio_entry.get())
        self.reset_game()

    def reset_game(self):
        self.spins = 1
        self.numbers_to_play = self.initial_numbers_to_play
        self.bet_multiplier = 1
        self.total_bet = self.initial_bet * self.numbers_to_play * self.bet_multiplier
        self.cumulative_bets = 0
        self.update_profit()
        self.display_status()

    def update_profit(self):
        while True:
            gain = self.bet_multiplier * self.numbers_to_play * self.initial_bet * self.initial_ratio / self.numbers_to_play
            cumulative_bets = self.cumulative_bets + self.total_bet
            profit = gain - cumulative_bets

            if profit > 0:
                break
            else:
                self.bet_multiplier += 1
                self.total_bet = self.initial_bet * self.numbers_to_play * self.bet_multiplier

    def display_status(self):
        add_result_text.config(state=tk.NORMAL)
        add_result_text.delete(1.0, tk.END)
        gain = self.bet_multiplier * self.numbers_to_play * self.initial_bet * self.initial_ratio / self.numbers_to_play
        cumulative_bets = self.cumulative_bets + self.total_bet
        profit = gain - cumulative_bets

        add_result_text.insert(tk.END, f"Spins : {self.spins}\n")
        add_result_text.insert(tk.END, f"Nb de Num√©ro : {self.numbers_to_play}\n")
        add_result_text.insert(tk.END, f"Mise Initiale : {self.initial_bet}\n")
        add_result_text.insert(tk.END, f"Coef de Mise : {self.bet_multiplier}\n")
        add_result_text.insert(tk.END, f"Mise Totale : {self.total_bet:.2f}\n")
        add_result_text.insert(tk.END, f"Mises Cumul: {cumulative_bets:.2f}\n")
        add_result_text.insert(tk.END, f"Rapport Init: 1 pour {self.initial_ratio}\n")
        add_result_text.insert(tk.END, f"Gain : {gain:.2f}\n")
        add_result_text.insert(tk.END, f"Profit : {profit:.2f}\n")
        add_result_text.config(state=tk.DISABLED)

    def play(self):
        self.setup_game()
        self.display_status()
        while True:
            root.wait_variable(add_action_var)
            action = add_action_var.get()
            if action == 'P':
                self.spins += 1
                self.numbers_to_play = self.initial_numbers_to_play + self.spins - 1
                self.cumulative_bets += self.total_bet
                self.update_profit()
                self.total_bet = self.initial_bet * self.numbers_to_play * self.bet_multiplier
                self.display_status()
                add_action_var.set('')  # R√©initialiser la variable d'action
            elif action == 'G':
                messagebox.showinfo("Pr√™t pour le prochain combat", "Pr√™t pour le prochain combat.")
                self.reset_game()
                break
            else:
                messagebox.showwarning("Action non reconnue", "Veuillez appuyer sur 'P' ou 'G'.")


# Fonction pour afficher les r√©sultats de la Martingale Additive dans l'interface principale
def display_martingale_additive_results():
    global add_game
    add_game = MartingaleAdditive()
    add_game.play()


# Tableaux de base
SIXAIN = [
    [1, 2, 3, 4, 5, 6],
    [4, 5, 6, 7, 8, 9],
    [7, 8, 9, 10, 11, 12],
    [10, 11, 12, 13, 14, 15],
    [13, 14, 15, 16, 17, 18],
    [16, 17, 18, 19, 20, 21],
    [19, 20, 21, 22, 23, 24],
    [22, 23, 24, 25, 26, 27],
    [25, 26, 27, 28, 29, 30],
    [28, 29, 30, 31, 32, 33],
    [31, 32, 33, 34, 35, 36]
]

CARRE = [
    [1, 2, 4, 5],
    [2, 3, 5, 6],
    [4, 5, 7, 8],
    [5, 6, 8, 9],
    [7, 8, 10, 11],
    [8, 9, 11, 12],
    [10, 11, 13, 14],
    [11, 12, 14, 15],
    [13, 14, 16, 17],
    [14, 15, 17, 18],
    [16, 17, 19, 20],
    [17, 18, 20, 21],
    [19, 20, 22, 23],
    [20, 21, 23, 24],
    [22, 23, 25, 26],
    [23, 24, 26, 27],
    [25, 26, 28, 29],
    [26, 27, 29, 30],
    [28, 29, 31, 32],
    [29, 30, 32, 33],
    [31, 32, 34, 35],
    [32, 33, 35, 36]
]

TVR = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9],
    [10, 11, 12],
    [13, 14, 15],
    [16, 17, 18],
    [19, 20, 21],
    [22, 23, 24],
    [25, 26, 27],
    [28, 29, 30],
    [31, 32, 33],
    [34, 35, 36]
]

CVX = [
    [1, 4],
    [1, 2],
    [2, 5],
    [2, 3],
    [3, 6],
    [4, 5],
    [4, 7],
    [5, 6],
    [6, 9],
    [5, 8],
    [7, 8],
    [7, 10],
    [8, 9],
    [8, 11],
    [9, 12],
    [10, 11],
    [10, 13],
    [11, 12],
    [11, 14],
    [12, 15],
    [13, 16],
    [13, 14],
    [14, 15],
    [14, 17],
    [15, 18],
    [16, 17],
    [16, 19],
    [17, 18],
    [17, 20],
    [18, 21],
    [19, 22],
    [19, 20],
    [20, 21],
    [20, 23],
    [21, 24],
    [22, 25],
    [22, 23],
    [23, 24],
    [23, 26],
    [24, 27],
    [25, 28],
    [25, 26],
    [26, 27],
    [26, 29],
    [27, 30],
    [28, 29],
    [28, 31],
    [29, 30],
    [29, 32],
    [30, 33],
    [31, 32],
    [31, 34],
    [32, 33],
    [32, 35],
    [33, 36],
    [34, 35],
    [35, 36]
]

V1 = [
    [0, 26, 32],
    [1, 33, 20],
    [2, 21, 25],
    [3, 35, 26],
    [4, 19, 21],
    [5, 10, 24],
    [6, 34, 27],
    [7, 29, 28],
    [8, 30, 23],
    [9, 31, 22],
    [10, 23, 5],
    [11, 36, 30],
    [12, 28, 35],
    [13, 27, 36],
    [14, 20, 31],
    [15, 32, 19],
    [16, 24, 33],
    [17, 25, 34],
    [18, 22, 29],
    [19, 15, 4],
    [20, 1, 14],
    [21, 4, 2],
    [22, 9, 18],
    [23, 8, 10],
    [24, 5, 16],
    [25, 2, 17],
    [26, 3, 0],
    [27, 6, 13],
    [28, 7, 12],
    [29, 18, 7],
    [30, 11, 8],
    [31, 14, 9],
    [32, 0, 15],
    [33, 16, 1],
    [34, 17, 6],
    [35, 12, 3],
    [36, 13, 11]
]

V2 = [
    [0, 3, 26, 32, 15],
    [1, 16, 33, 20, 14],
    [2, 4, 21, 25, 17],
    [3, 12, 35, 26, 0],
    [4, 15, 19, 21, 2],
    [5, 23, 10, 24, 16],
    [6, 17, 34, 27, 13],
    [7, 18, 29, 28, 12],
    [8, 11, 30, 23, 10],
    [9, 14, 31, 22, 18],
    [10, 8, 23, 5, 24],
    [11, 13, 36, 30, 8],
    [12, 7, 28, 35, 3],
    [13, 6, 27, 36, 11],
    [14, 1, 20, 31, 9],
    [15, 0, 32, 19, 4],
    [16, 5, 24, 33, 1],
    [17, 2, 25, 34, 6],
    [18, 9, 22, 29, 7],
    [19, 32, 15, 4, 21],
    [20, 33, 1, 14, 31],
    [21, 19, 4, 2, 25],
    [22, 31, 9, 18, 29],
    [23, 30, 8, 10, 5],
    [24, 10, 5, 16, 33],
    [25, 21, 2, 17, 34],
    [26, 35, 3, 0, 32],
    [27, 34, 6, 13, 36],
    [28, 29, 7, 12, 35],
    [29, 22, 18, 7, 28],
    [30, 36, 11, 8, 23],
    [31, 20, 14, 9, 22],
    [32, 26, 0, 15, 19],
    [33, 24, 16, 1, 20],
    [34, 25, 17, 6, 27],
    [35, 28, 12, 3, 26],
    [36, 27, 13, 11, 30],

]

V3 = [
    [0, 35, 3, 26, 15, 19, 4],
    [1, 24, 16, 33, 14, 31, 9],
    [2, 19, 4, 21, 17, 34, 6],
    [3, 28, 12, 35, 0, 32, 15],
    [4, 32, 15, 19, 2, 25, 17],
    [5, 8, 23, 10, 16, 33, 1],
    [6, 25, 17, 34, 13, 36, 11],
    [7, 22, 18, 29, 12, 35, 3],
    [8, 36, 11, 30, 10, 5, 24],
    [9, 20, 14, 31, 18, 29, 7],
    [10, 30, 8, 23, 24, 16, 33],
    [11, 27, 13, 36, 8, 23, 10],
    [12, 29, 7, 28, 3, 26, 0],
    [13, 34, 6, 27, 11, 30, 8],
    [14, 33, 1, 20, 9, 22, 18],
    [15, 26, 0, 32, 4, 21, 2],
    [16, 10, 5, 24, 1, 20, 14],
    [17, 21, 2, 25, 6, 27, 13],
    [18, 31, 9, 22, 7, 28, 12],
    [19, 0, 32, 15, 21, 2, 25],
    [20, 16, 33, 1, 31, 9, 22],
    [21, 15, 19, 4, 25, 17, 34],
    [22, 14, 31, 9, 29, 7, 28],
    [23, 11, 30, 8, 5, 24, 16],
    [24, 23, 10, 5, 33, 1, 20],
    [25, 4, 21, 2, 34, 6, 27],
    [26, 12, 35, 3, 32, 15, 19],
    [27, 17, 34, 6, 36, 11, 30],
    [28, 18, 29, 7, 35, 3, 26],
    [29, 9, 22, 18, 28, 12, 35],
    [30, 13, 36, 11, 23, 10, 5],
    [31, 1, 20, 14, 22, 18, 29],
    [32, 3, 26, 0, 19, 4, 21],
    [33, 5, 24, 16, 20, 14, 31],
    [34, 2, 25, 17, 27, 13, 36],
    [35, 7, 28, 12, 26, 0, 32],
    [36, 6, 27, 13, 30, 8, 23]

]

V4 = [
    [0, 12, 35, 3, 26, 32, 15, 19, 4],
    [1, 5, 24, 16, 33, 20, 14, 31, 9],
    [2, 15, 19, 4, 21, 25, 17, 34, 6],
    [3, 7, 28, 12, 35, 26, 0, 32, 15],
    [4, 0, 32, 15, 19, 21, 2, 25, 17],
    [5, 30, 8, 23, 10, 24, 16, 33, 1],
    [6, 2, 25, 17, 34, 27, 13, 36, 11],
    [7, 9, 22, 18, 29, 28, 12, 35, 3],
    [8, 13, 36, 11, 30, 23, 10, 5, 24],
    [9, 1, 20, 14, 31, 22, 18, 29, 7],
    [10, 11, 30, 8, 23, 5, 24, 16, 33],
    [11, 6, 27, 13, 36, 30, 8, 23, 10],
    [12, 18, 29, 7, 28, 35, 3, 26, 0],
    [13, 17, 34, 6, 27, 36, 11, 30, 8],
    [14, 16, 33, 1, 20, 31, 9, 22, 18],
    [15, 3, 26, 0, 32, 19, 4, 21, 2],
    [16, 23, 10, 5, 24, 33, 1, 20, 14],
    [17, 4, 21, 2, 25, 34, 6, 27, 13],
    [18, 14, 31, 9, 22, 29, 7, 28, 12],
    [19, 26, 0, 32, 15, 4, 21, 2, 25],
    [20, 24, 16, 33, 1, 14, 31, 9, 22],
    [21, 32, 15, 19, 4, 2, 25, 17, 34],
    [22, 20, 14, 31, 9, 18, 29, 7, 28],
    [23, 36, 11, 30, 8, 10, 5, 24, 16],
    [24, 8, 23, 10, 5, 16, 33, 1, 20],
    [25, 19, 4, 21, 2, 17, 34, 6, 27],
    [26, 28, 12, 35, 3, 0, 32, 15, 19],
    [27, 25, 17, 34, 6, 13, 36, 11, 30],
    [28, 22, 18, 29, 7, 12, 35, 3, 26],
    [29, 31, 9, 22, 18, 7, 28, 12, 35],
    [30, 27, 13, 36, 11, 8, 23, 10, 5],
    [31, 33, 1, 20, 14, 9, 22, 18, 29],
    [32, 35, 3, 26, 0, 15, 19, 4, 21],
    [33, 10, 5, 24, 16, 1, 20, 14, 31],
    [34, 21, 2, 25, 17, 6, 27, 13, 36],
    [35, 29, 7, 28, 12, 3, 26, 0, 32],
    [36, 34, 6, 27, 13, 11, 30, 8, 23]

]

PCA = [
    [21, 2, 4, 15, 17, 19, 25, 32, 34],
    [11, 6, 8, 10, 13, 23, 27, 30, 36],
    [1, 5, 9, 14, 16, 20, 24, 31, 33],
    [28, 3, 7, 12, 18, 22, 26, 29, 35]
]

# Dictionnaire pour stocker les √©carts de chaque tableau
ecarts = {
    "SIXAIN": [0] * len(SIXAIN),
    "CARRE": [0] * len(CARRE),
    "V1": [0] * len(V1),
    "V2": [0] * len(V2),
    "TVR": [0] * len(TVR),
    "CVX": [0] * len(CVX),
    "V3": [0] * len(V3),
    "V4": [0] * len(V4),
    "PCA": [0] * len(PCA)  # Nouvelle entr√©e
}

# Listes pour stocker les num√©ros de chaque sous-tableau
sSIXAIN_list = []
sCARRE_list = []
sV1_list = []
sV2_list = []
sTVR_list = []
sCVX_list = []
sV3_list = []
sV4_list = []
s4PCA_list = []  # Nouvelle liste


# Fonction pour mettre √† jour les √©carts
def update_ecarts(number):
    for tableau_name, tableau in [("SIXAIN", SIXAIN), ("CARRE", CARRE), ("V1", V1), ("V2", V2),
                                  ("TVR", TVR), ("CVX", CVX), ("V3", V3), ("V4", V4), ("PCA", PCA)]:  # Ajout de PCA
        for i, ligne in enumerate(tableau):
            if number in ligne:
                ecarts[tableau_name][i] = 0  # R√©initialiser l'√©cart si le num√©ro est dans la ligne
            else:
                ecarts[tableau_name][i] += 1  # Incr√©menter l'√©cart sinon


# Fonction pour obtenir les 4 meilleures lignes d'un tableau
def get_top_4_lines(tableau_name):
    tableau = globals()[tableau_name]  # R√©cup√®re le tableau correspondant
    ecarts_tableau = ecarts[tableau_name]  # R√©cup√®re les √©carts associ√©s
    # Associer chaque ligne √† son √©cart
    lignes_avec_ecarts = list(zip(tableau, ecarts_tableau))
    # Trier par √©cart d√©croissant
    lignes_avec_ecarts.sort(key=lambda x: x[1], reverse=True)
    # Retourner les 4 premi√®res lignes
    top_4_lines = [(ligne, ecart) for ligne, ecart in lignes_avec_ecarts[:4]]
    return top_4_lines


# Configurer les colonnes interm√©diaires pour qu'elles occupent de l'espace
for col in range(12, 21):  # Colonnes 12 √† 20
    main_frame.grid_columnconfigure(col, minsize=100)  # minsize en pixels

# Cr√©er un cadre principal pour les sous-tableaux
main_sous_tableaux_frame = tk.Frame(sixtual_frame, borderwidth=4, relief="groove", bg="lightgray")
main_sous_tableaux_frame.grid(row=2, column=11, columnspan=39, padx=16, pady=10)

# D√©finir la liste des noms des sous-tableaux
sous_tableaux_names = ["sSIXAIN", "sCARRE", "sV1", "sV2", "sTVR", "sCVX", "sV3", "sV4", "s4PCA"]

# Cr√©ation des sous-tableaux dans le cadre principal
sous_tableaux_frames = {}

for i, name in enumerate(sous_tableaux_names):
    # D√©terminer la ligne et la colonne en fonction de l'index
    if i < 3:  # Premi√®re ligne (3 sous-tableaux)
        row, column = 0, i
    elif i < 6:  # Deuxi√®me ligne (3 sous-tableaux)
        row, column = 1, i - 3
    else:  # Troisi√®me ligne (2 sous-tableaux)
        row, column = 2, i - 6

    # Cr√©ation des cadres pour chaque sous-tableau
    frame = tk.Frame(main_sous_tableaux_frame, borderwidth=2, relief="groove")
    frame.grid(row=row, column=column, padx=5, pady=5)
    sous_tableaux_frames[name] = frame

    # Ajouter un label pour le nom du sous-tableau
    tk.Label(frame, text=name, font=default_font).pack()

    # Ajouter un canvas pour afficher les lignes
    canvas = tk.Canvas(frame, width=220, height=80)  # Ajustez la taille selon vos besoins
    canvas.pack()

    # Ajouter 4 boutons (SL1, SL2, SL3, SL4)
    for j in range(4):
        btn = tk.Button(frame, text=f"SL{'1234'[j]}", borderwidth=4, font=default_font,bg="lightblue",
                        command=lambda n=name, idx=j: jouer_ligne(n, idx))
        btn.pack(side="left", padx=2, pady=2)

# Positionnement personnalis√© des cadres
sous_tableaux_frames["sSIXAIN"].grid(row=0, column=13, padx=10, pady=10, rowspan=1, columnspan=1)
sous_tableaux_frames["sCARRE"].grid(row=0, column=14, padx=10, pady=10, rowspan=1, columnspan=1)
sous_tableaux_frames["sV1"].grid(row=0, column=12, padx=10, pady=10, rowspan=1, columnspan=1)
sous_tableaux_frames["sV2"].grid(row=1, column=13, padx=10, pady=10, rowspan=1, columnspan=1)
sous_tableaux_frames["sTVR"].grid(row=1, column=12, padx=10, pady=10, rowspan=1, columnspan=1)
sous_tableaux_frames["sCVX"].grid(row=2, column=13, padx=10, pady=10, rowspan=1, columnspan=1)
sous_tableaux_frames["sV3"].grid(row=2, column=12, padx=10, pady=10, rowspan=1, columnspan=1)
sous_tableaux_frames["sV4"].grid(row=1, column=14, padx=10, pady=10, rowspan=1, columnspan=1)
sous_tableaux_frames["s4PCA"].grid(row=2, column=14, padx=10, pady=10, rowspan=1, columnspan=1)


# Fonction pour jouer une ligne d'un sous-tableau
def jouer_ligne(tableau_name, ligne_index):
    # Modifier la fa√ßon d'extraire le nom du tableau
    if tableau_name.startswith("s4"):
        real_tableau_name = tableau_name[2:]  # Pour "s4PCA" -> "PCA"
    else:
        real_tableau_name = tableau_name[1:]  # Pour les autres -> "SIXAIN", "CARRE", etc.

    top_4_lines = get_top_4_lines(real_tableau_name)
    if ligne_index < len(top_4_lines):
        ligne = top_4_lines[ligne_index][0]
        # Jouer les num√©ros de la ligne
        for num in ligne:
            if num in coordinates:
                x, y = coordinates[num]
                pyautogui.click(x, y)
                time.sleep(0.1)


# Fonction pour mettre √† jour l'affichage des sous-tableaux
def update_sous_tableaux():
    for name in sous_tableaux_names:
        # Modifier la fa√ßon d'extraire le nom du tableau
        if name.startswith("s4"):
            tableau_name = name[2:]  # Pour "s4PCA" -> "PCA"
        else:
            tableau_name = name[1:]  # Pour les autres -> "SIXAIN", "CARRE", etc.

        top_4_lines = get_top_4_lines(tableau_name)
        frame = sous_tableaux_frames[name]
        canvas = frame.winfo_children()[1]  # R√©cup√©rer le canvas
        canvas.delete("all")  # Effacer le contenu pr√©c√©dent

        if top_4_lines:  # V√©rifier que les lignes existent
            for i, (ligne, ecart) in enumerate(top_4_lines):
                # Afficher chaque ligne avec son √©cart
                canvas.create_text(10, 10 + i * 15, text=" ".join(map(str, ligne)) + f" (Ec: {ecart})",
                                   anchor="w", font=("Helvetica", 11, "bold"), fill="black")
        else:
            canvas.create_text(10, 10, text="Aucune ligne", anchor="w", font=("Helvetica", 8, "bold"), fill="black")


# Fonction pour v√©rifier la fonctionnalit√© DBX
def check_dbx():
    global history, dbx_counter, ecart_max_prx

    if len(history) >= 1:
        last_number = history[-1]
        # V√©rifier les doublons uniquement dans la zone de comptage actuelle
        zone_de_comptage = history[-int(dbx_counter.get()):]
        if last_number in zone_de_comptage[:-1]:
            # Doublon d√©tect√©
            index_previous = len(zone_de_comptage) - 2 - zone_de_comptage[:-1][::-1].index(last_number)
            distance = len(zone_de_comptage) - 1 - index_previous
            if distance == 1:
                # Doublon imm√©diat
                dbx_counter.set("1")
            else:
                # Doublon √©loign√©
                dbx_counter.set(str(distance))
        else:
            # Pas de doublon, incr√©menter le compteur
            current_count = int(dbx_counter.get())
            dbx_counter.set(str(current_count + 1))

    # Met √† jour l'√©cart max APR√àS avoir modifi√© dbx_counter
    try:
        ecart_actuel = int(dbx_counter.get())
        if ecart_actuel > ecart_max_prx:
            ecart_max_prx = ecart_actuel
            ecpmx_counter.set(str(ecart_max_prx))
    except:
        pass

# Fonction pour jouer les num√©ros sans doublon
def play_pr():
    global history, dbx_counter
    # R√©cup√©rer la valeur actuelle du compteur REPET
    try:
        repetitions = int(repet_mollette.get())
    except ValueError:
        messagebox.showerror("Erreur", "La valeur de r√©p√©tition doit √™tre un nombre entier.")
        return

    # R√©cup√©rer la valeur actuelle du compteur DBX
    current_count = int(dbx_counter.get())

    # R√©cup√©rer les `current_count` derniers num√©ros sans doublon
    if len(history) > 0:
        last_numbers = history[-current_count:]
        # Jouer uniquement ces num√©ros, en r√©p√©tant chaque num√©ro selon la valeur de REPET
        play_numbers_with_repetition(last_numbers, repetitions)
    else:
        messagebox.showwarning("Avertissement", "Aucun num√©ro dans l'historique.")

def play_numbers_with_repetition(numbers, repetitions):
    # R√©cup√©rer la vitesse de clic
    try:
        click_speed = int(speed_entry.get())
    except ValueError:
        messagebox.showerror("Erreur", "La vitesse de clic doit √™tre un nombre entier.")
        return

    # Cliquer sur chaque num√©ro de la liste, r√©p√©t√© selon la valeur de REPET
    for num in numbers:
        if num in coordinates:
            x, y = coordinates[num]
            if x > 0 and y > 0:  # V√©rifier que les coordonn√©es sont valides
                for _ in range(repetitions):  # R√©p√©ter le clic selon la valeur de REPET
                    pyautogui.click(x, y)  # Cliquer sur les coordonn√©es (X, Y)
                    time.sleep(click_speed / 1000)  # D√©lai entre les clics
            else:
                messagebox.showwarning("Avertissement", f"Coordonn√©es manquantes pour le num√©ro {num}.")
        else:
            messagebox.showwarning("Avertissement", f"Coordonn√©es manquantes pour le num√©ro {num}.")



prx_frame = tk.Frame(dyza_frame, borderwidth=2, relief="groove", bg="lightBlue", width=200, height=40)
prx_frame.grid(row=1, column=0, padx=5, pady=5, sticky="nsew")
prx_frame.grid_propagate(False)

prx_button = tk.Button(prx_frame, text="PRX", font=default_font,bg="DarkSalmon", fg="Black", borderwidth=8, command=play_pr, width=5)
prx_button.grid(row=0, column=0, padx=2, pady=5)

dbx_counter = tk.StringVar()
dbx_counter.set("0")
dbx_counter_label = tk.Label(prx_frame, textvariable=dbx_counter, font=default_font, width=4, bg="white")
dbx_counter_label.grid(row=0, column=1, padx=2, pady=5)

ecpmx_label = tk.Label(prx_frame, text="Ecpmx:", font=default_font, bg="lightgray")
ecpmx_label.grid(row=0, column=2, padx=(10, 2), pady=5)

ecpmx_counter = tk.StringVar()
ecpmx_counter.set("0")
ecpmx_counter_label = tk.Label(prx_frame, textvariable=ecpmx_counter, font=default_font, width=4, bg="white")
ecpmx_counter_label.grid(row=0, column=3, padx=2, pady=5)



# Fonction pour jouer une liste de num√©ros
def play_numbers(numbers):
    global history  # AJOUTER cette ligne

    # R√©cup√©rer la vitesse de clic
    try:
        click_speed = int(speed_entry.get())
    except ValueError:
        messagebox.showerror("Erreur", "La vitesse de clic doit √™tre un nombre entier.")
        return

    # R√©cup√©rer le nombre de r√©p√©titions
    try:
        repetitions = int(repet_mollette.get())
    except ValueError:
        messagebox.showerror("Erreur", "La valeur de r√©p√©tition doit √™tre un nombre entier.")
        return

    # Cliquer sur chaque num√©ro de la liste, r√©p√©t√© selon la valeur de REPET
    for num in numbers:
        if num in coordinates:
            x, y = coordinates[num]
            if x > 0 and y > 0:  # V√©rifier que les coordonn√©es sont valides
                for _ in range(repetitions):  # R√©p√©ter le clic selon la valeur de REPET
                    pyautogui.click(x, y)  # Cliquer sur les coordonn√©es (X, Y)
                    time.sleep(click_speed / 1000)  # D√©lai entre les clics

                # AJOUTER LE NUM√âRO √Ä L'HISTORIQUE APR√àS AVOIR CLIQU√â
                history.append(num)
                update_history_display()  # Mettre √† jour l'affichage

            else:
                messagebox.showwarning("Avertissement", f"Coordonn√©es manquantes pour le num√©ro {num}.")
        else:
            messagebox.showwarning("Avertissement", f"Coordonn√©es manquantes pour le num√©ro {num}.")

    # Mettre √† jour les compteurs apr√®s avoir jou√© tous les num√©ros
    update_counters()  # Si tu as cette fonction


# ... (le reste de ton code reste inchang√© jusqu'√† la fin)

# Fonction pour limiter le nombre de spins pris en compte
def reduc_spins():
    try:
        reduc_value = int(reduc_entry.get())
        if reduc_value <= len(history):
            global limited_history
            limited_history = history[-reduc_value:]
            update_all_interface_elements()  # Mettre √† jour tous les √©l√©ments de l'interface
        else:
            messagebox.showwarning("Avertissement", "Le nombre saisi est sup√©rieur au nombre total de spins.")
    except ValueError:
        messagebox.showerror("Erreur", "Veuillez entrer un nombre valide.")


# Fonction pour r√©initialiser l'action du bouton REDUC
def reset_reduc():
    global limited_history
    limited_history = None  # R√©initialiser l'historique limit√©
    update_all_interface_elements()  # Mettre √† jour tous les √©l√©ments de l'interface


# Fonction pour mettre √† jour tous les √©l√©ments de l'interface
def update_all_interface_elements():
    if limited_history is not None:
        current_history = limited_history
    else:
        current_history = history

    # R√©initialiser tous les compteurs et listes
    red_numbers_list.clear()
    black_numbers_list.clear()
    pair_numbers_list.clear()
    impair_numbers_list.clear()
    manque_numbers_list.clear()
    passe_numbers_list.clear()
    vo_numbers_list.clear()
    tie_numbers_list.clear()
    oph_numbers_list.clear()

    # R√©initialiser les s√©ries en m√©moire
    for serie_name in SERIES.keys():
        ns_values[serie_name] = 0
        ec_values[serie_name] = 0
        ecmx_values[serie_name] = 0

    # R√©initialiser le d√©versoir
    for i in range(11):
        stk_values[i] = set(range(37)) if i == 0 else set()
        stk_counters[i].set(str(len(stk_values[i])))

    # R√©initialiser les sous-tableaux
    sSIXAIN_list.clear()
    sCARRE_list.clear()
    sV1_list.clear()
    sV2_list.clear()
    sTVR_list.clear()
    sCVX_list.clear()
    sV3_list.clear()
    sV4_list.clear()

    # R√©initialiser les √©carts des sous-tableaux
    for tableau_name in ecarts.keys():
        ecarts[tableau_name] = [0] * len(globals()[tableau_name])

    # Mettre √† jour les compteurs et listes avec l'historique actuel
    for number in current_history:
        update_counters(number)
        update_all_columns(number)
        move_number(number)
        update_ecarts(number)

    # Mettre √† jour l'affichage
    update_labels()
    update_history()  # Mettre √† jour l'historique avec les spins limit√©s ou complets
    update_sous_tableaux()
    check_alerts()
    update_arrows()

    # Mettre √† jour la doublette RDBL et ses amis (sans toucher √† la fonction existante)
    if current_history:
        update_last_doublette(current_history[-1])  # Utiliser le dernier num√©ro de l'historique actuel








# =====================================================
# SYST√àME DE D√âTECTION - VERSION CORRIG√âE ET COMPL√àTE
# =====================================================

# Tableau de d√©tections original
detections_NUMtable = {
        0: [0, 5, 15, 25, 35, 26, 10, 30, 32, 1, 2, 8, 11, 17, 20, 29],
        1: [1, 2, 3, 4, 11, 20, 33, 19, 32, 11, 13, 15, 21, 31, 36],
        2: [0, 1, 3, 5, 2, 4, 9, 11, 29, 21, 25, 12, 22],
        3: [0, 2, 6, 3, 13, 23, 33, 6, 12, 21, 26, 27, 35, 30, 23],
        4: [0, 1, 5, 7, 2, 4, 14, 24, 31, 34, 19, 21, 20],
        5: [0, 2, 4, 6, 8, 5, 15, 25, 35, 10, 24, 14, 29, 23, 32],
        6: [1, 5, 6, 16, 26, 36, 17, 27, 34, 9, 15, 3, 34],
        7: [1, 8, 7, 17, 26, 27, 28, 29, 4, 10],
        8: [5, 7, 9, 11, 8, 18, 28, 17, 30, 32, 35],
        9: [22, 11, 6, 8, 12, 2, 4, 30,  19, 29, 31, 27, 18, 36, 9],
        10: [28, 0, 20, 30, 7, 11, 13, 29, 5, 23, 10, 3],
        11: [29, 8, 10, 3, 6, 12, 14, 21, 1, 31, 2, 9, 20, 30, 36, 22, 33, 4, 11],
        12: [21, 11, 15, 2, 4, 36, 22, 32, 9, 12, 28, 35],
        13: [31, 0, 3, 10, 16, 14, 9, 23, 33, 26, 27, 36, 28, 24, 12, 13],
        14: [18, 4, 24, 34, 5, 20, 31, 14, 9],
        15: [1, 6, 8, 20, 33, 11, 13, 15, 17, 5, 25, 35, 19, 32, 36],
        16: [19, 16, 7, 13, 17, 19, 6, 26, 36, 24, 33],
        17: [8, 34, 31, 14, 16, 18, 35, 6, 30, 22, 24, 25, 7, 17, 27, 20],
        18: [14, 8, 28, 15, 17, 21, 36, 22, 29, 5, 18, 2, 9],
        19: [16, 19, 20, 22, 9, 29, 4, 15, 10, 36],
        20: [1, 0, 10, 30, 33, 14, 17, 19, 21, 12, 23, 20],
        21: [12, 13, 36, 1, 11, 31, 2, 4, 18, 20, 24, 21],
        22: [22, 17, 14, 6, 12, 32, 2, 19, 23,  9, 18, 11, 33, 25, 29],
        23: [32, 3, 13, 16, 33, 5, 8, 10, 22, 24, 20, 26, 23],
        24: [17, 4, 18, 14, 34, 5, 16, 21, 23, 27, 28, 24],
        25: [27, 5, 15, 35, 29, 2, 17, 20, 10, 0, 22, 26, 28,  25],
        26: [29, 6, 16, 20, 27, 23, 25, 36, 0, 3, 13, 26],
        27: [25, 7, 17, 6, 22, 9, 13, 24, 26, 30, 27],
        28: [24, 8, 23, 18, 7, 12, 25, 31, 28, 29],
        29: [26, 9, 28, 30, 32, 19, 2, 11, 10, 7, 18, 5, 29, 25, 22, 20],
        30: [9, 0, 5, 15, 25,27, 29, 33,  35, 17, 10, 20, 22, 31, 8, 11, 30, 36],
        31: [13, 1, 27, 36, 11, 12, 21, 31, 28, 32, 34, 9, 14],
        32: [23, 2, 3, 12, 22, 0, 15, 8, 10, 32, 29, 31, 33, 35],
        33: [11, 3, 13, 23, 30, 32, 36, 1, 16, 22, 33],
        34: [17, 25, 3, 4, 14, 24, 6, 34, 31, 35],
        35: [0, 10, 20, 30, 8, 5, 15, 32, 34, 36, 25, 3, 12, 17, 11, 35],
        36: [1, 18, 22, 29, 20, 33, 32, 19, 6, 16, 26, 27, 15, 30, 35, 36, 12, 11, 13]

}

# Variable globale pour l'√©cart
det_ecart = 0
det_ecart_counter = tk.StringVar(value="0")


# Fonction COMPL√àTEMENT REVISIT√âE avec persistance garantie
def update_detected_numbers(last_number):
    global det_ecart

    # Initialisation de la m√©moire interne
    if not hasattr(update_detected_numbers, '_memory'):
        update_detected_numbers._memory = {
            'previous_numbers': [],
            'last_processed': None
        }

    # Anti-rebond : √©vite de traiter le m√™me num√©ro deux fois
    if update_detected_numbers._memory['last_processed'] == last_number:
        return
    update_detected_numbers._memory['last_processed'] = last_number

    # R√©cup√®re les num√©ros d√©tect√©s via detections_NUMtable
    current_detected = detections_NUMtable.get(last_number, [])
    # Filtre les non-nombres (ex: cha√Ænes comme "INV")
    current_filtered = [n for n in current_detected if isinstance(n, int)]

    # Logique d'√©cart
    if update_detected_numbers._memory['previous_numbers']:
        if last_number not in update_detected_numbers._memory['previous_numbers']:
            det_ecart += 1
        else:
            det_ecart = 0
    else:
        det_ecart = 0

    # Mise √† jour de l'interface
    detected_numbers_label.config(text=" ".join(map(str, current_filtered)))
    det_ecart_counter.set(str(det_ecart))

    # Sauvegarde pour le prochain appel
    update_detected_numbers._memory['previous_numbers'] = current_filtered.copy()

    # Force l'actualisation de l'interface
    root.update_idletasks()


# =====================================
# 1er AJOUT : ALERTE PRX (SIMPLIFI√â)
# =====================================

def check_prx_alert():
    global prx_alert_active

    # R√©cup√©rer la valeur de PRX (ici, on suppose que PRX est li√© √† dbx_counter)
    prx_value = int(dbx_counter.get())

    # V√©rifier si PRX >= 15
    if prx_value >= 15 and not prx_alert_active:
        # Activer l'alerte
        prx_alert_active = True
        # Changer la couleur du cadre PRX
        prx_frame.config(bg="red",borderwidth=7)
        for widget in prx_frame.winfo_children():
            widget.config(bg="red", fg="white")

    # Si PRX redevient <= 15, d√©sactiver l'alerte
    elif prx_value <= 15 and prx_alert_active:
        prx_alert_active = False
        # R√©tablir la couleur d'origine
        prx_frame.config(bg="lightgray")
        for widget in prx_frame.winfo_children():
            widget.config(bg="SystemButtonFace", fg="black")

    # V√©rifier √† nouveau apr√®s 1 seconde (sans cr√©er de boucle infinie)
    if root.winfo_exists():  # S'assurer que la fen√™tre existe toujours
        root.after(1000, check_prx_alert)


# Variable pour suivre l'√©tat de l'alerte PRX
prx_alert_active = False

# D√©marrer la v√©rification de l'alerte PRX
check_prx_alert()

# ===================================================
# 2√®me AJOUT : DECLENCHEUR COMPTEUR MEM (CORRIG√â)
# ===================================================

# Cr√©ation du cadre MEM
mem_frame = tk.Frame(main_frame, borderwidth=2, relief="groove", bg="lightgray")
mem_frame.grid(row=3, column=0, padx=5, pady=5,sticky="w", in_=dyza_frame)



# Libell√© "MEM"
tk.Label(mem_frame, text="MEM", font=default_font).grid(row=0, column=0, padx=5, pady=5)

# Compteur MEM
mem_counter = tk.StringVar(value="0")
mem_counter_label = tk.Label(mem_frame, textvariable=mem_counter, font=default_font, width=4, bg="white")
mem_counter_label.grid(row=0, column=1, padx=5, pady=5)

# Bouton "RM" pour r√©initialiser le compteur
tk.Button(mem_frame, text="RM", font=default_font, command=lambda: [mem_counter.set("0"), set_mem_index(0)]).grid(row=0,
                                                                                                                  column=2,
                                                                                                                  padx=5,
                                                                                                                  pady=5)

# S√©quence MEM
mem_sequence = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584]
mem_index = 0


# Fonction pour mettre √† jour le compteur MEM
def update_mem_counter():
    global mem_index

    # V√©rifier si l'√©cart (Ec) d'une des 26 rubriques est >= 15
    ec_condition_met = any(ec_values[serie_name] >= 15 for serie_name in SERIES.keys())

    if ec_condition_met:
        # Afficher la valeur suivante de la s√©quence MEM
        if mem_index < len(mem_sequence):
            mem_counter.set(str(mem_sequence[mem_index]))
            mem_index += 1
        else:
            mem_index = 0  # Revenir au d√©but de la s√©quence

        # Coloration de la case MEM en jaune
        mem_counter_label.config(bg="yellow", fg="black")
    else:
        # R√©initialiser le compteur si la condition n'est plus remplie
        mem_counter.set("0")
        mem_index = 0

        # R√©tablir la couleur d'origine de la case MEM
        mem_counter_label.config(bg="white", fg="black")


# Int√©gration dans la fonction on_number_click

# =====================
# AJOUT : MISE RDBL
# =====================

# Tableau des valeurs pour Mise et Tr
mise_tr_table = [
    (1, "1√©"), (1, "2√®"), (1, "3√®"), (1, "4√®"), (1, "5√®"), (1, "6√®"), (1, "7√®"), (1, "8√®"), (1, "9√®"), (1, "10√®"),
    (1, "11√®"), (1, "12√®"), (1, "13√®"), (1, "14√®"), (1, "15√®"), (1, "16√®"), (1, "17√®"), (1, "18√®"), (1, "19√®"),
    (1, "20√®"),
    (1, "21√®"), (1, "22√®"), (1, "23√®"), (1, "24√®"), (1, "25√®"), (1, "26√®"), (1, "27√®"), (1, "28√®"), (1, "29√®"),
    (1, "30√®"),
    (1, "31√®"), (1, "32√®"), (1, "33√®"), (1, "34√®"), (1, "35√®"), (2, "36√®"), (2, "37√®"), (2, "38√®"), (2, "39√®"),
    (2, "40√®"),
    (2, "41√®"), (2, "42√®"), (2, "43√®"), (2, "44√®"), (2, "45√®"), (2, "46√®"), (2, "47√®"), (2, "48√®"), (2, "49√®"),
    (2, "50√®"),
    (2, "51√®"), (2, "52√®"), (2, "53√®"), (3, "54√®"), (3, "55√®"), (3, "56√®"), (3, "57√®"), (3, "58√®"), (3, "59√®"),
    (3, "60√®"),
    (3, "61√®"), (3, "62√®"), (3, "63√®"), (3, "64√®"), (3, "65√®"), (4, "66√®"), (4, "67√®"), (4, "68√®"), (4, "69√®"),
    (4, "70√®"),
    (4, "71√®"), (4, "72√®"), (4, "73√®"), (4, "74√®"), (5, "75√®"), (5, "76√®"), (5, "77√®"), (5, "78√®"), (5, "79√®"),
    (5, "80√®"),
    (5, "81√®"), (6, "82√®"), (6, "83√®"), (6, "84√®"), (6, "85√®"), (6, "86√®"), (6, "87√®"), (7, "88√®"), (7, "89√®"),
    (7, "90√®"),
    (7, "91√®"), (7, "92√®"), (8, "93√®"), (8, "94√®"), (8, "95√®"), (8, "96√®"), (9, "97√®"), (9, "98√®"), (9, "99√®"),
    (9, "100√®"),
    (10, "101√®"), (10, "102√®"), (10, "103√®"), (11, "104√®"), (11, "105√®"), (11, "106√®"), (12, "107√®"), (12, "108√®"),
    (12, "109√®"),
    (13, "110√®"), (13, "111√®"), (14, "112√®"), (14, "113√®"), (15, "114√®"), (15, "115√®")
]

# Variables pour les compteurs Mise et Tr (initialis√©es √† vide)
mise_counter = tk.StringVar(value="")  # Vide au d√©marrage
tr_counter = tk.StringVar(value="")  # Vide au d√©marrage

# Index pour suivre la progression dans le tableau
mise_tr_index = 0

# Cadre pour Mise et Tr







# Fonction pour mettre √† jour les compteurs Mise et Tr
def update_mise_tr_counters():
    global mise_tr_index

    # V√©rifier si une doublette a √©t√© d√©tect√©e
    if last_doublette.get() != "XX":
        # Si c'est la premi√®re d√©tection de doublette, initialiser les compteurs
        if mise_counter.get() == "" and tr_counter.get() == "":
            mise_counter.set(str(mise_tr_table[0][0]))  # Premi√®re valeur : 1
            tr_counter.set(mise_tr_table[0][1])  # Premi√®re valeur : 1√®
            mise_tr_index = 1  # Passer √† la deuxi√®me ligne pour le prochain spin
        else:
            # Mettre √† jour les compteurs avec les valeurs du tableau
            if mise_tr_index < len(mise_tr_table):
                mise_counter.set(str(mise_tr_table[mise_tr_index][0]))
                tr_counter.set(mise_tr_table[mise_tr_index][1])
                mise_tr_index += 1
            else:
                # Revenir au d√©but du tableau si on d√©passe la 115√®me valeur
                mise_tr_index = 0
                mise_counter.set(str(mise_tr_table[mise_tr_index][0]))
                tr_counter.set(mise_tr_table[mise_tr_index][1])


# Fonction pour r√©initialiser les compteurs Mise et Tr
def reset_mise_tr_counters():
    global mise_tr_index
    mise_tr_index = 0
    mise_counter.set("")  # R√©initialiser √† vide
    tr_counter.set("")  # R√©initialiser √† vide


# ========================
# AJOUT : CARRE SYSTEME
# ========================

# Tableau CARRE (int√©gr√© directement dans le code)
CARRE_TABLE = {
    0: [0, 1, 2, 3],
    1: [1, 2, 4, 5],
    2: [1, 2, 4, 5],
    3: [2, 3, 5, 6],
    4: [1, 2, 4, 5],
    5: [1, 2, 4, 5],
    6: [2, 3, 5, 6],
    7: [7, 8, 10, 11],
    8: [8, 9, 11, 12],
    9: [8, 9, 11, 12],
    10: [10, 11, 13, 14],
    11: [11, 12, 14, 15],
    12: [11, 12, 14, 15],
    13: [13, 14, 16, 17],
    14: [14, 15, 17, 18],
    15: [14, 15, 17, 18],
    16: [16, 17, 19, 20],
    17: [17, 18, 20, 21],
    18: [17, 18, 20, 21],
    19: [19, 20, 22, 23],
    20: [20, 21, 23, 24],
    21: [20, 21, 23, 24],
    22: [22, 23, 25, 26],
    23: [23, 24, 26, 27],
    24: [23, 24, 26, 27],
    25: [25, 26, 28, 29],
    26: [26, 27, 29, 30],
    27: [26, 27, 29, 30],
    28: [28, 29, 31, 32],
    29: [29, 30, 32, 33],
    30: [29, 30, 32, 33],
    31: [31, 32, 34, 35],
    32: [32, 33, 35, 36],
    33: [32, 36, 35, 36],
    34: [31, 32, 34, 35],
    35: [32, 33, 35, 36],
    36: [32, 33, 35, 36]
}

# Base de donn√©es des 37 num√©ros de la roulette
BASE_NUMBERS = list(range(37))  # [0, 1, 2, ..., 36]


# Fonction pour obtenir les num√©ros associ√©s √† un num√©ro donn√© selon le tableau CARRE
def get_associated_numbers(number):
    return CARRE_TABLE.get(number, [])


# Fonction pour jouer les num√©ros restants apr√®s suppression des num√©ros associ√©s
def play_remaining_numbers(last_numbers):
    # R√©cup√©rer les num√©ros associ√©s aux derniers num√©ros sortis
    associated_numbers = set()
    for num in last_numbers:
        associated_numbers.update(get_associated_numbers(num))

    # Calculer les num√©ros restants
    remaining_numbers = [num for num in BASE_NUMBERS if num not in associated_numbers]

    # Jouer les num√©ros restants
    play_numbers(remaining_numbers)


# Cadre pour les boutons TCA
tca_frame = tk.Frame(main_frame, borderwidth=2, relief="groove", bg="lightgray")

# Boutons TCA1 √† TCA5
tca_buttons = []
for i in range(5):
    btn = tk.Button(tca_frame, text=f"TCA{i + 1}", font=default_font,
                    command=lambda idx=i: play_remaining_numbers(history[-(idx + 1):]))
    btn.grid(row=0, column=i, padx=5, pady=5)
    tca_buttons.append(btn)


# =================
# FIN DE L'AJOUT
# =================

# =========================================
# FONCTION POUR JOUER LES NUMEROS ASSOCIES
# =========================================

# Fonction pour jouer les num√©ros associ√©s
def play_associated_numbers(last_numbers):
    # R√©cup√©rer les num√©ros associ√©s aux derniers num√©ros sortis
    associated_numbers = set()
    for num in last_numbers:
        associated_numbers.update(get_associated_numbers(num))
    # Jouer les num√©ros associ√©s
    play_numbers(list(associated_numbers))


# Cadre pour les boutons ASK
ask_frame = tk.Frame(main_frame, borderwidth=2, relief="groove", bg="lightgray")

# Boutons ASK1 √† ASK5
for i in range(5):
    btn = tk.Button(ask_frame, text=f"ASK{i + 1}", font=default_font,
                    command=lambda idx=i: play_associated_numbers(history[-(idx + 1):]))
    btn.grid(row=0, column=i, padx=5, pady=5)

# ====================================================================
# AJOUT : SYSTEME STRATEGIE 8 VOIES (STR 8V) - VERSION FINALE CORRIGEE
# ====================================================================
# D√©finition des strat√©gies 8 voies
STRATEGIES_8V = {
    "RPM": [12, 14, 16, 18],
    "RIM": [1, 3, 5, 7, 9],
    "RPP": [30, 32, 34, 36],
    "RIP": [19, 21, 23, 25, 27],
    "NPM": [2, 4, 6, 8, 10],
    "NIM": [11, 13, 15, 17],
    "NPP": [20, 22, 24, 26, 28],
    "NIP": [29, 31, 33, 35]
}

# Variables pour le syst√®me STR 8V
str8v_counters = {name: 0 for name in STRATEGIES_8V.keys()}
str8v_active_series = []  # Pour suivre les s√©ries actives
str8v_display_numbers = []  # Num√©ros actuellement affich√©s
str8v_tour_count = 0  # Compteur de tours depuis l'affichage
str8v_active_frame = None  # Cadre d'affichage

def update_str8v_counters(number):
    global str8v_tour_count, str8v_display_numbers, str8v_active_series
    # V√©rifier d'abord si le num√©ro fait partie des num√©ros affich√©s
    if number in str8v_display_numbers:
        reset_str8v_display()
        return
    # Incr√©menter le compteur de tours si des num√©ros sont affich√©s
    if str8v_display_numbers:
        str8v_tour_count += 1
        # V√©rifier si on a atteint 15 tours
        if str8v_tour_count >= 15:
            reset_str8v_display()
            return
    # V√©rifier si le num√©ro appartient √† une strat√©gie
    for name, numbers in STRATEGIES_8V.items():
        if number in numbers:
            str8v_counters[name] += 1
            # Si compteur atteint 2 et s√©rie pas d√©j√† affich√©e
            if str8v_counters[name] >= 2 and name not in str8v_active_series:
                # V√©rifier qu'on ne d√©passe pas 3 s√©ries ou 15 num√©ros
                if len(str8v_active_series) < 3 and len(str8v_display_numbers) + len(numbers) <= 15:
                    str8v_active_series.append(name)
                    # Ajouter les num√©ros sans doublons
                    for num in numbers:
                        if num not in str8v_display_numbers:
                            str8v_display_numbers.append(num)
                    refresh_str8v_display()
                    str8v_tour_count = 0  # R√©initialiser le compteur de tours

def refresh_str8v_display():
    # Nettoyer le cadre
    for widget in str8v_active_frame.winfo_children():
        widget.destroy()
    # Afficher les num√©ros actuels VERTICALEMENT
    for num in str8v_display_numbers:
        lbl = tk.Label(str8v_active_frame, text=str(num), bg="white", fg="black",
                       font=default_font, width=3, relief="ridge")
        lbl.pack(side="top", padx=2, pady=1)

def reset_str8v_display():
    global str8v_display_numbers, str8v_active_series, str8v_tour_count
    # R√©initialiser toutes les variables
    for widget in str8v_active_frame.winfo_children():
        widget.destroy()
    str8v_display_numbers = []
    str8v_active_series = []
    str8v_tour_count = 0
    # R√©initialiser les compteurs NS
    for name in str8v_counters.keys():
        str8v_counters[name] = 0

def check_str8v_input(event):
    if event.keysym.isdigit():
        num = int(event.keysym)
        if num in str8v_display_numbers:
            reset_str8v_display()

# Nouvelle fonction pour jouer les num√©ros STR 8V avec REPET
def play_str8v_numbers_with_repet():
    if not str8v_display_numbers:
        messagebox.showwarning("Avertissement", "Aucun num√©ro √† jouer pour STR 8V.")
        return
    # R√©cup√©rer la valeur de REPET
    try:
        repetitions = int(repet_mollette.get())
    except ValueError:
        messagebox.showerror("Erreur", "La valeur de r√©p√©tition doit √™tre un nombre entier.")
        return
    # R√©cup√©rer la vitesse de clic
    try:
        click_speed = int(speed_entry.get())
    except ValueError:
        messagebox.showerror("Erreur", "La vitesse de clic doit √™tre un nombre entier.")
        return
    # Jouer chaque num√©ro avec r√©p√©tition
    for num in str8v_display_numbers:
        if num in coordinates:
            x, y = coordinates[num]
            if x > 0 and y > 0:
                for _ in range(repetitions):
                    pyautogui.click(x, y)
                    time.sleep(click_speed / 1000)
            else:
                messagebox.showwarning("Avertissement", f"Coordonn√©es manquantes pour le num√©ro {num}.")
        else:
            messagebox.showwarning("Avertissement", f"Coordonn√©es manquantes pour le num√©ro {num}.")

def setup_str8v_interface():
    global str8v_active_frame
    # 1. Cr√©er le cadre principal "HUIT VOIES" si ce n'est pas d√©j√† fait
    global huit_voies_frame
    if 'huit_voies_frame' not in globals() or not huit_voies_frame.winfo_exists():
        huit_voies_frame = tk.Frame(main_group_frame, borderwidth=2, relief="groove", bg='lightblue')
        huit_voies_frame.grid(row=0, column=6, padx=5, pady=5, sticky="n")
    # 2. Bouton STR 8V (modifi√© pour utiliser la nouvelle fonction)
    str8v_btn = tk.Button(huit_voies_frame, text="STR 8V", borderwidth=8, font=default_font,
                          command=play_str8v_numbers_with_repet, bg="orange")
    str8v_btn.pack(side="top", padx=0, pady=0)
    # 3. Cadre d'affichage des num√©ros
    str8v_active_frame = tk.Frame(huit_voies_frame, bg="Salmon")
    str8v_active_frame.pack(side="top", padx=0, pady=0)
    # Lier les entr√©es clavier
    root.bind("<Key>", check_str8v_input)

# Initialisation
setup_str8v_interface()


# [Le reste du code principal reste inchang√©...]

# Ajoutez ceci √† la fin de votre code, juste avant root.mainloop()
# Cadre pour les boutons D2D3, C2C3, C1C2, C1C3
d2d3_frame = tk.Frame(main_frame, borderwidth=2, relief="groove", bg="lightgray")

# Boutons D2D3, C2C3, C1C2, C1C3
tk.Button(d2d3_frame, text="D2D3", font=default_font, command=lambda: jouer_category(NR_SERIES["NR1"], "NR1")).grid(
    row=0, column=0, padx=5, pady=5)
tk.Button(d2d3_frame, text="C2C3", font=default_font, command=lambda: jouer_category(NR_SERIES["NR4"], "NR4")).grid(
    row=0, column=1, padx=5, pady=5)
tk.Button(d2d3_frame, text="C1C2", font=default_font, command=lambda: jouer_category(NR_SERIES["NR2"], "NR2")).grid(
    row=0, column=2, padx=5, pady=5)
tk.Button(d2d3_frame, text="C1C3", font=default_font, command=lambda: jouer_category(NR_SERIES["NR3"], "NR3")).grid(
    row=0, column=3, padx=5, pady=5)



# ==============================================
# AJOUT DLO (DOUBLON) - VERSION FINALE ET STABLE
# ==============================================

# Donn√©es DLO fournies
DLO_DATA = {
    0: [14, 20, 1, 4, 7, 28, 35, 34, 24, 5, 21, 22, 0, 3, 32],
    1: [0, 30, 36, 4, 33, 28, 24, 17, 22, 18, 12, 23, 29, 8, 27],
    2: [32, 5, 35, 7, 16, 19, 4, 11, 28, 25, 10, 30, 6, 31, 3],
    3: [10, 21, 33, 17, 27, 11, 35, 7, 24, 19, 36, 28, 23, 22, 34],
    4: [34, 1, 35, 16, 17, 36, 30, 15, 10, 7, 32, 27, 9, 8, 6],
    5: [8, 30, 26, 4, 15, 36, 20, 25, 16, 18, 35, 11, 32, 19, 7],
    6: [17, 21, 26, 10, 15, 24, 11, 20, 14, 16, 4, 27, 8, 3, 33],
    7: [33, 21, 1, 12, 26, 32, 4, 29, 22, 7, 17, 11, 28, 27, 2],
    8: [3, 23, 30, 17, 31, 35, 11, 28, 9, 7, 13, 36, 34, 32, 26],
    9: [29, 22, 24, 10, 1, 21, 33, 26, 3, 17, 15, 19, 32, 13, 30],
    10: [27, 13, 21, 34, 33, 35, 12, 6, 8, 19, 24, 4, 23, 18, 25],
    11: [6, 7, 1, 35, 9, 2, 16, 24, 29, 14, 22, 32, 20, 27, 28],
    12: [17, 32, 29, 26, 2, 33, 9, 13, 8, 4, 25, 1, 3, 21, 12],
    13: [3, 31, 6, 28, 8, 13, 1, 7, 9, 35, 20, 27, 34, 17, 22],
    14: [14, 35, 17, 33, 6, 26, 9, 27, 34, 32, 22, 0, 12, 11, 36],
    15: [36, 10, 17, 9, 6, 35, 19, 26, 33, 27, 21, 31, 14, 30, 16],
    16: [17, 35, 22, 36, 1, 30, 28, 23, 34, 25, 16, 4, 3, 2, 12],
    17: [15, 23, 17, 13, 29, 8, 33, 30, 11, 31, 27, 3, 16, 21, 35],
    18: [15, 9, 14, 17, 10, 33, 20, 36, 27, 2, 21, 34, 35, 31, 13],
    19: [19, 8, 20, 31, 4, 15, 1, 33, 5, 11, 30, 35, 10, 21, 34],
    20: [6, 14, 5, 25, 12, 24, 1, 16, 27, 23, 20, 31, 0, 22, 11],
    21: [22, 4, 35, 11, 19, 16, 21, 12, 14, 5, 36, 34, 33, 9, 0],
    22: [28, 14, 11, 2, 35, 21, 3, 7, 5, 22, 15, 8, 29, 24, 13],
    23: [13, 3, 5, 30, 21, 7, 17, 0, 23, 20, 8, 29, 36, 25, 6],
    24: [19, 28, 32, 18, 31, 9, 36, 33, 2, 7, 34, 24, 10, 5, 14],
    25: [9, 19, 2, 0, 10, 27, 8, 28, 30, 34, 33, 6, 32, 7, 36],
    26: [34, 36, 25, 17, 29, 22, 19, 20, 6, 14, 13, 5, 21, 2, 30],
    27: [29, 9, 3, 32, 34, 2, 1, 35, 31, 28, 19, 33, 5, 36, 12],
    28: [8, 15, 4, 29, 7, 35, 10, 32, 6, 0, 20, 36, 23, 9, 2],
    29: [33, 28, 12, 29, 18, 35, 11, 8, 0, 6, 10, 22, 2, 3, 31],
    30: [10, 34, 25, 28, 3, 20, 14, 8, 2, 30, 33, 18, 24, 15, 9],
    31: [35, 8, 25, 5, 0, 20, 27, 31, 1, 7, 26, 23, 10, 9, 36],
    32: [18, 4, 33, 2, 3, 14, 15, 24, 36, 23, 10, 19, 20, 29, 8],
    33: [3, 34, 13, 36, 28, 5, 31, 30, 4, 22, 6, 1, 29, 20, 17],
    34: [20, 14, 12, 25, 24, 26, 7, 28, 18, 10, 30, 27, 31, 17, 8],
    35: [11, 36, 26, 6, 24, 34, 29, 32, 15, 13, 20, 12, 7, 31, 5],
    36: [4, 23, 1, 5, 26, 16, 34, 32, 12, 28, 25, 8, 27, 22, 10]
}


# Donn√©es DLO1 (doublon s√©par√© par 1 num√©ro)
DLO1_DATA = {
    0: [9, 17, 25, 15, 33, 29, 13, 21, 3, 10, 0, 26, 6, 19, 30],
    1: [19, 12, 14, 33, 6, 35, 34, 8, 16, 3, 31, 36, 7, 17, 26],
    2: [30, 11, 36, 28, 3, 26, 2, 12, 29, 35, 21, 13, 22, 34, 9],
    3: [6, 27, 36, 35, 8, 2, 24, 25, 9, 4, 10, 18, 26, 29, 30],
    4: [12, 30, 33, 35, 0, 29, 9, 23, 34, 16, 26, 1, 31, 25, 5],
    5: [24, 0, 16, 4, 23, 36, 12, 22, 19, 14, 18, 28, 2, 33, 8],
    6: [5, 35, 31, 16, 29, 26, 12, 22, 8, 7, 25, 14, 32, 15, 33],
    7: [11, 36, 24, 23, 16, 14, 32, 4, 21, 8, 31, 33, 9, 22, 17],
    8: [20, 3, 12, 31, 6, 33, 25, 7, 1, 4, 9, 24, 36, 10, 28],
    9: [10, 35, 15, 6, 25, 36, 22, 24, 3, 13, 26, 34, 12, 2, 21],
    10: [14, 30, 22, 34, 11, 21, 24, 35, 1, 0, 26, 2, 31, 4, 9],
    11: [0, 3, 14, 24, 13, 18, 5, 33, 35, 16, 15, 6, 10, 4, 31],
    12: [25, 26, 11, 35, 2, 15, 24, 10, 22, 8, 9, 13, 27, 31, 30],
    13: [3, 31, 33, 1, 30, 0, 32, 24, 18, 26, 16, 14, 20, 9, 12],
    14: [15, 7, 13, 32, 31, 1, 5, 24, 27, 10, 21, 20, 3, 19, 22],
    15: [35, 10, 29, 0, 32, 25, 13, 20, 1, 4, 12, 14, 28, 6, 27],
    16: [32, 6, 1, 36, 2, 16, 0, 11, 26, 34, 12, 7, 20, 23, 21],
    17: [21, 3, 14, 24, 25, 8, 33, 1, 16, 29, 19, 0, 12, 23, 34],
    18: [30, 8, 35, 27, 36, 10, 11, 28, 12, 20, 3, 23, 14, 13, 1],
    19: [33, 20, 15, 9, 21, 25, 19, 16, 22, 6, 12, 23, 4, 28, 35],
    20: [20, 32, 24, 16, 22, 1, 35, 15, 21, 5, 19, 33, 28, 31, 13],
    21: [21, 28, 33, 34, 13, 29, 0, 31, 22, 3, 6, 26, 15, 27, 25],
    22: [14, 36, 22, 33, 6, 8, 7, 35, 3, 19, 5, 2, 28, 26, 21],
    23: [32, 34, 8, 29, 0, 20, 28, 5, 36, 27, 17, 33, 14, 6, 16],
    24: [8, 21, 35, 36, 28, 27, 13, 26, 20, 2, 22, 16, 3, 19, 11],
    25: [1, 25, 32, 28, 15, 33, 12, 20, 11, 3, 0, 2, 36, 21, 30],
    26: [14, 1, 10, 12, 30, 18, 24, 34, 4, 13, 2, 5, 6, 0, 26],
    27: [23, 22, 9, 10, 26, 19, 35, 3, 36, 1, 15, 31, 18, 25, 2],
    28: [15, 35, 18, 13, 4, 23, 1, 28, 9, 31, 2, 32, 20, 14, 26],
    29: [1, 3, 8, 32, 7, 0, 25, 2, 34, 35, 9, 36, 11, 10, 21],
    30: [2, 5, 21, 10, 34, 4, 25, 20, 30, 1, 24, 6, 28, 36, 13],
    31: [34, 8, 12, 21, 35, 14, 5, 31, 29, 20, 33, 1, 3, 10, 2],
    32: [12, 36, 4, 33, 19, 24, 27, 18, 2, 0, 3, 31, 26, 20, 28],
    33: [6, 11, 32, 15, 28, 12, 23, 19, 30, 8, 31, 33, 24, 29, 0],
    34: [10, 26, 32, 0, 28, 3, 21, 19, 6, 17, 29, 31, 36, 14, 7],
    35: [0, 5, 24, 8, 16, 32, 12, 35, 4, 20, 15, 9, 14, 33, 29],
    36: [25, 28, 24, 5, 3, 2, 19, 30, 32, 8, 21, 18, 14, 7, 16]
}

# Donn√©es DLO2 (doublon s√©par√© par 2 num√©ros)
DLO2_DATA = {
    0: [10, 25, 30, 13, 15, 28, 0, 33, 32, 26, 1, 29, 19, 12, 4],
    1: [2, 14, 32, 20, 27, 6, 9, 17, 33, 13, 35, 5, 30, 26, 12],
    2: [35, 29, 11, 17, 16, 15, 7, 2, 8, 30, 21, 10, 25, 22, 34],
    3: [26, 17, 20, 27, 10, 34, 8, 36, 0, 25, 9, 35, 3, 16, 33],
    4: [22, 30, 14, 7, 8, 19, 13, 18, 0, 6, 24, 12, 11, 28, 32],
    5: [2, 33, 25, 36, 6, 4, 3, 23, 14, 12, 19, 24, 16, 8, 28],
    6: [10, 31, 19, 8, 16, 0, 12, 4, 36, 17, 30, 33, 1, 6, 14],
    7: [30, 20, 11, 6, 27, 23, 36, 3, 28, 24, 1, 16, 25, 15, 12],
    8: [29, 18, 2, 36, 11, 13, 33, 30, 27, 16, 28, 12, 3, 20, 32],
    9: [35, 19, 18, 22, 15, 13, 16, 9, 24, 20, 33, 36, 2, 14, 11],
    10: [32, 33, 12, 2, 3, 6, 11, 18, 14, 19, 22, 15, 30, 28, 16],
    11: [35, 14, 24, 28, 17, 32, 3, 8, 34, 22, 27, 13, 23, 0, 7],
    12: [36, 8, 23, 12, 25, 15, 5, 17, 10, 27, 3, 29, 18, 14, 30],
    13: [3, 17, 23, 6, 4, 26, 30, 27, 13, 28, 31, 19, 1, 21, 34],
    14: [22, 13, 20, 28, 15, 11, 23, 17, 25, 12, 7, 14, 21, 26, 9],
    15: [35, 27, 14, 32, 17, 5, 16, 6, 12, 26, 36, 29, 4, 3, 20],
    16: [27, 11, 34, 9, 23, 21, 30, 36, 22, 2, 20, 0, 1, 16, 32],
    17: [15, 12, 30, 25, 27, 11, 26, 9, 29, 1, 14, 10, 32, 31, 34],
    18: [10, 3, 24, 12, 34, 15, 13, 7, 1, 27, 26, 17, 30, 4, 36],
    19: [35, 24, 7, 34, 10, 23, 2, 20, 19, 26, 29, 28, 25, 16, 9],
    20: [3, 1, 20, 6, 31, 12, 32, 18, 29, 22, 17, 25, 8, 24, 0],
    21: [12, 16, 33, 22, 36, 3, 7, 26, 13, 21, 6, 19, 29, 4, 27],
    22: [26, 3, 2, 19, 5, 8, 4, 6, 17, 31, 15, 30, 25, 12, 22],
    23: [6, 2, 14, 8, 3, 26, 35, 11, 31, 25, 32, 9, 4, 24, 23],
    24: [7, 2, 36, 21, 11, 31, 1, 33, 3, 15, 10, 8, 29, 5, 0],
    25: [32, 29, 26, 20, 35, 21, 1, 24, 0, 22, 31, 7, 5, 11, 13],
    26: [30, 27, 17, 36, 29, 10, 16, 20, 32, 11, 34, 25, 24, 26, 2],
    27: [0, 29, 8, 32, 7, 22, 25, 20, 1, 19, 31, 3, 6, 5, 35],
    28: [3, 4, 16, 2, 29, 13, 35, 31, 11, 1, 7, 8, 21, 6, 0],
    29: [1, 35, 7, 11, 13, 17, 26, 3, 27, 31, 10, 16, 32, 25, 24],
    30: [35, 33, 25, 12, 23, 34, 1, 5, 29, 26, 11, 15, 18, 3, 2],
    31: [12, 25, 24, 8, 3, 32, 5, 13, 10, 36, 30, 17, 18, 35, 14],
    32: [29, 22, 11, 16, 33, 36, 12, 7, 0, 3, 13, 21, 5, 26, 14],
    33: [32, 25, 20, 1, 36, 4, 28, 27, 22, 19, 35, 17, 0, 9, 13],
    34: [24, 29, 25, 27, 7, 21, 22, 2, 34, 12, 32, 16, 35, 10, 33],
    35: [9, 11, 0, 36, 12, 6, 3, 24, 10, 35, 29, 21, 33, 31, 16],
    36: [4, 32, 8, 14, 17, 24, 21, 23, 11, 35, 31, 3, 7, 28, 15]
}



# Donn√©es des montantes
MONTANTES = {
    "CLASS": {
        2: [1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,3,3,3,3,3,3,4,4,4,4,4,5,5,5,6,6,6],
        3: [1,1,1,1,1,1,1,1,2,2,2,2,3,3,3,3,3,4,4,4,5,5,6,6,7,8,8,9,10,11,12,13,14,15,17,19],
        4: [1,1,1,1,1,1,1,2,2,2,2,2,3,3,3,4,4,5,5,6,7,8,9,10,11,12,14,16,18,20,22,25,28,32,36,40],
        5: [1,1,1,1,1,1,2,2,2,2,3,3,4,4,5,6,7,8,9,11,13,15,17,20,23,27,31,36,42,49,56,66,76,88,103,119],
        6: [1,1,1,1,2,2,2,3,3,4,5,6,7,8,10,12,14,17,21,26,32,39,48,58,71,87,106],
        7: [1,1,1,1,2,2,3,3,4,5,6,8,10,12,15,18,23,28,35,43,54,67,83],
        8: [1,1,1,1,2,2,3,4,5,6,8,10,13,17,22,28,36,46,59,76],
        9: [1,1,2,2,3,4,6,8,11,15,20,27,36,48,65,88,118,158],
        10: [1,1,1,2,3,4,5,7,10,14,19,26,36,50,69,96],
        11: [1,1,2,3,4,6,8,12,17,25,36,52,76,110,159],
        12: [1,1,2,3,4,6,9,14,21,31,47,70,105,158],
        13: [1,1,2,3,5,8,12,19,30,47,74,116,182],
        14: [1,2,3,5,8,13,22,36,59,97,159,260],
        15: [1,2,3,5,9,16,27,47,81],
        16: [1,2,3,6,11,20,37,66,120],
        17: [1,2,4,8,16,30,60,120],
        18: [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536],
        19: [1,2,4,9,18,37,78,164],
        20: [1,2,5,10,22,49,109,242],
        21: [1,3,8,12,29,70,167,399],
        24: [1,3,9,27,81,243,729,2187],
        25: [1,3,10,33,110,360]
    },
    "PR": {
        8: [1,1,2,2,3,5,8,13,22,41],
        9: [1,1,2,2,3,5,9,16,29,57],
        10: [1,1,2,2,4,6,10,18,35,73],
        11: [1,1,2,3,5,9,17,34,72,162],
        12: [1,1,2,3,6,10,20,43,96,229],
        13: [1,2,2,4,7,13,26,58,137,351],
        14: [1,2,3,5,9,19,41,95,239,654],
        15: [1,2,3,5,10,21,49,125,343,1025],
        16: [1,2,3,6,12,27,68,187,558,1821],
        17: [1,2,4,7,16,39,107,318,1035,3717],
        18: [1,2,5,10,26,70,208,679,2442,9765],
        19: [1,2,5,12,31,92,297,1065,4251,19117],
        20: [1,3,6,15,44,140,498,1979,8882,45700],
        21: [1,3,6,18,58,205,812,3640]
    },
     "LIGHT N": {
       8 :[1,1,1,2,2,3,4,6,8,11,15,20,27,37,51,69,94,129,175,239],
       9 :[1,1,1,2,3,4,6,8,12,17,24,34,49,70,100,143,204,292,417,595],
      10 :[1,1,2,3,4,6,9,14,21,31,47,70,105,158,237,355,533],
      11 :[1,1,2,3,5,7,12,18,29,46,72,114,180,284,449,709,1119],
      12 :[1,1,2,3,5,9,15,25,41,69,115,191,319,531,885],
      13 :[1,1,2,4,7,12,21,37,66,116,205,361,638,1125],
      14 :[1,1,2,4,8,15,28,52,98,183,344,645,1209],
      15 :[1,2,4,8,16,32,64,128,256,512,1024,2048,4096],
      16 :[1,2,4,9,19,41,87,187,401,859,1841],
      17 :[1,2,4,10,23,53,122,282,650,1500],
      18 :[1,2,5,13,32,80,200,500,1250,3125]

     },

     "PRX LIGHT": {
        8: [1, 1, 1, 2, 3, 6, 11, 23, 51, 124, 327],
        9: [1, 1, 2, 3, 5, 10, 21, 46, 112, 295, 855],
        10: [1, 1, 2, 3, 6, 13, 28, 68, 179, 519, 1673],
        11: [1, 1, 2, 4, 8, 18, 43, 114, 330, 1063, 3854],
        12: [1, 1, 2, 4, 9, 22, 58, 168, 541, 1961],
        13: [1, 1, 2, 5, 12, 32, 92, 297, 1076, 4458],
        14: [1, 1, 3, 7, 18, 53, 170, 616, 2552, 12335],
        15: [1, 2, 4, 11, 32, 103, 373, 1545, 7468],
        16: [1, 2, 5, 15, 48, 174, 720, 3480, 20184],
        17: [1, 2, 6, 19, 69, 286, 1382, 8015],
        18: [1, 2, 7, 25, 104, 502, 2912, 21111]
     },
     "FIBONA": {
            1:[1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17711,28657,46368,75025]

},
     "DER DOUB": {
              1:[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
                        2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,3,4,4,4,4,4,
                        4,4,4,4,5,5,5,5,5,5,5,6,6,6,6,6,6,7,7,7,7,7,8,8,8,8,9,9,9,9,10,10,10,11,11,
                       11,12,12,12,13,13,14,14,15,15]
     }


}





# Variables globales pour DLO
dlo_numbers = []
dlo_display_var = tk.StringVar(value="")
dlo_active = False

# Variables globales pour DLO1
dlo1_numbers = []
dlo1_display_var = tk.StringVar(value="")
dlo1_active = False

# Variables globales pour DLO2
dlo2_numbers = []
dlo2_display_var = tk.StringVar(value="")
dlo2_active = False


# ‚≠ê AJOUT DES VARIABLES POUR LES 6 √âCARTS DLO ‚≠ê
dlo_ecart_actuel = 0
dlo_ecart_max = 0
dlo1_ecart_actuel = 0
dlo1_ecart_max = 0
dlo2_ecart_actuel = 0
dlo2_ecart_max = 0

# Variables pour les 6 compteurs d'√©cart
dlo_eco_var = tk.StringVar(value="0")
dlo_ecmxo_var = tk.StringVar(value="0")
dlo1_eco1_var = tk.StringVar(value="0")
dlo1_ecmxo1_var = tk.StringVar(value="0")
dlo2_eco2_var = tk.StringVar(value="0")
dlo2_ecmxo2_var = tk.StringVar(value="0")


# Dimensions des cadres
DETECTION_FRAME_WIDTH = 200
DETECTION_FRAME_HEIGHT = 40


# Cr√©er un cadre commun pour les 3 syst√®mes DLO
dlo_common_frame = tk.Frame(dyza_frame, relief="ridge", borderwidth=3, bg="lightblue", padx=5, pady=5)
dlo_common_frame.grid(row=7, column=0, sticky="w", pady=5, padx=5)

# --- DLO (doublon imm√©diat) ---
dlo_row_frame = tk.Frame(dlo_common_frame, bg="lightblue")
dlo_row_frame.pack(side="top", fill="x", pady=2)

dlo_btn = tk.Button(
    dlo_row_frame,
    text="DLO",
    font=default_font,
    borderwidth=8,
    bg="orange",
    width=4,
    command=lambda: jouer_dlo(dlo_numbers, "DLO")
)
dlo_btn.pack(side="left", padx=2)


# Mini cadre pour les 2 compteurs DLO
dlo_counter_frame = tk.Frame(dlo_row_frame, relief="sunken", borderwidth=1, bg="white")
dlo_counter_frame.pack(side="left", padx=2)

tk.Label(dlo_counter_frame, text="Eco:", font=("Helvetica", 10, "bold"), bg="white").grid(row=0, column=0)
tk.Label(dlo_counter_frame, textvariable=dlo_eco_var, font=("Helvetica", 12, "bold"),
         width=3, bg="white", relief="solid").grid(row=0, column=1, padx=1)

tk.Label(dlo_counter_frame, text="Ecmxo:", font=("Helvetica", 10, "bold"), bg="white").grid(row=0, column=2)
tk.Label(dlo_counter_frame, textvariable=dlo_ecmxo_var, font=("Helvetica", 12, "bold"),
         width=3, bg="white", relief="solid").grid(row=0, column=3, padx=1)

dlo_frame = tk.Frame(dlo_common_frame, width=150, height=20, relief="sunken",
                     borderwidth=2, bg="lightgray")
dlo_frame.pack_propagate(False)
dlo_label = tk.Label(dlo_frame, textvariable=dlo_display_var, font=default_font,
                    bg="lightgray", anchor="w")
dlo_label.pack(fill="both", expand=True)
dlo_frame.pack(side="top", fill="x", pady=2)

# --- DLO1 (doublon s√©par√© par 1 num√©ro) ---
dlo1_row_frame = tk.Frame(dlo_common_frame, bg="lightblue")
dlo1_row_frame.pack(side="top", fill="x", pady=2)

dlo1_btn = tk.Button(
    dlo1_row_frame,
    text="DLO1",
    font=default_font,
    borderwidth=8,
    bg="green",
    fg="white",
    width=4,
    command=lambda: jouer_dlo(dlo1_numbers, "DLO1")
)
dlo1_btn.pack(side="left", padx=2)


# Mini cadre pour les 2 compteurs DLO1
dlo1_counter_frame = tk.Frame(dlo1_row_frame, relief="sunken", borderwidth=1, bg="white")
dlo1_counter_frame.pack(side="left", padx=2)

tk.Label(dlo1_counter_frame, text="Eco1:", font=("Helvetica", 10, "bold"), bg="white").grid(row=0, column=0)
tk.Label(dlo1_counter_frame, textvariable=dlo1_eco1_var, font=("Helvetica", 12, "bold"),
         width=3, bg="white", relief="solid").grid(row=0, column=1, padx=1)

tk.Label(dlo1_counter_frame, text="Ecmxo1:", font=("Helvetica", 10, "bold"), bg="white").grid(row=0, column=2)
tk.Label(dlo1_counter_frame, textvariable=dlo1_ecmxo1_var, font=("Helvetica", 12, "bold"),
         width=3, bg="white", relief="solid").grid(row=0, column=3, padx=1)

dlo1_frame = tk.Frame(dlo_common_frame, width=150, height=20, relief="sunken",
                      borderwidth=2, bg="lightgreen")
dlo1_frame.pack_propagate(False)
dlo1_label = tk.Label(dlo1_frame, textvariable=dlo1_display_var, font=default_font,
                     bg="lightgreen", anchor="w")
dlo1_label.pack(fill="both", expand=True)
dlo1_frame.pack(side="top", fill="x", pady=2)

# --- DLO2 (doublon s√©par√© par 2 num√©ros) ---
dlo2_row_frame = tk.Frame(dlo_common_frame, bg="lightblue")
dlo2_row_frame.pack(side="top", fill="x", pady=2)

dlo2_btn = tk.Button(
    dlo2_row_frame,
    text="DLO2",
    font=default_font,
    borderwidth=8,
    bg="Darkblue",
    fg="white",
    width=4,
    command=lambda: jouer_dlo(dlo2_numbers, "DLO2")
)
dlo2_btn.pack(side="left", padx=2)


# Mini cadre pour les 2 compteurs DLO2
dlo2_counter_frame = tk.Frame(dlo2_row_frame, relief="sunken", borderwidth=1, bg="white")
dlo2_counter_frame.pack(side="left", padx=2)

tk.Label(dlo2_counter_frame, text="Eco2:", font=("Helvetica", 10, "bold"), bg="white").grid(row=0, column=0)
tk.Label(dlo2_counter_frame, textvariable=dlo2_eco2_var, font=("Helvetica", 12, "bold"),
         width=3, bg="white", relief="solid").grid(row=0, column=1, padx=1)

tk.Label(dlo2_counter_frame, text="Ecmxo2:", font=("Helvetica", 10, "bold"), bg="white").grid(row=0, column=2)
tk.Label(dlo2_counter_frame, textvariable=dlo2_ecmxo2_var, font=("Helvetica", 12, "bold"),
         width=3, bg="white", relief="solid").grid(row=0, column=3, padx=1)

dlo2_frame = tk.Frame(dlo_common_frame, width=150, height=20, relief="sunken",
                      borderwidth=2, bg="lightyellow")
dlo2_frame.pack_propagate(False)
dlo2_label = tk.Label(dlo2_frame, textvariable=dlo2_display_var, font=default_font,
                     bg="lightyellow", anchor="w")
dlo2_label.pack(fill="both", expand=True)
dlo2_frame.pack(side="top", fill="x", pady=2)



# Fonction pour jouer les num√©ros DLO/DLO1/DLO2
def jouer_dlo(numbers_list, cadre_type):
    """Joue les num√©ros d'un cadre DLO sur la table de jeu."""
    if not numbers_list:
        messagebox.showwarning("Avertissement", f"Aucun num√©ro √† jouer pour {cadre_type}.")
        return
    # R√©cup√©rer la vitesse de clic
    try:
        click_speed = int(speed_entry.get())
    except ValueError:
        messagebox.showerror("Erreur", "La vitesse de clic doit √™tre un nombre entier.")
        return
    # R√©cup√©rer le nombre de r√©p√©titions
    try:
        repetitions = int(repet_mollette.get())
    except ValueError:
        messagebox.showerror("Erreur", "La valeur de r√©p√©tition doit √™tre un nombre entier.")
        return
    # Jouer chaque num√©ro de la liste
    for num in numbers_list:
        if num in coordinates:
            x, y = coordinates[num]
            if x > 0 and y > 0:  # V√©rifier que les coordonn√©es sont valides
                for _ in range(repetitions):  # R√©p√©ter le clic selon la valeur de REPET
                    pyautogui.click(x, y)  # Cliquer sur les coordonn√©es (X, Y)
                    time.sleep(click_speed / 1000)  # D√©lai entre les clics
            else:
                messagebox.showwarning("Avertissement", f"Coordonn√©es manquantes pour le num√©ro {num}.")
        else:
            messagebox.showwarning("Avertissement", f"Coordonn√©es manquantes pour le num√©ro {num}.")



# Fonction de mise √† jour DLO (doublon imm√©diat)
def update_dlo(last_number):
    global dlo_active, dlo_ecart_actuel, dlo_ecart_max, dlo_display_var
    # D√©sactiver DLO si un autre cadre est actif
    if dlo_active:
        return
    # V√©rifier la condition de DLO (doublon imm√©diat)
    if len(history) >= 2 and history[-1] == history[-2]:
        num = history[-1]
        if num in DLO_DATA:
            dlo_active = True
            dlo_numbers.clear()
            dlo_numbers.extend(DLO_DATA[num])
            dlo_display_var.set("DLO : " + " ".join(map(str, dlo_numbers)))
            dlo_ecart_actuel = 0
    else:
        dlo_ecart_actuel += 1
    dlo_ecart_max = max(dlo_ecart_max, dlo_ecart_actuel)
    dlo_eco_var.set(str(dlo_ecart_actuel))
    dlo_ecmxo_var.set(str(dlo_ecart_max))



# Fonction de mise √† jour DLO1 (doublon s√©par√© par 1 num√©ro)
def update_dlo1(last_number):
    global dlo1_active, dlo1_ecart_actuel, dlo1_ecart_max, dlo1_display_var
    # D√©sactiver DLO1 si un autre cadre est actif
    if dlo1_active:
        return
    # V√©rifier la condition de DLO1 (doublon s√©par√© par 1 num√©ro)
    if len(history) >= 3 and history[-1] == history[-3]:
        num = history[-1]
        if num in DLO1_DATA:
            dlo1_active = True
            dlo1_numbers.clear()
            dlo1_numbers.extend(DLO1_DATA[num])
            dlo1_display_var.set("DLO1 : " + " ".join(map(str, dlo1_numbers)))
            dlo1_ecart_actuel = 0
    else:
        dlo1_ecart_actuel += 1
    dlo1_ecart_max = max(dlo1_ecart_max, dlo1_ecart_actuel)
    dlo1_eco1_var.set(str(dlo1_ecart_actuel))
    dlo1_ecmxo1_var.set(str(dlo1_ecart_max))


# Fonction de mise √† jour DLO2 (doublon s√©par√© par 2 num√©ros)
def update_dlo2(last_number):
    global dlo2_active, dlo2_ecart_actuel, dlo2_ecart_max, dlo2_display_var
    # D√©sactiver DLO2 si un autre cadre est actif
    if len(history) >= 4 and history[-1] == history[-4]:
        num = history[-1]
        if num in DLO2_DATA:
            dlo2_active = True
            dlo2_numbers.clear()
            dlo2_numbers.extend(DLO2_DATA[num])
            dlo2_display_var.set("DLO2 : " + " ".join(map(str, dlo2_numbers)))
            dlo2_ecart_actuel = 0
    else:
        dlo2_ecart_actuel += 1
    dlo2_ecart_max = max(dlo2_ecart_max, dlo2_ecart_actuel)
    dlo2_eco2_var.set(str(dlo2_ecart_actuel))
    dlo2_ecmxo2_var.set(str(dlo2_ecart_max))


def update_dlo_ecarts(last_number=None):
    global dlo_ecart_actuel, dlo_ecart_max, dlo1_ecart_actuel, dlo1_ecart_max, dlo2_ecart_actuel, dlo2_ecart_max

    # Si un num√©ro est fourni, v√©rifier s'il fait partie des DLO actifs
    if last_number is not None:
        # V√©rifier pour DLO
        if dlo_active and last_number in dlo_numbers:
            dlo_ecart_actuel = 0
        elif not dlo_active:
            dlo_ecart_actuel += 1

        # V√©rifier pour DLO1
        if dlo1_active and last_number in dlo1_numbers:
            dlo1_ecart_actuel = 0
        elif not dlo1_active:
            dlo1_ecart_actuel += 1

        # V√©rifier pour DLO2
        if dlo2_active and last_number in dlo2_numbers:
            dlo2_ecart_actuel = 0
        elif not dlo2_active:
            dlo2_ecart_actuel += 1
    else:
        # Si aucun num√©ro n'est fourni, incr√©menter normalement
        if not dlo_active:
            dlo_ecart_actuel += 1
        if not dlo1_active:
            dlo1_ecart_actuel += 1
        if not dlo2_active:
            dlo2_ecart_actuel += 1

    # Mettre √† jour les √©carts max si n√©cessaire
    if dlo_ecart_actuel > dlo_ecart_max:
        dlo_ecart_max = dlo_ecart_actuel
    if dlo1_ecart_actuel > dlo1_ecart_max:
        dlo1_ecart_max = dlo1_ecart_actuel
    if dlo2_ecart_actuel > dlo2_ecart_max:
        dlo2_ecart_max = dlo2_ecart_actuel

    # Mise √† jour de l'affichage des 6 compteurs
    def update_dlo_ecarts(last_number=None):
        # Mise √† jour des labels d'√©cart pour les 3 cadres
        dlo_eco_var.set(str(dlo_ecart_actuel))
        dlo_ecmxo_var.set(str(dlo_ecart_max))
        dlo1_eco1_var.set(str(dlo1_ecart_actuel))
        dlo1_ecmxo1_var.set(str(dlo1_ecart_max))
        dlo2_eco2_var.set(str(dlo2_ecart_actuel))
        dlo2_ecmxo2_var.set(str(dlo2_ecart_max))
        root.update_idletasks()


# Fonction de r√©initialisation DLO/DLO1/DLO2
def reset_dlo():
    global dlo_numbers, dlo_active, dlo1_numbers, dlo1_active, dlo2_numbers, dlo2_active
    global dlo_ecart_actuel, dlo_ecart_max, dlo1_ecart_actuel, dlo1_ecart_max, dlo2_ecart_actuel, dlo2_ecart_max

    # R√©initialisation des listes et √©tats
    dlo_numbers.clear()
    dlo1_numbers.clear()
    dlo2_numbers.clear()

    dlo_active = False
    dlo1_active = False
    dlo2_active = False

    # Remise √† z√©ro des √©carts actuels ET max
    dlo_ecart_actuel = 0
    dlo_ecart_max = 0
    dlo1_ecart_actuel = 0
    dlo1_ecart_max = 0
    dlo2_ecart_actuel = 0
    dlo2_ecart_max = 0

    # Mise √† jour de l'affichage
    dlo_display_var.set("")
    dlo1_display_var.set("")
    dlo2_display_var.set("")

    # Mise √† jour des 6 compteurs dans l'interface
    dlo_eco_var.set("0")
    dlo_ecmxo_var.set("0")
    dlo1_eco1_var.set("0")
    dlo1_ecmxo1_var.set("0")
    dlo2_eco2_var.set("0")
    dlo2_ecmxo2_var.set("0")

# Patch : Remplacement de update_counters
original_update_counters = update_counters


def new_update_counters(number):
    if dlo_active or dlo1_active or dlo2_active:
        reset_dlo()
    original_update_counters(number)
    update_dlo(number)
    update_dlo1(number)
    update_dlo2(number)
    update_dlo_ecarts(number)  # ‚≠ê AJOUT DU NUM√âRO EN PARAM√àTRE ‚≠ê

update_counters = new_update_counters

# Patch : Remplacement de reinitialiser_cadres
original_reinitialiser_cadres = reinitialiser_cadres


def new_reinitialiser_cadres(listboxes, counter_labels, nom_entries, series_labels):
    original_reinitialiser_cadres(listboxes, counter_labels, nom_entries, series_labels)
    reset_dlo()


reinitialiser_cadres = new_reinitialiser_cadres

# ========================
# AJOUT SYST√àME F23 / F14
# ========================

# Donn√©es int√©gr√©es
f23_data = {
    0: [0, 1, 2, 3, 4, 5, 7, 8, 10, 11, 12, 15, 16, 19, 21, 23, 24, 26, 28, 30, 32, 33, 35],
    1: [0, 1, 2, 4, 5, 9, 10, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 31, 32, 33, 34],
    2: [0, 1, 2, 4, 6, 9, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 24, 25, 27, 31, 32, 33, 34],
    3: [0, 3, 4, 5, 7, 8, 10, 11, 12, 13, 15, 16, 18, 19, 23, 24, 26, 28, 29, 30, 32, 35, 36],
    4: [0, 1, 2, 3, 4, 5, 6, 9, 10, 14, 15, 16, 17, 19, 20, 21, 24, 25, 26, 31, 32, 33, 34],
    5: [0, 1, 3, 4, 5, 8, 10, 11, 12, 14, 15, 16, 19, 20, 21, 23, 24, 26, 30, 32, 33, 35, 36],
    6: [2, 4, 6, 7, 8, 9, 11, 12, 13, 14, 17, 18, 20, 21, 22, 25, 27, 28, 29, 30, 31, 34, 36],
    7: [0, 3, 6, 7, 8, 9, 11, 12, 13, 14, 17, 18, 22, 23, 26, 27, 28, 29, 30, 31, 34, 35, 36],
    8: [0, 3, 5, 6, 7, 8, 10, 11, 12, 13, 15, 16, 23, 24, 26, 27, 28, 29, 30, 32, 33, 35, 36],
    9: [1, 2, 4, 6, 7, 9, 12, 13, 14, 16, 17, 18, 20, 21, 22, 25, 27, 28, 29, 31, 33, 34, 36],
    10: [0, 1, 3, 4, 5, 8, 10, 11, 12, 13, 15, 16, 19, 20, 23, 24, 26, 28, 30, 32, 33, 35, 36],
    11: [0, 3, 5, 6, 7, 8, 10, 11, 12, 13, 17, 18, 22, 23, 24, 26, 27, 28, 29, 30, 34, 35, 36],
    12: [0, 3, 5, 6, 7, 8, 9, 10, 11, 12, 13, 15, 18, 22, 23, 26, 27, 28, 29, 30, 32, 35, 36],
    13: [2, 3, 6, 7, 8, 9, 10, 11, 12, 13, 17, 18, 22, 23, 25, 27, 28, 29, 30, 31, 34, 35, 36],
    14: [1, 2, 4, 5, 6, 7, 9, 14, 15, 16, 17, 18, 19, 20, 21, 22, 24, 25, 27, 29, 31, 33, 34],
    15: [0, 1, 2, 3, 4, 5, 8, 10, 12, 14, 15, 16, 17, 19, 20, 21, 23, 24, 25, 26, 32, 33, 35],
    16: [0, 1, 2, 3, 4, 5, 8, 9, 10, 14, 15, 16, 19, 20, 21, 23, 24, 25, 26, 30, 31, 32, 33],
    17: [1, 2, 4, 6, 7, 9, 11, 13, 14, 15, 17, 18, 19, 20, 21, 22, 25, 27, 29, 31, 33, 34, 36],
    18: [1, 2, 3, 6, 7, 9, 11, 12, 13, 14, 17, 18, 20, 22, 25, 27, 28, 29, 30, 31, 34, 35, 36],
    19: [0, 1, 2, 3, 4, 5, 10, 14, 15, 16, 17, 19, 20, 21, 23, 24, 25, 26, 31, 32, 33, 34, 35],
    20: [1, 2, 4, 5, 6, 9, 10, 14, 15, 16, 17, 18, 19, 20, 21, 22, 24, 25, 29, 31, 32, 33, 34],
    21: [0, 1, 2, 4, 5, 6, 9, 14, 15, 16, 17, 19, 20, 21, 22, 24, 25, 26, 27, 31, 32, 33, 34],
    22: [1, 2, 6, 7, 9, 11, 12, 13, 14, 17, 18, 20, 21, 22, 25, 27, 28, 29, 31, 33, 34, 35, 36],
    23: [0, 1, 3, 5, 7, 8, 10, 11, 12, 13, 15, 16, 19, 23, 24, 26, 27, 28, 30, 32, 33, 35, 36],
    24: [0, 1, 2, 3, 4, 5, 8, 10, 11, 14, 15, 16, 19, 20, 21, 23, 24, 26, 30, 31, 32, 33, 35],
    25: [1, 2, 4, 6, 9, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 25, 27, 29, 31, 32, 33, 34, 36],
    26: [0, 3, 4, 5, 7, 8, 10, 11, 12, 15, 16, 19, 21, 23, 24, 26, 28, 29, 30, 32, 33, 35, 36],
    27: [2, 6, 7, 8, 9, 11, 12, 13, 14, 17, 18, 21, 22, 23, 25, 27, 28, 29, 30, 31, 34, 35, 36],
    28: [0, 3, 6, 7, 8, 9, 10, 11, 12, 13, 18, 22, 23, 26, 27, 28, 29, 30, 31, 32, 34, 35, 36],
    29: [3, 6, 7, 8, 9, 11, 12, 13, 14, 17, 18, 20, 22, 25, 26, 27, 28, 29, 30, 31, 34, 35, 36],
    30: [0, 3, 5, 6, 7, 8, 10, 11, 12, 13, 16, 18, 23, 24, 26, 27, 28, 29, 30, 32, 34, 35, 36],
    31: [1, 2, 4, 6, 7, 9, 13, 14, 16, 17, 18, 19, 20, 21, 22, 24, 25, 27, 28, 29, 31, 33, 34],
    32: [0, 1, 2, 3, 4, 5, 8, 10, 12, 15, 16, 19, 20, 21, 23, 24, 25, 26, 28, 30, 32, 33, 35],
    33: [0, 1, 2, 4, 5, 8, 9, 10, 14, 15, 16, 17, 19, 20, 21, 22, 23, 24, 25, 26, 31, 32, 33],
    34: [1, 2, 4, 6, 7, 9, 11, 13, 14, 17, 18, 19, 20, 21, 22, 25, 27, 28, 29, 30, 31, 34, 36],
    35: [0, 3, 5, 7, 8, 10, 11, 12, 13, 15, 18, 19, 22, 23, 24, 26, 27, 28, 29, 30, 32, 35, 36],
    36: [3, 5, 6, 7, 8, 9, 10, 11, 12, 13, 17, 18, 22, 23, 25, 26, 27, 28, 29, 30, 34, 35, 36]
}

f14_data = {
    0: [6, 9, 13, 14, 17, 18, 20, 22, 25, 27, 29, 31, 34, 36],
    1: [3, 6, 7, 8, 11, 12, 13, 26, 27, 28, 29, 30, 35, 36],
    2: [3, 5, 7, 8, 10, 11, 12, 23, 26, 28, 29, 30, 35, 36],
    3: [1, 2, 6, 9, 14, 17, 20, 21, 22, 25, 27, 29, 31, 34],
    4: [7, 8, 11, 12, 13, 18, 22, 23, 27, 28, 29, 30, 35, 36],
    5: [2, 6, 7, 9, 13, 17, 18, 22, 25, 27, 28, 29, 31, 34],
    6: [0, 1, 3, 5, 10, 15, 16, 19, 23, 24, 26, 32, 33, 35],
    7: [1, 2, 4, 5, 10, 15, 16, 19, 20, 21, 24, 25, 32, 33],
    8: [1, 2, 4, 9, 14, 17, 18, 19, 20, 21, 22, 25, 31, 34],
    9: [0, 3, 5, 8, 10, 15, 16, 19, 23, 24, 26, 30, 32, 35],
    10: [2, 6, 7, 9, 14, 17, 18, 21, 22, 25, 27, 29, 31, 34],
    11: [1, 2, 4, 9, 14, 15, 16, 19, 20, 21, 25, 31, 32, 33],
    12: [1, 2, 4, 14, 16, 17, 19, 20, 21, 24, 25, 31, 33, 34],
    13: [0, 1, 4, 5, 14, 15, 16, 19, 20, 21, 24, 26, 32, 33],
    14: [0, 3, 8, 10, 11, 12, 13, 23, 26, 28, 30, 32, 35, 36],
    15: [6, 7, 9, 11, 13, 18, 22, 27, 28, 29, 30, 31, 34, 36],
    16: [6, 7, 11, 12, 13, 17, 18, 22, 27, 28, 29, 34, 35, 36],
    17: [0, 3, 5, 8, 10, 12, 16, 23, 24, 26, 28, 30, 32, 35],
    18: [0, 4, 5, 8, 10, 15, 16, 19, 21, 23, 24, 26, 32, 33],
    19: [6, 7, 8, 9, 11, 12, 13, 18, 22, 27, 28, 29, 30, 36],
    20: [0, 3, 7, 8, 11, 12, 13, 23, 26, 27, 28, 30, 35, 36],
    21: [3, 7, 8, 10, 11, 12, 13, 18, 23, 28, 29, 30, 35, 36],
    22: [0, 3, 4, 5, 8, 10, 15, 16, 19, 23, 24, 26, 30, 32],
    23: [2, 4, 6, 9, 14, 17, 18, 20, 21, 22, 25, 29, 31, 34],
    24: [6, 7, 9, 12, 13, 17, 18, 22, 25, 27, 28, 29, 34, 36],
    25: [0, 3, 5, 7, 8, 10, 11, 12, 23, 24, 26, 28, 30, 35],
    26: [1, 2, 6, 9, 13, 14, 17, 18, 20, 22, 25, 27, 31, 34],
    27: [0, 1, 3, 4, 5, 10, 15, 16, 19, 20, 24, 26, 32, 33],
    28: [1, 2, 4, 5, 14, 15, 16, 17, 19, 20, 21, 24, 25, 33],
    29: [0, 1, 2, 4, 5, 10, 15, 16, 19, 21, 23, 24, 32, 33],
    30: [1, 2, 4, 9, 14, 15, 17, 19, 20, 21, 22, 25, 31, 33],
    31: [0, 3, 5, 8, 10, 11, 12, 15, 23, 26, 30, 32, 35, 36],
    32: [6, 7, 9, 11, 13, 14, 17, 18, 22, 27, 29, 31, 34, 36],
    33: [3, 6, 7, 11, 12, 13, 18, 27, 28, 29, 30, 34, 35, 36],
    34: [0, 3, 5, 8, 10, 12, 15, 16, 23, 24, 26, 32, 33, 35],
    35: [1, 2, 4, 6, 9, 14, 16, 17, 20, 21, 25, 31, 33, 34],
    36: [0, 1, 2, 4, 14, 15, 16, 19, 20, 21, 24, 31, 32, 33]
}


# Fonction de mise √† jour

# NE PAS PATCHER on_number_click ici
# update_f23_f14 sera appel√©e dans la version finale de on_number_click

def update_f23_f14(last_number):
    global f23_numbers, f14_numbers, f23_ec, f14_ec, f23_ecmx, f14_ecmx

    # Mise √† jour imm√©diate des num√©ros de cadre avec le num√©ro saisi
    if last_number in f23_data:
        f23_numbers = f23_data[last_number]
        f23_display_var.set("f23 " + " ".join(map(str, f23_numbers)))
    if last_number in f14_data:
        f14_numbers = f14_data[last_number]
        f14_display_var.set("f14 " + " ".join(map(str, f14_numbers)))

    # Calcul des √©carts seulement √† partir du 2e num√©ro
    if len(history) >= 2:
        previous_num = history[-2]  # Num√©ro pr√©c√©dent (r√©f√©rence de la s√©rie pass√©e)
        current_num = last_number  # Num√©ro actuel

        # Obtenir les anciennes s√©ries (du num√©ro pr√©c√©dent)
        prev_f23 = f23_data.get(previous_num, [])
        prev_f14 = f14_data.get(previous_num, [])

        # R√©initialiser Ec si le num√©ro actuel est dans la s√©rie du num√©ro pr√©c√©dent
        if current_num in prev_f23:
            f23_ec = 0
        else:
            f23_ec += 1

        if current_num in prev_f14:
            f14_ec = 0
        else:
            f14_ec += 1

        # Mettre √† jour Ecmx
        if f23_ec > f23_ecmx:
            f23_ecmx = f23_ec
        if f14_ec > f14_ecmx:
            f14_ecmx = f14_ec

    # Mise √† jour des labels
    f23_ec_var.set(f"Ec: {f23_ec}")
    f14_ec_var.set(f"Ec: {f14_ec}")
    f23_ecmx_var.set(f"Ecmx: {f23_ecmx}")
    f14_ecmx_var.set(f"Ecmx: {f14_ecmx}")


# ==============================================
# AJOUT SYST√àME   EQUIVALENT   [ HIGH / LOW ]
# ==============================================

# --- 1. Donn√©es int√©gr√©es (HIGH et LOW) ---
high_data = {
    0: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30,
        31, 32, 33, 34, 35, 36],
    1: [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
        32, 33, 34, 35, 36],
    2: [3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32,
        33, 34, 35, 36],
    3: [4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32,
        33, 34, 35, 36],
    4: [5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33,
        34, 35, 36],
    5: [6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34,
        35, 36],
    6: [7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35,
        36],
    7: [8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35,
        36],
    8: [9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36],
    9: [10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36],
    10: [11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36],
    11: [12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36],
    12: [13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36],
    13: [14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36],
    14: [15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36],
    15: [16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36],
    16: [17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36],
    17: [18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36],
    18: [19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36],
    19: [20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36],
    20: [21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36],
    21: [22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36],
    22: [23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36],
    23: [24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36],
    24: [25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36],
    25: [26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36],
    26: [27, 28, 29, 30, 31, 32, 33, 34, 35, 36],
    27: [28, 29, 30, 31, 32, 33, 34, 35, 36],
    28: [29, 30, 31, 32, 33, 34, 35, 36],
    29: [30, 31, 32, 33, 34, 35, 36],
    30: [31, 32, 33, 34, 35, 36],
    31: [32, 33, 34, 35, 36],
    32: [33, 34, 35, 36],
    33: [34, 35, 36],
    34: [35, 36],
    35: [36],
    36: []
}

low_data = {
    0: [],
    1: [0],
    2: [0, 1],
    3: [0, 1, 2],
    4: [0, 1, 2, 3],
    5: [0, 1, 2, 3, 4],
    6: [0, 1, 2, 3, 4, 5],
    7: [0, 1, 2, 3, 4, 5, 6],
    8: [0, 1, 2, 3, 4, 5, 6, 7],
    9: [0, 1, 2, 3, 4, 5, 6, 7, 8],
    10: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9],
    11: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
    12: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11],
    13: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12],
    14: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13],
    15: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14],
    16: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15],
    17: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16],
    18: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17],
    19: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18],
    20: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19],
    21: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],
    22: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21],
    23: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22],
    24: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23],
    25: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24],
    26: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25],
    27: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26],
    28: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27],
    29: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28],
    30: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29],
    31: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29,
         30],
    32: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29,
         30, 31],
    33: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29,
         30, 31, 32],
    34: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29,
         30, 31, 32, 33],
    35: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29,
         30, 31, 32, 33, 34],
    36: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29,
         30, 31, 32, 33, 34, 35]
}


# Fonction de mise √† jour
def update_high_low(last_number):
    global high_numbers, low_numbers, high_ec, low_ec, high_ecmx, low_ecmx

    # Mise √† jour imm√©diate des num√©ros de cadre avec le num√©ro saisi
    if last_number in high_data:
        high_numbers = high_data[last_number]
        high_display_var.set("high " + " ".join(map(str, high_numbers)))
        high_count_var.set(str(len(high_numbers)))  # Mise √† jour compteur
    if last_number in low_data:
        low_numbers = low_data[last_number]
        low_display_var.set("low " + " ".join(map(str, low_numbers)))
        low_count_var.set(str(len(low_numbers)))  # Mise √† jour compteur

    # Calcul des √©carts seulement √† partir du 2e num√©ro
    if len(history) >= 2:
        previous_num = history[-2]  # Num√©ro pr√©c√©dent (r√©f√©rence de la s√©rie pass√©e)
        current_num = last_number  # Num√©ro actuel

        # Obtenir les anciennes s√©ries (du num√©ro pr√©c√©dent)
        prev_high = high_data.get(previous_num, [])
        prev_low = low_data.get(previous_num, [])

        # R√©initialiser Ec si le num√©ro actuel est dans la s√©rie du num√©ro pr√©c√©dent
        if current_num in prev_high:
            high_ec = 0
        else:
            high_ec += 1

        if current_num in prev_low:
            low_ec = 0
        else:
            low_ec += 1

        # Mettre √† jour Ecmx
        if high_ec > high_ecmx:
            high_ecmx = high_ec
        if low_ec > low_ecmx:
            low_ecmx = low_ec

    # Mise √† jour des labels
    high_ec_var.set(f"Ec: {high_ec}")
    low_ec_var.set(f"Ec: {low_ec}")
    high_ecmx_var.set(f"Ecmx: {high_ecmx}")
    low_ecmx_var.set(f"Ecmx: {low_ecmx}")


# ===================================================
# AJOUT SYST√àME DISTANCE - VERSION FINALE ET CORRIG√âE
# ===================================================

# Donn√©es Distance compl√®tes et corrig√©es
distance_data = {
    0: {
        "T1": [1, 2, 3],
        "T2": [4, 5, 6],
        "T3": [7, 8, 9],
        "T4": [10, 11, 12],
        "T5": [13, 14, 15],
        "T6": [16, 17, 18],
        "T7": [19, 20, 21],
        "T8": [22, 23, 24],
        "T9": [25, 26, 27],
        "T10": [28, 29, 30],
        "T11": [31, 32, 33],
        "T12": [34, 35, 36],
        "T13": []
    },
    1: {
        "T1": [0, 2, 4],
        "T2": [3, 5, 7],
        "T3": [6, 8, 10],
        "T4": [13, 9, 11],
        "T5": [12, 14, 16],
        "T6": [19, 17, 15],
        "T7": [22, 20, 18],
        "T8": [21, 23, 25],
        "T9": [24, 26, 28],
        "T10": [31, 27, 29],
        "T11": [30, 32, 34],
        "T12": [33, 35],
        "T13": [36]
    },
    2: {
        "T1": [0, 1, 3, 5],
        "T2": [4, 6, 8],
        "T3": [11, 9, 7],
        "T4": [14, 10, 12],
        "T5": [17, 15, 13],
        "T6": [18, 16, 20],
        "T7": [23, 19, 21],
        "T8": [22, 24, 26],
        "T9": [25, 27, 29],
        "T10": [28, 30, 32],
        "T11": [35, 31, 33],
        "T12": [34, 36],
        "T13": []
    },
    3: {
        "T1": [0, 2, 6],
        "T2": [1, 5, 9],
        "T3": [12, 8, 4],
        "T4": [15, 11, 7],
        "T5": [18, 14, 10],
        "T6": [21, 17, 13],
        "T7": [16, 20, 24],
        "T8": [19, 23, 27],
        "T9": [22, 26, 30],
        "T10": [33, 29, 25],
        "T11": [28, 32, 36],
        "T12": [31, 35],
        "T13": [34]
    },
    4: {
        "T1": [1, 5, 7],
        "T2": [0, 2, 6, 8, 10],
        "T3": [3, 9, 11, 13],
        "T4": [16, 12, 14],
        "T5": [15, 17, 19],
        "T6": [22, 20, 18],
        "T7": [21, 23, 25],
        "T8": [24, 26, 28],
        "T9": [27, 29, 31],
        "T10": [34, 30, 32],
        "T11": [35, 33],
        "T12": [36],
        "T13": []
    },
    5: {
        "T1": [2, 4, 6, 8],
        "T2": [0, 1, 3, 7, 9, 11],
        "T3": [12, 14, 10],
        "T4": [17, 15, 13],
        "T5": [20, 18, 16],
        "T6": [21, 23, 19],
        "T7": [22, 24, 26],
        "T8": [25, 27, 29],
        "T9": [28, 30, 32],
        "T10": [31, 33, 35],
        "T11": [34, 36],
        "T12": [],
        "T13": []
    },
    6: {
        "T1": [3, 5, 9],
        "T2": [0, 2, 4, 8, 12],
        "T3": [1, 15, 7, 11],
        "T4": [18, 10, 14],
        "T5": [21, 17, 13],
        "T6": [24, 20, 16],
        "T7": [19, 23, 27],
        "T8": [22, 26, 30],
        "T9": [25, 29, 33],
        "T10": [28, 32, 36],
        "T11": [31, 35],
        "T12": [34],
        "T13": []
    },
    7: {
        "T1": [4, 8, 10],
        "T2": [1, 5, 9, 11, 13],
        "T3": [2, 6, 12, 16, 14, 0],
        "T4": [3, 19, 15, 17],
        "T5": [22, 20, 18],
        "T6": [25, 23, 21],
        "T7": [24, 26, 28],
        "T8": [27, 29, 31],
        "T9": [30, 32, 34],
        "T10": [35, 33],
        "T11": [36],
        "T12": [],
        "T13": []
    },
    8: {
        "T1": [5, 7, 9, 11],
        "T2": [2, 4, 6, 10, 12, 14],
        "T3": [3, 1, 15, 13, 17, 0],
        "T4": [18, 20, 16],
        "T5": [23, 21, 19],
        "T6": [22, 24, 26],
        "T7": [25, 27, 29],
        "T8": [28, 30, 32],
        "T9": [31, 33, 35],
        "T10": [36, 34],
        "T11": [],
        "T12": [],
        "T13": []
    },
    9: {
        "T1": [6, 8, 12],
        "T2": [3, 5, 7, 11, 15],
        "T3": [2, 4, 18, 10, 14, 0],
        "T4": [1, 21, 13, 17],
        "T5": [24, 20, 16],
        "T6": [19, 23, 27],
        "T7": [22, 26, 30],
        "T8": [25, 29, 33],
        "T9": [28, 32, 36],
        "T10": [31, 35],
        "T11": [34],
        "T12": [],
        "T13": []
    },
    10: {
        "T1": [7, 11, 13],
        "T2": [12, 4, 8, 14, 16],
        "T3": [1, 19, 9, 15, 5, 17],
        "T4": [0, 2, 6, 18, 20, 22],
        "T5": [3, 21, 23, 25],
        "T6": [28, 26, 24],
        "T7": [27, 29, 31],
        "T8": [30, 32, 34],
        "T9": [35, 33],
        "T10": [36],
        "T11": [],
        "T12": [],
        "T13": []
    },
    11: {
        "T1": [8, 10, 12, 14],
        "T2": [5, 7, 9, 13, 15, 17],
        "T3": [2, 20, 6, 18, 4, 16],
        "T4": [1, 3, 21, 19, 23, 0],
        "T5": [24, 22, 26],
        "T6": [25, 27, 29],
        "T7": [28, 30, 32],
        "T8": [31, 33, 35],
        "T9": [36, 34],
        "T10": [],
        "T11": [],
        "T12": [],
        "T13": []
    },
    12: {
        "T1": [9, 11, 15],
        "T2": [6, 8, 10, 18, 14],
        "T3": [3, 21, 5, 17, 7, 13],
        "T4": [0, 2, 4, 16, 20, 24],
        "T5": [1, 27, 23, 19],
        "T6": [30, 26, 22],
        "T7": [25, 29, 33],
        "T8": [28, 32, 36],
        "T9": [31, 35],
        "T10": [34],
        "T11": [],
        "T12": [],
        "T13": []
    },
    13: {
        "T1": [10, 14, 16],
        "T2": [7, 15, 11, 17, 19],
        "T3": [4, 22, 12, 18, 8, 20],
        "T4": [1, 25, 5, 23, 9, 21],
        "T5": [0, 2, 6, 24, 26, 28],
        "T6": [3, 27, 29, 31],
        "T7": [30, 32, 34],
        "T8": [35, 33],
        "T9": [36],
        "T10": [],
        "T11": [],
        "T12": [],
        "T13": []
    },
    14: {
        "T1": [11, 13, 15, 17],
        "T2": [8, 10, 12, 16, 18, 20],
        "T3": [5, 23, 9, 21, 7, 19],
        "T4": [2, 6, 24, 26, 4, 22],
        "T5": [3, 1, 27, 29, 25, 0],
        "T6": [30, 28, 32],
        "T7": [35, 31, 33],
        "T8": [34, 36],
        "T9": [],
        "T10": [],
        "T11": [],
        "T12": [],
        "T13": []
    },
    15: {
        "T1": [12, 14, 18],
        "T2": [9, 21, 13, 11, 17],
        "T3": [6, 24, 8, 20, 10, 16],
        "T4": [3, 27, 5, 23, 7, 19],
        "T5": [0, 2, 4, 22, 26, 30],
        "T6": [1, 33, 29, 25],
        "T7": [28, 32, 36],
        "T8": [31, 35],
        "T9": [34],
        "T10": [],
        "T11": [],
        "T12": [],
        "T13": []
    },
    16: {
        "T1": [13, 17, 19],
        "T2": [10, 14, 18, 20, 22],
        "T3": [7, 25, 11, 23, 15, 21],
        "T4": [4, 28, 8, 26, 12, 24],
        "T5": [1, 5, 9, 31, 29, 27],
        "T6": [2, 6, 30, 32, 34, 0],
        "T7": [35, 33, 3],
        "T8": [36],
        "T9": [],
        "T10": [],
        "T11": [],
        "T12": [],
        "T13": []
    },
    17: {
        "T1": [14, 16, 18, 20],
        "T2": [11, 15, 21, 13, 19, 23],
        "T3": [8, 26, 12, 24, 10, 22],
        "T4": [5, 29, 9, 27, 7, 25],
        "T5": [2, 4, 6, 32, 30, 28],
        "T6": [1, 3, 31, 33, 35, 0],
        "T7": [34, 36],
        "T8": [],
        "T9": [],
        "T10": [],
        "T11": [],
        "T12": [],
        "T13": []
    },
    18: {
        "T1": [15, 17, 21],
        "T2": [12, 24, 16, 14, 20],
        "T3": [9, 27, 11, 23, 13, 19],
        "T4": [6, 30, 8, 26, 10, 22],
        "T5": [3, 5, 7, 33, 29, 25],
        "T6": [2, 4, 36, 32, 28, 0],
        "T7": [35, 31, 1],
        "T8": [34],
        "T9": [],
        "T10": [],
        "T11": [],
        "T12": [],
        "T13": []
    },
    19: {
        "T1": [16, 20, 22],
        "T2": [13, 21, 17, 23, 25],
        "T3": [10, 28, 14, 26, 18, 24],
        "T4": [7, 31, 11, 29, 15, 27],
        "T5": [4, 8, 12, 34, 32, 30],
        "T6": [1, 5, 9, 33, 35],
        "T7": [0, 36, 6, 2],
        "T8": [3],
        "T9": [],
        "T10": [],
        "T11": [],
        "T12": [],
        "T13": []
    },
    20: {
        "T1": [17, 19, 21, 23],
        "T2": [14, 18, 24, 16, 22, 26],
        "T3": [11, 29, 15, 27, 13, 25],
        "T4": [8, 32, 12, 30, 10, 28],
        "T5": [5, 7, 9, 33, 31, 35],
        "T6": [2, 4, 6, 34, 36],
        "T7": [0, 3, 1],
        "T8": [],
        "T9": [],
        "T10": [],
        "T11": [],
        "T12": [],
        "T13": []
    },
    21: {
        "T1": [18, 20, 24],
        "T2": [19, 15, 27, 17, 23],
        "T3": [12, 30, 14, 26, 16, 22],
        "T4": [9, 33, 11, 29, 13, 25],
        "T5": [36, 6, 32, 8, 28, 10],
        "T6": [3, 5, 7, 35, 31],
        "T7": [0, 2, 34, 4],
        "T8": [1],
        "T9": [],
        "T10": [],
        "T11": [],
        "T12": [],
        "T13": []
    },
    22: {
        "T1": [19, 23, 25],
        "T2": [16, 28, 24, 20, 26],
        "T3": [13, 31, 17, 29, 21, 27],
        "T4": [10, 14, 32, 30, 18, 34],
        "T5": [7, 11, 15, 35, 33],
        "T6": [4, 8, 12, 36],
        "T7": [1, 5, 9],
        "T8": [6, 2, 0],
        "T9": [3],
        "T10": [],
        "T11": [],
        "T12": [],
        "T13": []
    },
    23: {
        "T1": [20, 22, 24, 26],
        "T2": [17, 21, 27, 19, 25, 29],
        "T3": [14, 32, 16, 28, 18, 30],
        "T4": [11, 35, 15, 33, 13, 31],
        "T5": [8, 34, 10, 12, 36],
        "T6": [9, 5, 7],
        "T7": [2, 4, 6],
        "T8": [3, 0, 1],
        "T9": [],
        "T10": [],
        "T11": [],
        "T12": [],
        "T13": []
    },
    24: {
        "T1": [21, 23, 27],
        "T2": [18, 30, 22, 20, 26],
        "T3": [15, 33, 17, 29, 19, 25],
        "T4": [36, 12, 14, 32, 16, 28],
        "T5": [9, 35, 11, 31, 13],
        "T6": [6, 8, 10, 34],
        "T7": [3, 5, 7],
        "T8": [4, 2, 0],
        "T9": [0, 1],
        "T10": [],
        "T11": [],
        "T12": [],
        "T13": []
    },
    25: {
        "T1": [22, 26, 28],
        "T2": [27, 19, 31, 23, 29],
        "T3": [16, 34, 20, 32, 34, 30],
        "T4": [13, 35, 17, 33, 21],
        "T5": [10, 14, 36, 18],
        "T6": [7, 11, 15],
        "T7": [4, 8, 12],
        "T8": [1, 5, 9],
        "T9": [6, 2, 0],
        "T10": [3],
        "T11": [],
        "T12": [],
        "T13": []
    },
    26: {
        "T1": [23, 25, 27, 29],
        "T2": [20, 32, 24, 30, 22, 28],
        "T3": [17, 35, 21, 33, 19, 31],
        "T4": [14, 36, 18, 34, 16],
        "T5": [13, 11, 15],
        "T6": [8, 10, 12],
        "T7": [5, 7, 9],
        "T8": [4, 6, 2],
        "T9": [3, 1, 0],
        "T10": [],
        "T11": [],
        "T12": [],
        "T13": []
    },
    27: {
        "T1": [24, 26, 30],
        "T2": [21, 33, 25, 23, 29],
        "T3": [18, 36, 20, 32, 22, 28],
        "T4": [15, 35, 17, 31, 19],
        "T5": [34, 16, 14, 12],
        "T6": [9, 11, 13],
        "T7": [6, 8, 10],
        "T8": [3, 5, 7],
        "T9": [4, 0, 2],
        "T10": [1],
        "T11": [],
        "T12": [],
        "T13": []
    },
    28: {
        "T1": [25, 29, 31],
        "T2": [22, 34, 30, 26, 32],
        "T3": [19, 23, 27, 33, 35],
        "T4": [16, 20, 36, 24],
        "T5": [13, 17, 21],
        "T6": [10, 14, 18],
        "T7": [7, 11, 15],
        "T8": [4, 8, 12],
        "T9": [9, 5, 1],
        "T10": [0, 2, 6],
        "T11": [3],
        "T12": [],
        "T13": []
    },
    29: {
        "T1": [26, 28, 30, 32],
        "T2": [23, 35, 27, 33, 25, 31],
        "T3": [20, 22, 34, 24, 36],
        "T4": [19, 17, 21],
        "T5": [16, 14, 18],
        "T6": [11, 13, 15],
        "T7": [8, 10, 12],
        "T8": [7, 9, 5],
        "T9": [2, 4, 6],
        "T10": [0, 1, 3],
        "T11": [],
        "T12": [],
        "T13": []
    },
    30: {
        "T1": [27, 29, 33],
        "T2": [24, 36, 28, 26, 32],
        "T3": [21, 23, 35, 25, 31],
        "T4": [18, 20, 34, 22],
        "T5": [19, 15, 17],
        "T6": [12, 14, 16],
        "T7": [9, 11, 13],
        "T8": [6, 8, 10],
        "T9": [3, 5, 7],
        "T10": [0, 2, 4],
        "T11": [1],
        "T12": [],
        "T13": []
    },
    31: {
        "T1": [28, 32, 34],
        "T2": [25, 33, 29, 35],
        "T3": [22, 26, 36, 30],
        "T4": [19, 23, 27],
        "T5": [16, 20, 24],
        "T6": [13, 17, 21],
        "T7": [10, 14, 18],
        "T8": [7, 11, 15],
        "T9": [4, 8, 12],
        "T10": [9, 5, 1],
        "T11": [0, 2, 6],
        "T12": [3],
        "T13": []
    },
    32: {
        "T1": [29, 31, 33, 35],
        "T2": [26, 30, 36, 28, 34],
        "T3": [23, 25, 27],
        "T4": [20, 22, 24],
        "T5": [17, 19, 21],
        "T6": [14, 16, 18],
        "T7": [11, 13, 15],
        "T8": [8, 10, 12],
        "T9": [5, 7, 9],
        "T10": [2, 4, 6],
        "T11": [0, 1, 3],
        "T12": [],
        "T13": []
    },
    33: {
        "T1": [30, 32, 36],
        "T2": [27, 29, 35, 31],
        "T3": [24, 26, 28, 34],
        "T4": [21, 23, 25],
        "T5": [18, 20, 22],
        "T6": [15, 17, 19],
        "T7": [12, 14, 16],
        "T8": [9, 11, 13],
        "T9": [6, 8, 10],
        "T10": [3, 5, 7],
        "T11": [0, 2, 4],
        "T12": [1],
        "T13": []
    },
    34: {
        "T1": [31, 35],
        "T2": [28, 36, 32],
        "T3": [33, 25, 29],
        "T4": [22, 26, 30],
        "T5": [19, 23, 27],
        "T6": [16, 20, 24],
        "T7": [13, 17, 21],
        "T8": [10, 14, 18],
        "T9": [7, 11, 15],
        "T10": [4, 8, 12],
        "T11": [1, 5, 9],
        "T12": [0, 2, 6],
        "T13": [3]
    },
    35: {
        "T1": [32, 34, 36],
        "T2": [33, 29, 31],
        "T3": [26, 30, 28],
        "T4": [23, 25, 27],
        "T5": [22, 24, 20],
        "T6": [17, 19, 21],
        "T7": [14, 16, 18],
        "T8": [11, 13, 15],
        "T9": [8, 10, 12],
        "T10": [5, 7, 9],
        "T11": [2, 4, 6],
        "T12": [0, 1, 3],
        "T13": []
    },
    36: {
        "T1": [33, 35],
        "T2": [34, 30, 32],
        "T3": [27, 31, 29],
        "T4": [24, 26, 28],
        "T5": [21, 23, 25],
        "T6": [18, 20, 22],
        "T7": [15, 17, 19],
        "T8": [12, 14, 16],
        "T9": [9, 11, 13],
        "T10": [6, 8, 10],
        "T11": [3, 5, 7],
        "T12": [0, 2, 4],
        "T13": [1]
    }

}

# Variables globales
distance_counters = {f"T{i}": {"NS": 0, "Ec": 0, "Exmx": 0} for i in range(1, 14)}
distance_history = []
tx_numbers = []
# =========================================
# CADRE HISTORIQUE DES DISTANCES (√† gauche)
# ==========================================
# distance_frame est maintenant un enfant de main_group_frame
# Cr√©ation d'un cadre conteneur pour regrouper historique des distances et 3DEN
distance_tden_container = tk.Frame(main_group_frame, bg='darkgray')
distance_tden_container.grid(row=0, column=4, rowspan=3, padx=10, pady=5, sticky="nw")
# distance_frame est maintenant un enfant du conteneur
distance_frame = tk.Frame(distance_tden_container, bg='black', width=75, height=540, relief="ridge", borderwidth=4)
distance_frame.pack(pady=(0, 0))
distance_frame.pack_propagate(False)
# 20 labels pour afficher jusqu'√† 20 distances
distance_labels = []
for _ in range(20):
    label = tk.Label(distance_frame, text="", font=("Courier", 12, "bold"), bg="black", fg="yellow", anchor="w", padx=5)
    label.pack(fill="x", pady=1)
    distance_labels.append(label)
# =====================================================================
# BLOC UNIFI√â : Tableau des Distances + 3 Martyrs (VERSION GRID FINALE)
# =====================================================================
# --- CONTENEUR PRINCIPAL UNIFI√â ---
dist_martyrs_frame = tk.Frame(main_group_frame, bg='lightgray', borderwidth=3, relief="ridge")
dist_martyrs_frame.grid(row=0, column=6, rowspan=2, padx=10, pady=10, sticky="nw")
dist_martyrs_frame.columnconfigure(0, weight=1)
dist_martyrs_frame.rowconfigure(0, weight=1)
dist_martyrs_frame.rowconfigure(1, weight=1)
# --- SOUS-CADRE TABLEAU DES DISTANCES (en haut) ---
dist_main_frame = tk.Frame(dist_martyrs_frame, bg='Darkturquoise', borderwidth=2, relief="sunken")
dist_main_frame.grid(row=0, column=0, sticky="nsew", padx=2, pady=(2, 1))
dist_main_frame.columnconfigure(0, weight=1)
tk.Label(dist_main_frame, text="DISTANCE", font=("Arial", 12, "bold"),
         bg="darkblue", fg="white").grid(row=0, column=0, sticky="ew", pady=(0, 5))
# --- SOUS-CADRE 3 MARTYRS (en bas) ---
martyrs_frame = tk.Frame(dist_martyrs_frame, bg="lightyellow", borderwidth=2, relief="sunken")
martyrs_frame.grid(row=1, column=0, sticky="nsew", padx=2, pady=(1, 2))
martyrs_frame.columnconfigure(0, weight=1)
# Ent√™tes
header_bg = "navy"
header_fg = "white"
tk.Label(dist_main_frame, text="Tx", font=("Arial", 9, "bold"), bg=header_bg, fg=header_fg, width=4).grid(row=1,
                                                                                                          column=0,
                                                                                                          padx=2,
                                                                                                          pady=2)
tk.Label(dist_main_frame, text="NS", font=("Arial", 9, "bold"), bg=header_bg, fg=header_fg, width=4).grid(row=1,
                                                                                                          column=1,
                                                                                                          padx=2,
                                                                                                          pady=2)
tk.Label(dist_main_frame, text="Ec", font=("Arial", 9, "bold"), bg=header_bg, fg=header_fg, width=4).grid(row=1,
                                                                                                          column=2,
                                                                                                          padx=2,
                                                                                                          pady=2)
tk.Label(dist_main_frame, text="Exmx", font=("Arial", 9, "bold"), bg=header_bg, fg=header_fg, width=4).grid(row=1,
                                                                                                            column=3,
                                                                                                            padx=2,
                                                                                                            pady=2)
tk.Label(dist_main_frame, text="", bg="lightgray", width=2).grid(row=1, column=4)
# Variables d'affichage
tx_vars = {}
for i in range(1, 14):
    tx = f"T{i}"
    tx_vars[tx] = {
        "NS": tk.StringVar(value="0"),
        "Ec": tk.StringVar(value="0"),
        "Exmx": tk.StringVar(value="0")
    }
# Cr√©er les lignes
for i in range(1, 14):
    tx = f"T{i}"
    row = i + 1
    # Tx label
    tk.Label(dist_main_frame, text=tx, font=("Arial", 11, "bold"), bg="lightgray", fg="black").grid(row=row, column=0,
                                                                                                    padx=2, pady=1)
    # NS
    tk.Label(dist_main_frame, textvariable=tx_vars[tx]["NS"], font=("Arial", 12, "bold"), bg="white", fg="black",
             width=4, relief="sunken").grid(row=row, column=1, padx=2, pady=1)
    # Ec
    tk.Label(dist_main_frame, textvariable=tx_vars[tx]["Ec"], font=("Arial", 12, "bold"), bg="white", fg="black",
             width=4, relief="sunken").grid(row=row, column=2, padx=2, pady=1)
    # Exmx
    tk.Label(dist_main_frame, textvariable=tx_vars[tx]["Exmx"], font=("Arial", 12, "bold"), bg="white", fg="black",
             width=4, relief="sunken").grid(row=row, column=3, padx=2, pady=1)
    # Bouton Tx
    def make_command(t):
        def command():
            if history:
                ref_num = history[-1]
                if ref_num in distance_data and t in distance_data[ref_num]:
                    new_numbers = distance_data[ref_num][t]
                    # Ajouter les nouveaux num√©ros sans effacer les anciens
                    tx_numbers.extend(new_numbers)
                    # Supprimer les doublons tout en gardant l'ordre
                    seen = set()
                    unique_numbers = []
                    for n in tx_numbers:
                        if n not in seen:
                            seen.add(n)
                            unique_numbers.append(n)
                    # Mettre √† jour l'affichage
                    tx_display_var.set("TX\n" + "\n".join(map(str, unique_numbers)))
        return command
    tk.Button(dist_main_frame, text=tx, font=("Arial", 11, "bold"), width=3, height=1,
              bg="#E0E0E0", fg="navy", borderwidth=6, relief="raised", overrelief="ridge",
              command=make_command(tx)).grid(row=row, column=4, padx=2, pady=1)
# =============
# CADRE TX
# =============
tx_frame = tk.Frame(dist_main_frame, bg="white", borderwidth=1, relief="sunken", width=150, height=80)
tx_frame.grid(row=15, column=2, columnspan=3, padx=5, pady=5)
tx_frame.pack_propagate(False)
tx_display_var = tk.StringVar(value="TX")
tx_label = tk.Label(tx_frame, textvariable=tx_display_var, font=("Courier", 10, "bold"), bg="white", fg="blue",
                    anchor="nw", justify="left", padx=5, pady=3)
tx_label.pack(fill="both", expand=True)
# Bouton RSTx CORRIG√â - Reset uniquement le cadre TX
def reset_tx_display():
    global tx_numbers
    tx_numbers = []  # Vide la liste des num√©ros TX
    tx_display_var.set("TX")  # R√©initialise l'affichage
tk.Button(dist_main_frame, text="RSTx", font=("Arial", 11, "bold"), bg="orange", fg="white",borderwidth=6, width=5,
          relief="raised", command=reset_tx_display).grid(row=15, column=0, columnspan=2, pady=8)
# Bouton T3DT
def t3dt_command():
    global tx_numbers
    # R√©initialiser les num√©ros TX
    tx_numbers = []
    # R√©cup√©rer les 3 derni√®res distances de l'historique
    if len(distance_history) >= 3:
        last_three_distances = distance_history[-3:]
    else:
        last_three_distances = distance_history[:]  # Prendre toutes les disponibles
    # V√©rifier qu'il y a des distances √† traiter
    if not last_three_distances:
        messagebox.showinfo("Information", "Aucune distance dans l'historique")
        return
    # Pour chaque distance, r√©cup√©rer les num√©ros correspondants
    for dist in last_three_distances:
        if history:  # V√©rifier qu'il y a un historique de num√©ros
            ref_num = history[-1]  # Dernier num√©ro sorti
            if ref_num in distance_data and dist in distance_data[ref_num]:
                new_numbers = distance_data[ref_num][dist]
                # Ajouter les nouveaux num√©ros
                tx_numbers.extend(new_numbers)
    # V√©rifier qu'on a r√©cup√©r√© des num√©ros
    if not tx_numbers:
        messagebox.showinfo("Information", "Aucun num√©ro √† jouer pour les distances s√©lectionn√©es")
        return
    # Supprimer les doublons tout en gardant l'ordre
    seen = set()
    unique_numbers = []
    for n in tx_numbers:
        if n not in seen:
            seen.add(n)
            unique_numbers.append(n)
    # Mettre √† jour l'affichage TX
    tx_display_var.set("TX\n" + "\n".join(map(str, unique_numbers)))
    # Jouer automatiquement les num√©ros sur la table de jeu
    play_numbers(unique_numbers)
tk.Button(dist_main_frame, text="T3DT", font=("Arial", 10, "bold", ),
          bg="purple", fg="white", borderwidth=6, width=5, relief="raised",
          command=t3dt_command).grid(row=15, column=1, columnspan=1, pady=8, padx=(5, 0))
# Nouvelle fonction pour jouer les num√©ros TX avec REPET
def play_tx_numbers_with_repet():
    if not tx_numbers:
        messagebox.showinfo("Information", "Aucun num√©ro √† jouer pour TX.")
        return
    # R√©cup√©rer la valeur de REPET
    try:
        repetitions = int(repet_mollette.get())
    except ValueError:
        messagebox.showerror("Erreur", "La valeur de r√©p√©tition doit √™tre un nombre entier.")
        return
    # R√©cup√©rer la vitesse de clic
    try:
        click_speed = int(speed_entry.get())
    except ValueError:
        messagebox.showerror("Erreur", "La vitesse de clic doit √™tre un nombre entier.")
        return
    # Jouer chaque num√©ro avec r√©p√©tition
    for num in tx_numbers:
        if num in coordinates:
            x, y = coordinates[num]
            if x > 0 and y > 0:
                for _ in range(repetitions):
                    pyautogui.click(x, y)
                    time.sleep(click_speed / 1000)
            else:
                messagebox.showwarning("Avertissement", f"Coordonn√©es manquantes pour le num√©ro {num}.")
        else:
            messagebox.showwarning("Avertissement", f"Coordonn√©es manquantes pour le num√©ro {num}.")
# Bouton TX modifi√© pour utiliser la nouvelle fonction
tk.Button(dist_main_frame, text="TX", font=("Arial", 10, "bold"), bg="green", fg="white", borderwidth=6, width=8,
          relief="raised",
          command=play_tx_numbers_with_repet).grid(row=16, column=0, columnspan=5, pady=8)
# Fonction de mise √† jour DISTANCE
def update_distance(last_number):
    global tx_numbers
    if len(history) < 2:
        return
    prev_num = history[-2]
    current_num = last_number
    # Incr√©menter Ec pour TOUTES les Tx
    for tx in distance_counters:
        distance_counters[tx]["Ec"] += 1
        # MISE √Ä JOUR IMM√âDIATE DE Ecmx : miroir de Ec
        if distance_counters[tx]["Ec"] > distance_counters[tx]["Exmx"]:
            distance_counters[tx]["Exmx"] = distance_counters[tx]["Ec"]
    # Chercher current_num dans les tables de prev_num
    validated_Tx = None
    if prev_num in distance_data:
        for tx_name, tx_numbers_list in distance_data[prev_num].items():
            if current_num in tx_numbers_list:
                validated_Tx = tx_name
                break
    if validated_Tx:
        # R√©initialiser Ec √† 0 (NS est incr√©ment√©, mais Ec repart de 0)
        distance_counters[validated_Tx]["NS"] += 1
        distance_counters[validated_Tx]["Ec"] = 0
        # Historique
        distance_history.append(validated_Tx)
        if len(distance_history) > 20:
            distance_history.pop(0)
        # Afficher les 20 derni√®res distances (bas en haut)
        for i, tx in enumerate(reversed(distance_history)):
            if i < 20:
                distance_labels[i].config(text=f"  {tx}")
            else:
                distance_labels[i].config(text="")
        # Mettre √† jour l'affichage des compteurs
        for tx in distance_counters:
            tx_vars[tx]["NS"].set(str(distance_counters[tx]["NS"]))
            tx_vars[tx]["Ec"].set(str(distance_counters[tx]["Ec"]))
            tx_vars[tx]["Exmx"].set(str(distance_counters[tx]["Exmx"]))
    else:
        # M√™me si aucune Tx n'est trouv√©e, mettre √† jour l'affichage
        for tx in distance_counters:
            tx_vars[tx]["Ec"].set(str(distance_counters[tx]["Ec"]))


# ============================================================
# AJOUT SYST√àME FIN 2 DERN - VERSION ULTRA-VISIBLE ET D√âBOGU√âE
# ============================================================

# Tableau des finales
FINALES = {
    0: [0, 10, 20, 30],
    1: [1, 11, 21, 31],
    2: [2, 12, 22, 32],
    3: [3, 13, 23, 33],
    4: [4, 14, 24, 34],
    5: [5, 15, 25, 35],
    6: [6, 16, 26, 36],
    7: [7, 17, 27],
    8: [8, 18, 28],
    9: [9, 19, 29]
}

# Variables globales
fin2dern_ec = 0
fin2dern_last_finales = (None, None)  # Pour le bouton de jeu

# ========================
# AJOUT SYST√àME VFN - VERSION COMPL√àTE
# ========================

# Tableau VFN (Finales d√©ficientes)
VFN = {
    0: [0, 1, 3, 5, 8, 10, 11, 13, 14, 15, 16, 19, 20, 23, 24, 26, 27, 30, 31, 32, 33, 35, 36],
    1: [1, 2, 4, 5, 8, 9, 10, 11, 13, 14, 16, 19, 20, 21, 22, 23, 24, 25, 30, 31, 33, 36],
    2: [0, 2, 3, 4, 6, 7, 9, 12, 15, 17, 18, 19, 21, 22, 25, 26, 27, 28, 29, 31, 32, 34, 35],
    3: [0, 1, 3, 5, 6, 8, 10, 11, 12, 13, 16, 20, 23, 24, 26, 27, 30, 33, 35, 36],
    4: [1, 2, 4, 5, 6, 9, 10, 14, 15, 16, 17, 19, 20, 21, 24, 25, 27, 31, 33, 34],
    5: [0, 2, 3, 4, 5, 10, 12, 15, 16, 17, 19, 21, 23, 24, 25, 26, 28, 32, 34, 35],
    6: [0, 1, 3, 5, 6, 8, 10, 11, 13, 15, 16, 17, 23, 24, 26, 27, 30, 32, 33, 34, 35, 36],
    7: [2, 4, 6, 7, 8, 11, 12, 13, 17, 18, 19, 21, 22, 25, 27, 28, 29, 30, 34, 35, 36],
    8: [0, 1, 3, 5, 7, 8, 9, 10, 11, 12, 14, 16, 18, 20, 22, 23, 26, 28, 29, 30, 31, 33, 35, 36],
    9: [0, 1, 2, 3, 4, 7, 9, 12, 14, 15, 18, 19, 20, 21, 22, 25, 26, 28, 29, 31, 32, 35]
}

# Variable globale
vfn_var = tk.StringVar(value="VFN x")

# Cr√©er le cadre
# vfn_frame est maintenant un enfant de main_group_frame


# Bouton tr√®s visible - Fond gris par d√©faut, devient rouge quand VFN d√©tect√©


# Variable pour stocker le dernier VFN d√©tect√©
last_detected_vfn = None


# Fonction de mise √† jour
def update_vfn(last_number):
    global last_detected_vfn

    # Attendre 3 num√©ros
    if len(history) < 3:
        vfn_var.set("VFN x")
        vfn_button.config(bg="lightgray")
        last_detected_vfn = None
        return

    # R√©cup√©rer les 3 derniers num√©ros
    nums = history[-3:]
    finales = [n % 10 for n in nums]

    # Compter les occurrences
    from collections import Counter
    count = Counter(finales)
    valeurs = sorted(count.values())

    # V√©rifier deux identiques, une unique
    if valeurs == [1, 2]:
        unique_final = [f for f, c in count.items() if c == 1][0]
        vfn_var.set(f"VFN {unique_final}")  # Espace entre VFN et le num√©ro
        vfn_button.config(bg="red", fg="white", borderwidth=8)  # Rouge quand d√©tect√©
        last_detected_vfn = unique_final
        print(f"[VFN] ‚úÖ D√âTECT√â: VFN {unique_final}")
    else:
        vfn_var.set("VFN x")
        vfn_button.config(bg="lightgray", fg="black")
        last_detected_vfn = None


# Fonction de r√©initialisation MANUELLE (optionnelle)
def reset_vfn():
    global last_detected_vfn
    last_detected_vfn = None
    vfn_var.set("VFN x")
    vfn_button.config(bg="lightgray", fg="black")
    print("[VFN] R√©initialis√© manuellement")


# =============================================================
# AJOUT SYST√àME RECTANGULO - VERSION COMPL√àTE ET FONCTIONNELLE
# =============================================================

# Tableau RECTANGULO (couples ‚Üí s√©ries)
RECTANGULO_DATA = {
    (1, 14): [1, 14, 21, 34, 9, 29],
    (1, 16): [1, 16, 21, 36, 14, 34],
    (1, 21): [1, 14, 16, 21, 34, 36],
    (1, 34): [1, 14, 21, 34, 16, 36],
    (1, 36): [1, 16, 21, 36, 5, 25],
    (2, 4): [2, 4, 22, 24, 15, 35],
    (2, 22): [2, 4, 22, 24, 15, 35],
    (2, 24): [2, 4, 22, 24, 15, 35],
    (3, 12): [3, 12, 23, 32, 7, 27],
    (3, 23): [3, 12, 23, 32, 7, 27],
    (3, 32): [3, 12, 23, 32, 7, 27],
    (4, 15): [4, 15, 24, 35, 2, 22],
    (4, 22): [2, 4, 22, 24, 15, 35],
    (4, 24): [2, 4, 15, 22, 24, 35],
    (5, 16): [5, 16, 25, 36, 1, 21],
    (5, 25): [5, 16, 25, 36, 1, 21],
    (5, 36): [5, 16, 25, 36, 1, 21],
    (6, 13): [6, 13, 26, 33, 11, 31],
    (6, 26): [6, 13, 26, 33, 11, 31],
    (6, 33): [6, 13, 26, 33, 11, 31],
    (7, 12): [7, 12, 27, 32, 3, 23],
    (7, 27): [7, 12, 27, 32, 3, 23],
    (7, 32): [7, 12, 27, 32, 3, 23],
    (8, 10): [8, 10, 28, 30, 11, 31],
    (8, 11): [8, 11, 28, 31, 10, 30],
    (8, 28): [8, 10, 11, 28, 30, 31],
    (8, 30): [8, 10, 28, 30, 11, 31],
    (8, 31): [8, 11, 28, 31, 10, 30],
    (9, 14): [9, 14, 29, 34, 1, 21],
    (9, 29): [9, 14, 29, 34, 1, 21],
    (9, 34): [9, 14, 29, 34, 1, 21],
    (10, 28): [8, 10, 28, 30, 11, 31],
    (10, 30): [8, 10, 28, 30, 11, 31],
    (11, 13): [11, 13, 31, 33, 8, 28],
    (11, 28): [8, 11, 28, 31, 13, 33],
    (11, 31): [8, 11, 13, 28, 31, 33],
    (11, 33): [11, 13, 31, 33, 8, 28],
    (12, 23): [3, 12, 23, 32, 7, 27],
    (12, 27): [7, 12, 27, 32, 3, 23],
    (12, 32): [3, 7, 12, 23, 27, 32],
    (13, 26): [6, 13, 26, 33, 11, 31],
    (13, 31): [11, 13, 31, 33, 6, 26],
    (13, 33): [6, 11, 13, 26, 31, 33],
    (14, 21): [1, 14, 21, 34, 9, 29],
    (14, 29): [9, 14, 29, 34, 1, 21],
    (14, 34): [1, 9, 14, 21, 29, 34],
    (15, 24): [4, 15, 24, 35, 2, 22],
    (15, 35): [4, 15, 24, 35, 2, 22],
    (16, 21): [1, 16, 21, 36, 5, 25],
    (16, 25): [5, 16, 25, 36, 1, 21],
    (16, 36): [1, 5, 16, 21, 25, 36],
    (21, 34): [1, 14, 21, 34, 16, 36],
    (21, 36): [1, 16, 21, 36, 14, 34],
    (22, 24): [2, 4, 22, 24, 15, 35],
    (23, 32): [3, 12, 23, 32, 7, 27],
    (24, 35): [4, 15, 24, 35, 2, 22],
    (25, 36): [5, 16, 25, 36, 1, 21],
    (26, 33): [6, 13, 26, 33, 11, 31],
    (27, 32): [7, 12, 27, 32, 3, 23],
    (28, 30): [8, 10, 28, 30, 11, 31],
    (28, 31): [8, 11, 28, 31, 10, 30],
    (29, 34): [9, 14, 29, 34, 1, 21],
    (31, 33): [11, 13, 31, 33, 8, 28]
}

# ===========================================
# CADRE CHS (CHANCES SIMPLES)
# ===========================================

# Cr√©ation du cadre CHS
# Cr√©ation du cadre CHS √† l'int√©rieur du cadre parent (√† c√¥t√© du d√©versoir)
chs_frame = tk.Frame(grouped_frame, borderwidth=3, relief="ridge", bg="lightblue")
chs_frame.grid(row=0, column=1, padx=10, pady=10, sticky="nw")

# Titre du cadre
tk.Label(chs_frame, text="CH CS", font=("Arial", 11, "bold"), bg="lightblue").pack(pady=5)


# Fonction pour jouer une chance simple
def jouer_chance_simple(chance_type):
    if chance_type in coordinates:
        x, y = coordinates[chance_type]
        if x > 0 and y > 0:
            # R√©cup√©rer la vitesse de clic
            try:
                click_speed = int(speed_entry.get())
            except ValueError:
                messagebox.showerror("Erreur", "La vitesse de clic doit √™tre un nombre entier.")
                return

            # R√©cup√©rer le nombre de r√©p√©titions
            try:
                repetitions = int(repet_mollette.get())
            except ValueError:
                messagebox.showerror("Erreur", "La valeur de r√©p√©tition doit √™tre un nombre entier.")
                return

            # Cliquer sur la chance simple
            for _ in range(repetitions):
                pyautogui.click(x, y)
                time.sleep(click_speed / 1000)
        else:
            messagebox.showwarning("Avertissement", f"Coordonn√©es manquantes pour {chance_type}.")
    else:
        messagebox.showwarning("Avertissement", f"Coordonn√©es manquantes pour {chance_type}.")


# Cr√©ation des boutons dans la disposition demand√©e
button_frames = []
for i in range(6):  # 6 lignes
    frame = tk.Frame(chs_frame, bg="lightblue")
    frame.pack(pady=2)
    button_frames.append(frame)

# Premi√®re ligne: ROUGE - NOIR
tk.Button(button_frames[0], text="RGE", font=default_font, borderwidth=5, command=lambda: jouer_chance_simple("R")).pack(side="left",
                                                                                                            padx=5)
tk.Button(button_frames[0], text="NRE", font=default_font,  borderwidth=5, command=lambda: jouer_chance_simple("N")).pack(side="left",
                                                                                                           padx=5)

# Deuxi√®me ligne: PAIR - IMPAIR
tk.Button(button_frames[1], text="PAI", font=default_font,  borderwidth=5, command=lambda: jouer_chance_simple("PA")).pack(side="left",
                                                                                                            padx=5)
tk.Button(button_frames[1], text="IMP", font=default_font, borderwidth=5,  command=lambda: jouer_chance_simple("IP")).pack(
    side="left", padx=5)

# Troisi√®me ligne: MANQUE - PASSE
tk.Button(button_frames[2], text="MAQ", font=default_font,  borderwidth=5, command=lambda: jouer_chance_simple("Mq")).pack(
    side="left", padx=5)
tk.Button(button_frames[2], text="PAS", font=default_font,  borderwidth=5, command=lambda: jouer_chance_simple("Pss")).pack(
    side="left", padx=5)

# Quatri√®me ligne: DOUZAINE 1 - COLONNE 1
tk.Button(button_frames[3], text="DZ1", font=default_font, borderwidth=5,  command=lambda: jouer_chance_simple("D1")).pack(
    side="left", padx=5)
tk.Button(button_frames[3], text="CL1", font=default_font,  borderwidth=5, command=lambda: jouer_chance_simple("C1")).pack(
    side="left", padx=5)

# Cinqui√®me ligne: DOUZAINE 2 - COLONNE 2
tk.Button(button_frames[4], text="DZ2", font=default_font,  borderwidth=5, command=lambda: jouer_chance_simple("D2")).pack(
    side="left", padx=5)
tk.Button(button_frames[4], text="CL2", font=default_font,  borderwidth=5, command=lambda: jouer_chance_simple("C2")).pack(
    side="left", padx=5)

# Sixi√®me ligne: DOUZAINE 3 - COLONNE 3
tk.Button(button_frames[5], text="DZ3", font=default_font,  borderwidth=5, command=lambda: jouer_chance_simple("D3")).pack(
    side="left", padx=5)
tk.Button(button_frames[5], text="CL3", font=default_font,  borderwidth=5, command=lambda: jouer_chance_simple("C3")).pack(
    side="left", padx=5)

# ===================================
# CADRE RECTANGULO - Version stylis√©e
# ===================================

# Variables globales
rectangulo_series = []
persistent_green_numbers = set()
rectangulo_buttons = []
rectangulo_labels = []

# Cr√©ation du cadre principal
rectangulo_frame = tk.Frame(main_group_frame, bg="darkgreen", borderwidth=4, relief="raised")
rectangulo_frame.grid(row=0, column=8, padx=10, pady=10, sticky="nw")

# Titre du cadre
tk.Label(
    rectangulo_frame,
    text="RECTANGULO",
    font=("Arial", 12, "bold"),
    bg="darkgreen",
    fg="white",
    width=15,
    relief="flat"
).grid(row=0, column=0, columnspan=7, pady=(0, 5), sticky="ew")


# Fonction pour jouer tous les num√©ros du tableau RECTANGULO
def jouer_tous_numeros_rectangulo():
    """Joue tous les num√©ros pr√©sents dans le tableau RECTANGULO"""
    # R√©cup√©rer tous les num√©ros uniques de toutes les s√©ries
    tous_numeros = set()
    for series in rectangulo_series:
        tous_numeros.update(series)

    if not tous_numeros:
        messagebox.showinfo("BGT", "Aucun num√©ro √† jouer dans le tableau RECTANGULO.")
        return

    # Convertir en liste tri√©e
    tous_numeros = sorted(tous_numeros)

    # Jouer tous les num√©ros
    play_numbers(tous_numeros)



# --- üîπ FONCTION BGT4 : Jouer uniquement les 4 premiers num√©ros de chaque liste ---
def jouer_quatre_premiers():
    """
    Joue uniquement les 4 premiers num√©ros de chaque groupe actif dans rectangulo_lists.
    """
    numeros_a_jouer = []
    for i in range(12):
        if rectangulo_lists[i]:
            numeros_a_jouer.extend(rectangulo_lists[i][:4])  # 4 premiers max

    numeros_uniques = list(set(numeros_a_jouer))

    if not numeros_uniques:
        messagebox.showinfo("BGT4", "Aucun num√©ro √† jouer (listes vides).")
        return

    # R√©cup√©rer param√®tres
    try:
        repetitions = int(repet_mollette.get())
        click_speed = int(speed_entry.get()) / 1000
    except:
        messagebox.showerror("Erreur", "Valeur de r√©p√©tition ou vitesse invalide.")
        return

    # Jouer les num√©ros
    for num in numeros_uniques:
        if num in coordinates:
            x, y = coordinates[num]
            if x > 0 and y > 0:
                for _ in range(repetitions):
                    pyautogui.click(x, y)
                    time.sleep(click_speed)
        else:
            print(f"[ALERTE] Coordonn√©es manquantes pour {num}")

    print(f"[BGT4] Jou√©s : {len(numeros_uniques)} num√©ros (4 premiers par groupe).")





# --- üîß CONTENEUR UNIQUE POUR LES BOUTONS BGT / BGT4 / RES-BG ---
button_container = tk.Frame(rectangulo_frame, bg="darkgreen")
button_container.grid(row=1, column=0, padx=0, pady=(0, 2), sticky="w")

# Bouton BGT
btn_bgt = tk.Button(
    button_container,
    text="BGT",
    font=("Arial", 10, "bold"),
    bg="#FFD700",
    fg="black",
    width=4,
    height=2,
    relief="raised",
    overrelief="solid",
    borderwidth=6,
    command=jouer_tous_numeros_rectangulo
)
btn_bgt.pack(side="left", padx=(0, 2))

# Bouton BGT4
btn_bgt4 = tk.Button(
    button_container,
    text="BGT4",
    font=("Arial", 10, "bold"),
    bg="#FFA500",
    fg="black",
    width=6,
    height=2,
    relief="raised",
    overrelief="solid",
    borderwidth=6,
    command=jouer_quatre_premiers
)
btn_bgt4.pack(side="left", padx=2)



# Cr√©er 13 lignes (d√©cal√©es d'une ligne √† cause du bouton BGT)
for i in range(13):
    frame_row = tk.Frame(rectangulo_frame, bg="lightgray")
    frame_row.grid(row=i + 2, column=0, columnspan=7, sticky="w", pady=1)  # row=i+2 pour laisser la place au bouton BGT

    # Bouton RC
    btn = tk.Button(
        frame_row,
        text=f"RC{i + 1}",
        font=("Arial", 11, "bold"),
        bg="#C8F0C8",
        fg="black",
        width=4,
        relief="raised",
        overrelief="solid"
    )
    btn.grid(row=0, column=0, padx=(0, 5))
    rectangulo_buttons.append(btn)

    # 6 √©tiquettes pour les num√©ros
    row_labels = []
    for j in range(6):
        lbl = tk.Label(
            frame_row,
            text="",
            font=("Arial", 11, "bold"),
            width=4,
            height=1,
            bg="white",
            fg="black",
            relief="sunken"
        )
        lbl.grid(row=0, column=j + 1, padx=1)
        row_labels.append(lbl)
    rectangulo_labels.append(row_labels)


# Fonction de mise √† jour
def update_rectangulo(last_number=None):
    global rectangulo_series, persistent_green_numbers

    # Si aucun num√©ro n'est fourni, utiliser le dernier de l'historique
    if last_number is None and history:
        last_number = history[-1]
    elif last_number is None:
        last_number = 0

    last_numbers = history[-8:] if len(history) >= 8 else history

    if len(last_numbers) < 2:
        for i in range(13):
            rectangulo_buttons[i].config(state="disabled", command=None)
            for j in range(6):
                rectangulo_labels[i][j].config(text="", bg="white", fg="black")
        rectangulo_series = []
        return

    # Sauvegarder les anciennes s√©ries
    old_series_flat = {num for series in rectangulo_series for num in series}

    # G√©n√©rer les nouvelles s√©ries
    new_series = []
    from itertools import combinations
    for a, b in combinations(last_numbers, 2):
        couple = tuple(sorted((a, b)))
        if couple in RECTANGULO_DATA:
            series = RECTANGULO_DATA[couple]
            if series not in rectangulo_series and series not in new_series:
                new_series.append(series)

    # Ajouter les nouvelles s√©ries
    for series in new_series:
        if len(rectangulo_series) < 13:
            rectangulo_series.append(series)
    rectangulo_series = rectangulo_series[:13]

    # Mettre √† jour les num√©ros persistants
    if last_number in old_series_flat:
        persistent_green_numbers.add(last_number)

    # Afficher les s√©ries
    for i in range(13):
        if i < len(rectangulo_series):
            series = rectangulo_series[i]
            rectangulo_buttons[i].config(
                state="normal",
                command=lambda s=series: play_numbers(s)
            )
            for j in range(6):
                num = series[j]
                label = rectangulo_labels[i][j]
                label.config(text=str(num))
                if num in persistent_green_numbers:
                    label.config(bg="green", fg="white")
                else:
                    label.config(bg="white", fg="black")
        else:
            rectangulo_buttons[i].config(state="disabled", command=None)
            for j in range(6):
                rectangulo_labels[i][j].config(text="", bg="white", fg="black")


# ===== AJOUT DES 2 BOUTONS EN T√äTE =====

voisin_button = tk.Button(
    martyrs_frame,  # On utilise martyrs_frame au lieu de voisin_frame
    text="JEU\nVOIS",
    font=("Arial", 10, "bold"),
    bg="Orange",
    fg="black",
    borderwidth=7,
    width=6,
    height=2,
    command=lambda: jouer_voisin() if jeu_voisin_active else messagebox.showinfo("JEU VOISIN", "Aucune alerte active.")
)
voisin_button.grid(row=0, column=0, padx=5, pady=5, sticky="nw")  # row=0 pour le placer en t√™te

# --- CADRE PARENT POUR LES DEUX BOUTONS (positionn√© comme vfn_button) ---
buttons_frame = tk.Frame(
    martyrs_frame,
    bg="lightgray",  # Fond optionnel pour mieux voir le cadre
    borderwidth=2,
    relief="groove"
)
buttons_frame.grid(row=1, column=0, padx=5, pady=5, sticky="nw")  # M√™me position que vfn_button

# --- Bouton VFN (dans le cadre parent) ---
vfn_button = tk.Button(
    buttons_frame,  # Plac√© dans le cadre parent
    textvariable=vfn_var,
    font=("Arial", 12, "bold"),
    bg="lightgray",
    fg="black",
    width=12,
    height=2,
    command=lambda: play_numbers(VFN[last_detected_vfn]) if last_detected_vfn is not None else None
)
vfn_button.pack(side="left", padx=5, pady=5)  # Plac√© √† gauche dans le cadre parent




# Titre du bloc LIGTNE : 6794
tk.Label(
    martyrs_frame,
    text="LES 3 MARTYRS",
    font=("Arial", 10, "bold"),
    bg="darkgray",
    fg="yellow"
).grid(row=0, column=0, columnspan=2, pady=(0, 5))

# --- Cadre parent pour regrouper les 6 sous-cadres ---
group_frame = tk.Frame(martyrs_frame, bg="lightgray", borderwidth=1, relief="raised")
group_frame.grid(row=2, column=0, columnspan=2, padx=5, pady=5, sticky="ew")

# --- D√©finition des variables StringVar (√† placer en haut de ton code, apr√®s l'initialisation de tk.Tk()) ---
last_doublette = tk.StringVar(value="--")
mise_counter = tk.StringVar(value="0")
tr_counter = tk.StringVar(value="0")
adjacent_number_1 = tk.StringVar(value="--")

# --- Sous-cadres √† gauche (APPL, FUT KAC, FCCG) ---
# Sous-cadre APPL
appl_subframe = tk.Frame(group_frame, bg="lightgray", borderwidth=1, relief="raised")
appl_subframe.grid(row=0, column=0, padx=2, pady=2, sticky="ew")
appl_button = tk.Button(
    appl_subframe,
    text="APPL",
    font=("Arial", 9, "bold"),
    bg="#D4AF37",  # Or
    fg="black",
    borderwidth=3,
    width=6,
    command=lambda: play_numbers(appl_numbers)
)
appl_button.grid(row=0, column=0, padx=2, pady=2)
appl_label = tk.Label(
    appl_subframe,
    text="",
    font=("Courier", 9, "bold"),
    bg="black",
    fg="yellow",
    width=10,
    height=1,
    relief="sunken",
    anchor="w",
    padx=2
)
appl_label.grid(row=0, column=1, padx=2, pady=2)

# Sous-cadre FUT KAC
fut_subframe = tk.Frame(group_frame, bg="lightgray", borderwidth=1, relief="raised")
fut_subframe.grid(row=1, column=0, padx=2, pady=2, sticky="ew")
fut_button = tk.Button(
    fut_subframe,
    text="FUT KAC",
    font=("Arial", 9, "bold"),
    bg="#8B008B",  # Violet
    fg="white",
    borderwidth=3,
    width=6,
    command=lambda: play_numbers(fut_numbers)
)
fut_button.grid(row=0, column=0, padx=2, pady=2)
fut_label = tk.Label(
    fut_subframe,
    text="",
    font=("Courier", 9, "bold"),
    bg="black",
    fg="cyan",
    width=10,
    height=1,
    relief="sunken",
    anchor="w",
    padx=2
)
fut_label.grid(row=0, column=1, padx=2, pady=2)

# Sous-cadre FCCG
fccg_subframe = tk.Frame(group_frame, bg="lightgray", borderwidth=1, relief="raised")
fccg_subframe.grid(row=2, column=0, padx=2, pady=2, sticky="ew")
fccg_button = tk.Button(
    fccg_subframe,
    text="FCCG",
    font=("Arial", 9, "bold"),
    bg="#FF6347",  # Rouge tomate
    fg="white",
    borderwidth=3,
    width=6,
    command=lambda: play_numbers(fccg_numbers)
)
fccg_button.grid(row=0, column=0, padx=2, pady=2)
fccg_label = tk.Label(
    fccg_subframe,
    text="",
    font=("Courier", 9, "bold"),
    bg="black",
    fg="white",
    width=10,
    height=1,
    relief="sunken",
    anchor="w",
    padx=2
)
fccg_label.grid(row=0, column=1, padx=2, pady=2)

# --- Sous-cadres √† droite (RDBL, NUM ADJ, MISE-TR) ---
# Sous-cadre RDBL
rdb_subframe = tk.Frame(group_frame, bg="lightgray", borderwidth=1, relief="raised")
rdb_subframe.grid(row=0, column=1, padx=2, pady=2, sticky="ew")
tk.Label(rdb_subframe, text="RDBL", font=("Arial", 9, "bold"), bg="lightgray").grid(row=0, column=0, padx=2, pady=2)
rdb_label = tk.Label(rdb_subframe, textvariable=last_doublette, font=("Arial", 12, "bold"), width=3, bg="white")
rdb_label.grid(row=0, column=1, padx=2, pady=2)

# Sous-cadre NUM ADJ
adjacent_subframe = tk.Frame(group_frame, bg="lightgray", borderwidth=1, relief="raised")
adjacent_subframe.grid(row=1, column=1, padx=2, pady=2, sticky="ew")

# Label pour le titre "NUM ADJ"
tk.Label(adjacent_subframe, text="NUM ADJ", font=("Arial", 9, "bold"), bg="lightgray").grid(row=0, column=0, padx=2, pady=2)

# Label pour le premier num√©ro adjacent
adjacent_label_1 = tk.Label(adjacent_subframe, textvariable=adjacent_number_1, font=("Arial", 18, "bold"), width=3, bg="white")
adjacent_label_1.grid(row=0, column=1, padx=2, pady=2)

# Label pour le deuxi√®me num√©ro adjacent
adjacent_label_2 = tk.Label(adjacent_subframe, textvariable=adjacent_number_2, font=("Arial", 18, "bold"), width=3, bg="white")
adjacent_label_2.grid(row=0, column=2, padx=2, pady=2)



# Sous-cadre MISE-TR
mise_tr_subframe = tk.Frame(group_frame, bg="lightgray", borderwidth=1, relief="raised")
mise_tr_subframe.grid(row=2, column=1, padx=2, pady=2, sticky="ew")
tk.Label(mise_tr_subframe, text="Mise", font=("Arial", 9, "bold"), bg="lightgray").grid(row=0, column=0, padx=2, pady=2)
mise_label = tk.Label(mise_tr_subframe, textvariable=mise_counter, font=("Arial", 13, "bold"), width=3, bg="white")
mise_label.grid(row=0, column=1, padx=2, pady=2)
tk.Label(mise_tr_subframe, text="Tr", font=("Arial", 9, "bold"), bg="lightgray").grid(row=0, column=2, padx=2, pady=2)
tr_label = tk.Label(mise_tr_subframe, textvariable=tr_counter, font=("Arial", 13, "bold"), width=3, bg="white")
tr_label.grid(row=0, column=3, padx=2, pady=2)








# ===========================================================
# AJOUT SYST√àME JEU DU VOISIN - VERSION CORRECTE ET COMPL√àTE
# ===========================================================

# S√©ries VOISIN (num√©ros √† surveiller)
VOISIN_NUMBERS = {0, 2, 3, 4, 7, 12, 15, 18, 19, 21, 22, 25, 26, 28, 29, 32, 35}

# Variables globales
jeu_voisin_active = False  # Indique si l'alerte est active

# --- Cr√©ation du cadre principal pour JEU VOISIN ---

# --- Bouton "JEU VOIS" ---

# --- Label d'√©tat (optionnel, pour debug) ---
voisin_status = tk.Label(
    martyrs_frame,
    text="",
    font=("Courier", 8),
    bg="Lightgray",
    width=4,
    height=1
)
voisin_status.grid(row=0, column=2, padx=5, pady=5)  # Chang√© √† column=2 pour √©viter le chevauchement


# --- Fonction pour jouer les num√©ros VOISIN ---
def jouer_voisin():
    if jeu_voisin_active:
        try:
            click_speed = int(speed_entry.get())
        except ValueError:
            messagebox.showerror("Erreur", "Vitesse de clic invalide.")
            return
        played = []
        for num in VOISIN_NUMBERS:
            if num in coordinates:
                x, y = coordinates[num]
                if x > 0 and y > 0:
                    pyautogui.click(x, y)
                    played.append(num)
                    time.sleep(click_speed / 1000)
        print(f"[JEU VOISIN] Num√©ros jou√©s : {sorted(played)}")
    else:
        messagebox.showinfo("JEU VOISIN", "Pas d'alerte active. Aucun num√©ro jou√©.")


# --- Fonction de mise √† jour ---
def update_jeu_voisin(last_number):
    global jeu_voisin_active

    # On a besoin de 2 num√©ros au moins
    if len(history) < 2:
        reset_jeu_voisin()
        return

    prev_last = history[-2]  # Avant-dernier
    current = history[-1]  # Dernier

    # V√©rifier les deux conditions
    condition_prev = 13 <= prev_last <= 24
    condition_curr = 1 <= current <= 12

    if condition_prev and condition_curr:
        # ‚úÖ Les deux conditions sont remplies ‚Üí ALERTE ACTIVE
        jeu_voisin_active = True
        voisin_button.config(bg="red", fg="white",borderwidth=8)
        voisin_status.config(text="ACTIVE")
    else:
        # ‚ùå Conditions non remplies ‚Üí d√©sactiver l'alerte
        reset_jeu_voisin()


# --- Fonction de r√©initialisation ---
def reset_jeu_voisin():
    global jeu_voisin_active
    jeu_voisin_active = False
    voisin_button.config(bg="lightgray", fg="black")
    voisin_status.config(text="")


# ==========================================================================
# AJOUT SYST√àME : S√âRIES A/B + √âCARTS D√âCAL√âS (√âcSD) - VERSION COMPL√àTE ET MODIFI√âE
# ==========================================================================

# D√©finition des 24 s√©ries
AB_SERIES = {
    "A1": {0, 26, 32}, "B1": {5, 10, 23, 24},
    "A2": {15, 4, 19}, "B2": {33, 16, 1},
    "A3": {2, 21, 25}, "B3": {14, 20, 31},
    "A4": {34, 17, 6}, "B4": {22, 9, 18},
    "A5": {13, 27, 36}, "B5": {7, 29, 28},
    "A6": {30, 11, 8}, "B6": {35, 12, 3},
    "A7": {5, 10, 23, 24}, "B7": {0, 26, 32},
    "A8": {33, 16, 1}, "B8": {15, 4, 19},
    "A9": {14, 20, 31}, "B9": {2, 21, 25},
    "A10": {22, 9, 18}, "B10": {34, 17, 6},
    "A11": {7, 29, 28}, "B11": {13, 27, 36},
    "A12": {35, 12, 3}, "B12": {30, 11, 8}
}

# Variables globales (pr√©fix√©es AB_)
ab_ns_values = {serie: 0 for serie in AB_SERIES.keys()}
ab_ec_values = {serie: 0 for serie in AB_SERIES.keys()}
ab_ecmx_values = {serie: 0 for serie in AB_SERIES.keys()}

# √âcarts de S√©rie D√©cal√©e (A ‚Üí B)
ab_ecsd_values = {f"A{i}/B{i}": 0 for i in range(1, 13)}  # √âcart actuel A‚ÜíB
ab_ecsdmax_values = {f"A{i}/B{i}": 0 for i in range(1, 13)}  # √âcart max A‚ÜíB

# Suivi du dernier num√©ro
ab_last_number_was_A = {f"A{i}": False for i in range(1, 13)}

# R√©f√©rence √† la fen√™tre secondaire
ab_window = None
last_window_position = None  # Pour sauvegarder la position

# Couleurs du style
BG_COLOR = "black"
FG_COLOR = "white"
BUTTON_BG = "gray20"
BUTTON_ACTIVE = "gray30"

# Couleurs sp√©cifiques pour les effets
HIGHLIGHT_ECA_BG = "darkblue"   # Fond bleu fonc√© quand Eca = 0
HIGHLIGHT_B_BG = "darkgreen"    # Fond vert fonc√© pour la s√©rie B associ√©e


# Fonction pour jouer les num√©ros d'une s√©rie
def play_numbers(numbers):
    """Joue les num√©ros d'une s√©rie sur la table de jeu"""
    for num in numbers:
        if num in coordinates:
            x, y = coordinates[num]
            pyautogui.click(x, y)
            time.sleep(0.1)


def jouer_ab_series():
    """Joue tous les num√©ros des S√âRIES A qui ont NS = 0"""
    global AB_SERIES, ab_ns_values

    series_a = [f"A{i}" for i in range(1, 13)]
    numeros_a_jouer = set()

    for serie_name in series_a:
        if ab_ns_values[serie_name] == 0:
            numeros_a_jouer.update(AB_SERIES[serie_name])

    if not numeros_a_jouer:
        print("[AB] Aucun num√©ro √† jouer.")
        return

    print(f"[AB] üî• Joue les num√©ros : {sorted(numeros_a_jouer)}")
    play_numbers(sorted(numeros_a_jouer))


def check_ab_alert():
    """Met √† jour l'√©tat du bouton JOUER A/B"""
    global jouer_ab_button

    series_a = [f"A{i}" for i in range(1, 13)]
    ns_zero_count = sum(1 for s in series_a if ab_ns_values[s] == 0)

    print(f"[AB] S√©ries A restantes √† NS=0 : {ns_zero_count}")

    if 1 <= ns_zero_count <= 10:
        jouer_ab_button.config(bg="red", fg="white", state="normal")
        jouer_ab_button.pack(pady=(0, 0))
    else:
        jouer_ab_button.config(bg="gray", fg="white", state="disabled")
        jouer_ab_button.pack_forget()


# FONCTION ESSENTIELLE QUI MANQUAIT !
def update_ab_series(last_number):
    """Met √† jour les statistiques des s√©ries A/B"""
    # Incr√©menter tous les √©carts
    for serie in AB_SERIES.keys():
        ab_ec_values[serie] += 1
        if ab_ec_values[serie] > ab_ecmx_values[serie]:
            ab_ecmx_values[serie] = ab_ec_values[serie]

    # R√©initialiser les √©carts si le num√©ro fait partie d'une s√©rie
    for serie_name, serie_numbers in AB_SERIES.items():
        if last_number in serie_numbers:
            ab_ns_values[serie_name] += 1
            ab_ec_values[serie_name] = 0

    # Gestion des √©carts d√©cal√©s A ‚Üí B
    for i in range(1, 13):
        a_name = f"A{i}"
        b_name = f"B{i}"
        combi = f"A{i}/B{i}"

        if ab_last_number_was_A[a_name]:
            if last_number in AB_SERIES[b_name]:
                ab_ecsd_values[combi] = 0
            else:
                ab_ecsd_values[combi] += 1
                if ab_ecsd_values[combi] > ab_ecsdmax_values[combi]:
                    ab_ecsdmax_values[combi] = ab_ecsd_values[combi]

        ab_last_number_was_A[a_name] = False

        if last_number in AB_SERIES[a_name]:
            ab_last_number_was_A[a_name] = True

    # Afficher le tableau dans la console
    print_ab_table()

    # METTRE √Ä JOUR LA FEN√äTRE SI ELLE EST OUVERTE
    update_ab_window()


# FONCTION ESSENTIELLE QUI MANQUAIT !
def print_ab_table():
    """Affiche le tableau A/B dans la console"""
    headers = [
        "NSA", "S√©ries A", "Eca", "√âcamx",
        "NSB", "S√©ries B", "Ecb", "√âcbmx",
        "COMBI", "√âcSD", "√âcSDmax"
    ]
    widths = [4, 12, 5, 7, 4, 12, 5, 7, 8, 6, 9]
    header_line = " ".join(f"{h:^{w}}" for h, w in zip(headers, widths))
    separator = "-" * len(header_line)

    print("\n" + separator)
    print(header_line)
    print(separator)

    for i in range(1, 13):
        a = f"A{i}"
        b = f"B{i}"
        combi = f"A{i}/B{i}"
        ns_a = ab_ns_values[a]
        ec_a = ab_ec_values[a]
        ecmx_a = ab_ecmx_values[a]
        ns_b = ab_ns_values[b]
        ec_b = ab_ec_values[b]
        ecmx_b = ab_ecmx_values[b]
        ecsd = ab_ecsd_values[combi]
        ecsdmax = ab_ecsdmax_values[combi]
        a_nums = ",".join(map(str, sorted(AB_SERIES[a])))
        b_nums = ",".join(map(str, sorted(AB_SERIES[b])))

        line = (
            f"{ns_a:^{widths[0]}} "
            f"{a_nums:^{widths[1]}} "
            f"{ec_a:^{widths[2]}} "
            f"{ecmx_a:^{widths[3]}} "
            f"{ns_b:^{widths[4]}} "
            f"{b_nums:^{widths[5]}} "
            f"{ec_b:^{widths[6]}} "
            f"{ecmx_b:^{widths[7]}} "
            f"{combi:^{widths[8]}} "
            f"{ecsd:^{widths[9]}} "
            f"{ecsdmax:^{widths[10]}}"
        )
        print(line)
    print(separator)


def reset_ab_series():
    """R√©initialise toutes les statistiques A/B"""
    global ab_ns_values, ab_ec_values, ab_ecmx_values, ab_ecsd_values, ab_ecsdmax_values, ab_last_number_was_A
    ab_ns_values = {serie: 0 for serie in AB_SERIES.keys()}
    ab_ec_values = {serie: 0 for serie in AB_SERIES.keys()}
    ab_ecmx_values = {serie: 0 for serie in AB_SERIES.keys()}
    ab_ecsd_values = {f"A{i}/B{i}": 0 for i in range(1, 13)}
    ab_ecsdmax_values = {f"A{i}/B{i}": 0 for i in range(1, 13)}
    ab_last_number_was_A = {f"A{i}": False for i in range(1, 13)}
    print("\n[AB SERIES] Syst√®me r√©initialis√©.")

    # METTRE √Ä JOUR LA FEN√äTRE SI ELLE EST OUVERTE
    update_ab_window()


# Fonction pour mettre √† jour la fen√™tre A/B si elle est ouverte
def update_ab_window():
    """Met √† jour la fen√™tre A/B avec coloration dynamique sur Eca = 0"""
    global ab_window, last_window_position
    if not ab_window or not ab_window.winfo_exists():
        return

    try:
        last_window_position = (ab_window.winfo_x(), ab_window.winfo_y())
    except:
        pass

    ab_window.destroy()
    create_ab_window(*last_window_position)


# Fonction pour cr√©er la fen√™tre
def create_ab_window(x=None, y=None):
    """Cr√©e la fen√™tre A/B avec position optionnelle"""
    global ab_window
    ab_window = tk.Toplevel(root)
    ab_window.title("üìä S√âRIES A/B ‚Äî TABLEAU DE SURVEILLANCE LIVE")
    ab_window.configure(bg=BG_COLOR)
    ab_window.geometry("1200x750")
    ab_window.resizable(True, True)

    if x is not None and y is not None:
        ab_window.geometry(f"+{x}+{y}")
    elif last_window_position:
        x, y = last_window_position
        ab_window.geometry(f"+{x}+{y}")

    # Titre
    title_label = tk.Label(
        ab_window,
        text="üéØ S√âRIES A/B ‚Äî SURVEILLANCE EN TEMPS R√âEL",
        font=("Arial", 16, "bold"),
        bg=BG_COLOR,
        fg="cyan",
        relief="raised",
        bd=3,
        pady=10
    )
    title_label.pack(pady=15, padx=20, fill="x")

    # Sous-titre
    tk.Label(
        ab_window,
        text="Double-cliquez sur un bouton pour jouer ses num√©ros",
        font=("Arial", 10, "italic"),
        bg=BG_COLOR,
        fg="lightgray"
    ).pack(pady=5)

    # Frame principal
    main_frame = tk.Frame(ab_window, bg=BG_COLOR)
    main_frame.pack(fill="both", expand=True, padx=15, pady=10)
    main_frame.grid_rowconfigure(0, weight=1)
    main_frame.grid_columnconfigure(0, weight=1)

    # Frame tableau
    table_frame = tk.Frame(main_frame, bg=BG_COLOR, relief="sunken", bd=2)
    table_frame.grid(row=0, column=0, sticky="nsew", padx=10, pady=10)
    table_frame.grid_rowconfigure(1, weight=1)
    table_frame.grid_columnconfigure(0, weight=1)

    # ========== EN-T√äTES DES COLONNES ==========
    headers = ["NSA", "S√©ries A", "Eca", "√âcamx", "NSB", "S√©ries B", "Ecb", "√âcbmx", "COMBI", "√âcSD", "√âcSDmax"]
    header_frame = tk.Frame(table_frame, bg=BG_COLOR)
    header_frame.grid(row=0, column=0, sticky="ew", padx=5, pady=(10, 5))

    col_widths = [6, 16, 6, 8, 6, 16, 6, 8, 10, 8, 10]

    for i, (header, width) in enumerate(zip(headers, col_widths)):
        lbl = tk.Label(
            header_frame,
            text=header,
            font=("Courier New", 12, "bold"),
            bg=BG_COLOR,
            fg="yellow",
            width=width,
            borderwidth=2,
            relief="raised",
            padx=3,
            pady=3,
            anchor="center"
        )
        lbl.grid(row=0, column=i, padx=1, pady=2, sticky="ew")
        header_frame.grid_columnconfigure(i, weight=0)
        header_frame.grid_columnconfigure(i, minsize=width * 10)

    # ========== CADRE AVEC CANVAS ET SCROLLBAR ==========
    canvas_frame = tk.Frame(table_frame, bg=BG_COLOR)
    canvas_frame.grid(row=1, column=0, sticky="nsew", padx=5, pady=5)
    canvas_frame.grid_rowconfigure(0, weight=1)
    canvas_frame.grid_columnconfigure(0, weight=1)

    canvas = tk.Canvas(canvas_frame, bg=BG_COLOR, highlightthickness=0)
    scrollbar = tk.Scrollbar(canvas_frame, orient="vertical", command=canvas.yview)
    scrollable_frame = tk.Frame(canvas, bg=BG_COLOR)

    scrollable_frame.bind(
        "<Configure>",
        lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
    )

    canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
    canvas.configure(yscrollcommand=scrollbar.set)

    canvas.grid(row=0, column=0, sticky="nsew")
    scrollbar.grid(row=0, column=1, sticky="ns")
    canvas_frame.grid_columnconfigure(0, weight=1)
    canvas_frame.grid_rowconfigure(0, weight=1)

    # ========== LIGNES DE DONN√âES ==========
    for i in range(1, 13):
        a = f"A{i}"
        b = f"B{i}"
        combi = f"A{i}/B{i}"

        ns_a = ab_ns_values[a]
        ec_a = ab_ec_values[a]
        ecmx_a = ab_ecmx_values[a]
        ns_b = ab_ns_values[b]
        ec_b = ab_ec_values[b]
        ecmx_b = ab_ecmx_values[b]
        ecsd = ab_ecsd_values[combi]
        ecsdmax = ab_ecsdmax_values[combi]
        a_nums = ",".join(map(str, sorted(AB_SERIES[a])))
        b_nums = ",".join(map(str, sorted(AB_SERIES[b])))

        line_frame = tk.Frame(scrollable_frame, bg=BG_COLOR)
        line_frame.pack(fill="x", pady=2, padx=5)

        for col_idx in range(11):
            line_frame.grid_columnconfigure(col_idx, weight=0)
            line_frame.grid_columnconfigure(col_idx, minsize=col_widths[col_idx] * 10)

        # === COLONNE 1: NSA ===
        tk.Label(
            line_frame,
            text=f"{ns_a:>3}",
            font=("Courier New", 12, "bold"),
            bg=BG_COLOR,
            fg=FG_COLOR,
            width=col_widths[0],
            anchor="center"
        ).grid(row=0, column=0, padx=1, sticky="ew")

        # === COLONNE 2: S√âRIES A ===
        btn_a = tk.Button(
            line_frame,
            text=a_nums,
            font=("Courier New", 12, "bold"),
            bg=BUTTON_BG,
            fg="lightgreen",
            width=col_widths[1],
            relief="raised",
            activebackground="green",
            activeforeground="white",
            command=lambda s=AB_SERIES[a]: play_numbers(s),
            anchor="center",
            padx=3,
            pady=2
        )
        btn_a.grid(row=0, column=1, padx=1, sticky="ew")

        # === COLONNE 3: Eca ===
        eca_bg = HIGHLIGHT_ECA_BG if ec_a == 0 else BG_COLOR
        eca_fg = "white" if ec_a == 0 else FG_COLOR
        eca_label = tk.Label(
            line_frame,
            text=f"{ec_a:>3}",
            font=("Courier New", 12, "bold"),
            bg=eca_bg,
            fg=eca_fg,
            width=col_widths[2],
            anchor="center"
        )
        eca_label.grid(row=0, column=2, padx=1, sticky="ew")

        # === COLONNE 4: √âcamx ===
        tk.Label(
            line_frame,
            text=f"{ecmx_a:>4}",
            font=("Courier New", 12, "bold"),
            bg=BG_COLOR,
            fg="orange",
            width=col_widths[3],
            anchor="center"
        ).grid(row=0, column=3, padx=1, sticky="ew")

        # === COLONNE 5: NSB ===
        tk.Label(
            line_frame,
            text=f"{ns_b:>3}",
            font=("Courier New", 12, "bold"),
            bg=BG_COLOR,
            fg=FG_COLOR,
            width=col_widths[4],
            anchor="center"
        ).grid(row=0, column=4, padx=1, sticky="ew")

        # === COLONNE 6: S√âRIES B ===
        b_bg = HIGHLIGHT_B_BG if ec_a == 0 else BUTTON_BG
        b_fg = "white" if ec_a == 0 else "lightblue"
        btn_b = tk.Button(
            line_frame,
            text=b_nums,
            font=("Courier New", 12, "bold"),
            bg=b_bg,
            fg=b_fg,
            width=col_widths[5],
            relief="raised",
            activebackground="blue",
            activeforeground="white",
            command=lambda s=AB_SERIES[b]: play_numbers(s),
            anchor="center",
            padx=3,
            pady=2
        )
        btn_b.grid(row=0, column=5, padx=1, sticky="ew")

        # === COLONNE 7: Ecb ===
        tk.Label(
            line_frame,
            text=f"{ec_b:>3}",
            font=("Courier New", 12, "bold"),
            bg=BG_COLOR,
            fg=FG_COLOR,
            width=col_widths[6],
            anchor="center"
        ).grid(row=0, column=6, padx=1, sticky="ew")

        # === COLONNE 8: √âcbmx ===
        tk.Label(
            line_frame,
            text=f"{ecmx_b:>4}",
            font=("Courier New", 12, "bold"),
            bg=BG_COLOR,
            fg="orange",
            width=col_widths[7],
            anchor="center"
        ).grid(row=0, column=7, padx=1, sticky="ew")

        # === COLONNE 9: COMBI ===
        tk.Label(
            line_frame,
            text=combi,
            font=("Courier New", 12, "bold"),
            bg=BG_COLOR,
            fg="magenta",
            width=col_widths[8],
            anchor="center"
        ).grid(row=0, column=8, padx=1, sticky="ew")

        # === COLONNE 10: √âcSD ===
        ecsd_color = "red" if ecsd > 3 else FG_COLOR
        tk.Label(
            line_frame,
            text=f"{ecsd:>4}",
            font=("Courier New", 12, "bold"),
            bg=BG_COLOR,
            fg=ecsd_color,
            width=col_widths[9],
            anchor="center"
        ).grid(row=0, column=9, padx=1, sticky="ew")

        # === COLONNE 11: √âcSDmax ===
        tk.Label(
            line_frame,
            text=f"{ecsdmax:>5}",
            font=("Courier New", 12, "bold"),
            bg=BG_COLOR,
            fg="red",
            width=col_widths[10],
            anchor="center"
        ).grid(row=0, column=10, padx=1, sticky="ew")

    # ========== BOUTONS BAS ==========
    button_frame = tk.Frame(main_frame, bg=BG_COLOR)
    button_frame.grid(row=2, column=0, pady=15)

    # Bouton Reset AB
    tk.Button(
        button_frame,
        text="üîÑ RESET AB",
        font=("Arial", 12, "bold"),
        bg="orange",
        fg="white",
        command=reset_ab_series,
        padx=15,
        pady=10
    ).pack(side="left", padx=10)

    # Bouton Fermer
    tk.Button(
        button_frame,
        text="‚ùå FERMER LE TABLEAU A/B",
        font=("Arial", 12, "bold"),
        bg="red",
        fg="white",
        command=lambda: ab_window.destroy(),
        padx=20,
        pady=10
    ).pack(side="right", padx=10)

    # Focus
    ab_window.lift()
    ab_window.focus_force()
    canvas.update_idletasks()
    canvas.config(scrollregion=canvas.bbox("all"))
    ab_window.update_idletasks()


# Fonction pour ouvrir ou fermer la fen√™tre
def toggle_ab_window():
    global ab_window, last_window_position
    if ab_window is None or not ab_window.winfo_exists():
        create_ab_window()
    else:
        last_window_position = (ab_window.winfo_x(), ab_window.winfo_y())
        ab_window.destroy()
        ab_window = None


# --- SOUS-CADRE POUR LES BOUTONS "AFF/CACH" ET "JOUER A/B" ---
buttons_ab_frame = tk.Frame(dyza_frame, bg="lightyellow", borderwidth=0)
buttons_ab_frame.grid(row=3, column=1, padx=5, pady=5, sticky="n")

# Bouton "Aff/Cach S√©ries A/B"
aff_cach_button = tk.Button(
    buttons_ab_frame,
    text="Aff/Cach\nS√©ries A/B",
    font=("Arial", 10, "bold"),
    bg="lightblue",
    fg="black",
    borderwidth=8,
    width=10,
    height=2,
    command=toggle_ab_window
)
aff_cach_button.pack(pady=(0, 2))

# Bouton "JOUER A/B"
jouer_ab_button = tk.Button(
    buttons_ab_frame,
    text="JOUER A/B",
    font=("Arial", 10, "bold"),
    bg="gray",
    fg="white",
    state="disabled",
    width=10,
    height=2,
    command=jouer_ab_series
)
jouer_ab_button.pack(pady=(0, 0))
jouer_ab_button.pack_forget()  # Cach√© au d√©part


# =======================================================
# AJOUT SYST√àME : S√âQUENCE ROUGE/NOIR 6 SPINS + MONTANTE
# =======================================================

# =======================================================
# D√âFINITIONS DES CONSTANTES POUR LES NOUVEAUX SYST√àMES
# =======================================================

# S√©quence fixe (6 spins)
SEQUENCE_RN = ["R", "N", "R", "R", "N", "N"]
SEQUENCE_PI = ["Pa", "Ip", "Pa", "Pa", "Ip", "Ip"]  # Pair/Impair
SEQUENCE_MP = ["Mq", "Ps", "Mq", "Mq", "Ps", "Ps"]  # Manque/Passe

# D√©finition des num√©ros
RED_NUMBERS = {1, 3, 5, 7, 9, 12, 14, 16, 18, 19, 21, 23, 25, 27, 30, 32, 34, 36}
BLACK_NUMBERS = {2, 4, 6, 8, 10, 11, 13, 15, 17, 20, 22, 24, 26, 28, 29, 31, 33, 35}
PAIR_NUMBERS = {2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36}
IMPAIR_NUMBERS = {1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35}
MANQUE_NUMBERS = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18}
PASSE_NUMBERS = {19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36}

# Variables globales pour les syst√®mes
rn_sequence_index = 0  # Position dans la s√©quence (0 √† 5)
rn_mise = 1  # Mise actuelle (montante)
rn_last_result = "WIN"  # Pour savoir si on r√©initialise

pi_sequence_index = 0  # Pair/Impair
pi_mise = 1
pi_last_result = "WIN"

mp_sequence_index = 0  # Manque/Passe
mp_mise = 1
mp_last_result = "WIN"

# Texte au centre du cercle
rn_text = rn_canvas.create_text(30, 30, text="1", font=("Arial", 14, "bold"), fill="white")


# Fonction pour dessiner le cercle
def draw_rn_circle(color):
    rn_canvas.delete("all")
    rn_canvas.create_oval(5, 5, 55, 55, outline="black", width=2, fill=color)
    rn_canvas.create_text(30, 30, text=str(rn_mise), font=("Arial", 14, "bold"), fill="white")


# Fonction de mise √† jour
def update_rn_sequence(last_number):
    global rn_sequence_index, rn_mise, rn_last_result

    # D√©terminer la couleur du dernier num√©ro
    if last_number in RED_NUMBERS:
        couleur_du_coup = "R"
    elif last_number in BLACK_NUMBERS:
        couleur_du_coup = "N"
    else:
        couleur_du_coup = "R"  # 0 n'affecte pas, on continue

    # Cible actuelle dans la s√©quence
    cible = SEQUENCE_RN[rn_sequence_index]

    # V√©rifier si gain ou perte
    if couleur_du_coup == cible:
        rn_last_result = "WIN"
        rn_mise = 1  # R√©initialiser √† 1 apr√®s gain
    else:
        rn_last_result = "LOSS"
        rn_mise *= 2  # Doubler apr√®s perte

    # Passer √† l'√©l√©ment suivant de la s√©quence (cycle 0‚Üí5)
    rn_sequence_index = (rn_sequence_index + 1) % 6

    # Dessiner le cercle selon la prochaine cible
    next_target = SEQUENCE_RN[rn_sequence_index]
    color = "red" if next_target == "R" else "black"
    draw_rn_circle(color)


# Fonction de r√©initialisation
def reset_rn_sequence():
    global rn_sequence_index, rn_mise, rn_last_result
    rn_sequence_index = 0
    rn_mise = 1
    rn_last_result = "WIN"
    draw_rn_circle("red")  # D√©marre toujours sur ROUGE


# =======================================================
# SYST√àME PAIR/IMPAIR
# =======================================================

# Fonction pour dessiner le cercle Pair/Impair
def draw_pi_circle(color, text_color="white"):
    pi_canvas.delete("all")
    pi_canvas.create_oval(5, 5, 55, 55, outline="black", width=2, fill=color)
    pi_canvas.create_text(30, 30, text=f"{pi_mise}{SEQUENCE_PI[pi_sequence_index]}",
                          font=("Arial", 12, "bold"), fill=text_color)


# Fonction de mise √† jour Pair/Impair
def update_pi_sequence(last_number):
    global pi_sequence_index, pi_mise, pi_last_result

    # D√©terminer si pair ou impair
    if last_number in PAIR_NUMBERS:
        resultat_du_coup = "Pa"
    elif last_number in IMPAIR_NUMBERS:
        resultat_du_coup = "Ip"
    else:
        resultat_du_coup = "Pa"  # 0 n'affecte pas, on continue

    # Cible actuelle dans la s√©quence
    cible = SEQUENCE_PI[pi_sequence_index]

    # V√©rifier si gain ou perte
    if resultat_du_coup == cible:
        pi_last_result = "WIN"
        pi_mise = 1  # R√©initialiser √† 1 apr√®s gain
    else:
        pi_last_result = "LOSS"
        pi_mise *= 2  # Doubler apr√®s perte

    # Passer √† l'√©l√©ment suivant de la s√©quence (cycle 0‚Üí5)
    pi_sequence_index = (pi_sequence_index + 1) % 6

    # Dessiner le cercle selon la prochaine cible
    next_target = SEQUENCE_PI[pi_sequence_index]
    if next_target == "Pa":
        draw_pi_circle("darkblue", "white")  # Bleu fonc√© pour Pair
    else:
        draw_pi_circle("#8B4513", "white")  # Marron fonc√© pour Impair


# Fonction de r√©initialisation Pair/Impair
def reset_pi_sequence():
    global pi_sequence_index, pi_mise, pi_last_result
    pi_sequence_index = 0
    pi_mise = 1
    pi_last_result = "WIN"
    draw_pi_circle("darkblue", "white")  # D√©marre toujours sur PAIR


# =======================================================
# SYST√àME MANQUE/PASSE
# =======================================================

# Fonction pour dessiner le cercle Manque/Passe
def draw_mp_circle(color, text_color="white"):
    mp_canvas.delete("all")
    mp_canvas.create_oval(5, 5, 55, 55, outline="black", width=2, fill=color)
    mp_canvas.create_text(30, 30, text=f"{mp_mise}{SEQUENCE_MP[mp_sequence_index]}",
                          font=("Arial", 12, "bold"), fill=text_color)


# Fonction de mise √† jour Manque/Passe
def update_mp_sequence(last_number):
    global mp_sequence_index, mp_mise, mp_last_result

    # D√©terminer si manque ou passe
    if last_number in MANQUE_NUMBERS:
        resultat_du_coup = "Mq"
    elif last_number in PASSE_NUMBERS:
        resultat_du_coup = "Ps"
    else:
        resultat_du_coup = "Mq"  # 0 n'affecte pas, on continue

    # Cible actuelle dans la s√©quence
    cible = SEQUENCE_MP[mp_sequence_index]

    # V√©rifier si gain ou perte
    if resultat_du_coup == cible:
        mp_last_result = "WIN"
        mp_mise = 1  # R√©initialiser √† 1 apr√®s gain
    else:
        mp_last_result = "LOSS"
        mp_mise *= 2  # Doubler apr√®s perte

    # Passer √† l'√©l√©ment suivant de la s√©quence (cycle 0‚Üí5)
    mp_sequence_index = (mp_sequence_index + 1) % 6

    # Dessiner le cercle selon la prochaine cible
    next_target = SEQUENCE_MP[mp_sequence_index]
    if next_target == "Mq":
        draw_mp_circle("darkgreen", "white")  # Vert fonc√© pour Manque
    else:
        draw_mp_circle("purple", "white")  # Mauve pour Passe


# Fonction de r√©initialisation Manque/Passe
def reset_mp_sequence():
    global mp_sequence_index, mp_mise, mp_last_result
    mp_sequence_index = 0
    mp_mise = 1
    mp_last_result = "WIN"
    draw_mp_circle("darkgreen", "white")  # D√©marre toujours sur MANQUE


# Initialisation des trois syst√®mes
draw_rn_circle("red")  # Rouge/Noir
draw_pi_circle("darkblue", "white")  # Pair/Impair
draw_mp_circle("darkgreen", "white")  # Manque/Passe

# =======================================================
# AJOUT SYST√àME : JC - 4 TABLES INTERACTIVES (A, B, C, D)
# =======================================================

import tkinter as tk
from tkinter import messagebox

# Donn√©es des 4 tables
TABLES_JC = {
    "A": [
        [1, 2, 3, 4, 5, 6, 7, 8, 9],
        [16, 17, 12, 15, 10, 13, 18, 11, 14],
        [20, 21, 26, 19, 23, 27, 28, 30, 22],
        [33, 25, 35, 32, 24, 34, 29, 36, 31],
        [0, 0, 0, 0, 0, 0, 0, 0, 0]  # Pour aligner avec 5 lignes
    ],
    "B": [
        [1, 2, 3, 4, 5, 6, 7, 8, 9],
        [14, 17, 26, 15, 10, 13, 12, 11, 18],
        [20, 25, 32, 19, 16, 27, 28, 23, 22],
        [33, 34, 35, 21, 24, 36, 29, 30, 31],
        [0, 0, 0, 0, 0, 0, 0, 0, 0]
    ],
    "C": [
        [1, 2, 3, 11, 5, 6, 7, 8, 9],
        [14, 4, 15, 13, 16, 17, 12, 10, 18],
        [20, 19, 26, 27, 24, 25, 28, 23, 22],
        [31, 21, 32, 36, 33, 34, 35, 30, 29],
        [0, 0, 0, 0, 0, 0, 0, 0, 0]
    ],
    "D": [
        [1, 2, 3, 11, 5, 6, 7, 9, 15],
        [16, 4, 12, 13, 8, 17, 18, 14, 19],
        [24, 21, 28, 30, 10, 27, 22, 20, 26],
        [33, 25, 35, 36, 23, 34, 29, 31, 32],
        [0, 0, 0, 0, 0, 0, 0, 0, 0]
    ]
}

# Variables globales
jc_window = None
jc_highlighted = set()  # Num√©ros colori√©s
jc_cibles = []  # Liste des cibles
jc_level = 1  # Niveau 1 ou 2
jc_color_count = {}  # Compte des num√©ros colori√©s par colonne (pour niveau 2)
jc_table_frames = []  # Frames des tables
jc_cibles_labels = {}  # Labels des cibles pour mise √† jour


# Fonction pour jouer les num√©ros
def play_numbers(numbers):
    """Joue les num√©ros d'une s√©rie sur la table de jeu"""
    for num in numbers:
        if num in coordinates:
            x, y = coordinates[num]
            pyautogui.click(x, y)
            time.sleep(0.1)


# Fonction pour ouvrir/fermer la fen√™tre
def toggle_jc_window():
    global jc_window
    if jc_window is None or not jc_window.winfo_exists():
        create_jc_window()
        # Mettre √† jour l'affichage avec les donn√©es existantes
        refresh_jc_display()
    else:
        jc_window.destroy()
        jc_window = None


# Fonction pour cr√©er la fen√™tre JC
def create_jc_window():
    global jc_window, jc_cibles_frame, jc_level_var, jc_table_frames

    jc_window = tk.Toplevel(root)
    jc_window.title("JC - TABLES A/B/C/D")
    jc_window.configure(bg="navy")
    jc_window.geometry("1000x700")
    jc_window.resizable(True, True)

    # Titre
    tk.Label(
        jc_window,
        text="üîç SYST√àME JC - 4 TABLES INTERACTIVES",
        font=("Arial", 16, "bold"),
        bg="navy",
        fg="gold"
    ).pack(pady=10)

    # Frame principale
    main_jc_frame = tk.Frame(jc_window, bg="navy")
    main_jc_frame.pack(pady=10)

    # Contr√¥les haut
    control_frame = tk.Frame(main_jc_frame, bg="navy")
    control_frame.grid(row=0, column=0, columnspan=5, pady=10)

    # Niveau
    tk.Label(control_frame, text="Niveau :", bg="navy", fg="white", font=("Arial", 10)).pack(side="left", padx=5)
    jc_level_var = tk.IntVar(value=jc_level)
    tk.Radiobutton(control_frame, text="1", variable=jc_level_var, value=1, bg="navy", fg="white",
                   selectcolor="darkblue", command=lambda: set_jc_level(1)).pack(side="left")
    tk.Radiobutton(control_frame, text="2", variable=jc_level_var, value=2, bg="navy", fg="white",
                   selectcolor="darkblue", command=lambda: set_jc_level(2)).pack(side="left", padx=(10, 0))

    # Bouton RESET
    tk.Button(
        control_frame,
        text="RESET 4 TB",
        font=("Arial", 10, "bold"),
        bg="red",
        fg="white",
        command=reset_jc
    ).pack(side="right", padx=10)

    # Frame des tables
    tables_frame = tk.Frame(main_jc_frame, bg="navy")
    tables_frame.grid(row=1, column=0, columnspan=5, pady=10)

    # Cr√©er les 4 tables
    for idx, (name, table) in enumerate(TABLES_JC.items()):
        frame = tk.Frame(tables_frame, bg="gray20", bd=2, relief="groove")
        frame.grid(row=0, column=idx, padx=15)

        tk.Label(frame, text=f"TABLE {name}", font=("Arial", 12, "bold"), bg="gray20", fg="cyan").grid(row=0, column=0,
                                                                                                       columnspan=9)

        for i, row in enumerate(table):
            for j, num in enumerate(row):
                if num == 0 and i == 4:  # Case 0 centr√©e
                    lbl = tk.Label(
                        frame,
                        text="0",
                        font=("Arial", 11, "bold"),
                        bg="black", fg="white",
                        width=3, height=1,
                        relief="raised"
                    )
                    lbl.grid(row=5, column=4, pady=2)
                elif num != 0:
                    lbl = tk.Label(
                        frame,
                        text=str(num),
                        font=("Arial", 10),
                        bg="lightgray", fg="black",
                        width=3, height=1,
                        relief="raised"
                    )
                    lbl.grid(row=i + 1, column=j, padx=1, pady=1)
                    lbl.num = num
                    lbl.table = name
                    lbl.pos = (i, j)
                    lbl.bind("<Button-1>", lambda e: None)  # Pas de clic direct
                    setattr(frame, f"cell_{num}", lbl)

    # Sauvegarder les frames
    jc_table_frames = [frame for frame in tables_frame.winfo_children()]

    # Colonnes CIBLES
    cibles_frame = tk.Frame(main_jc_frame, bg="navy")
    cibles_frame.grid(row=1, column=5, padx=20, sticky="n")

    tk.Label(
        cibles_frame,
        text="CIBLES",
        font=("Arial", 14, "bold"),
        bg="navy", fg="yellow"
    ).pack()

    # Liste des cibles
    jc_cibles_frame = tk.Frame(cibles_frame, bg="black")
    jc_cibles_frame.pack(pady=5, fill="y", expand=True)

    # Bouton CIBLES
    tk.Button(
        cibles_frame,
        text="Jouer Cibles",
        font=("Arial", 12, "bold"),
        bg="green",
        fg="white",
        command=lambda: play_numbers(jc_cibles) if jc_cibles else None
    ).pack(pady=5)


# Fonction pour d√©finir le niveau
def set_jc_level(level):
    global jc_level
    jc_level = level
    # Recalculer les cibles avec le nouveau niveau
    recalculate_jc_targets()


# Fonction pour recalculer les cibles
def recalculate_jc_targets():
    global jc_cibles
    jc_cibles.clear()

    # Parcourir chaque table
    collected = []
    for table_name, table in TABLES_JC.items():
        for j in range(9):  # Chaque colonne
            column_nums = [row[j] for row in table if row[j] != 0]
            colored_in_col = [n for n in column_nums if n in jc_highlighted]

            if jc_level == 1:
                # Pour chaque num√©ro colori√© dans cette colonne
                for num in colored_in_col:
                    collected.extend([n for n in column_nums if n != num])
            elif jc_level == 2:
                if len(colored_in_col) >= 2:
                    collected.extend([n for n in column_nums if n not in colored_in_col])

    # Supprimer les doublons
    unique_collected = []
    for n in collected:
        if n not in unique_collected and n not in jc_highlighted:
            unique_collected.append(n)

    # Mettre √† jour les cibles
    jc_cibles = unique_collected

    # Mettre √† jour l'affichage si la fen√™tre est ouverte
    if jc_window and jc_window.winfo_exists():
        refresh_jc_cibles_display()


# Fonction de mise √† jour
def update_jc(last_number):
    global jc_cibles

    # Mettre √† jour les num√©ros colori√©s
    if last_number not in jc_highlighted:
        jc_highlighted.add(last_number)

    # Recalculer les cibles
    recalculate_jc_targets()

    # Mettre √† jour l'affichage si la fen√™tre est ouverte
    if jc_window and jc_window.winfo_exists():
        refresh_jc_display()

    # V√©rifier si le dernier num√©ro est dans CIBLES
    if last_number in jc_cibles:
        # Afficher un message seulement si la fen√™tre est ouverte
        if jc_window and jc_window.winfo_exists():
            messagebox.showinfo("üéØ GAGNANT !", f"{last_number} est dans les CIBLES !", parent=jc_window)


# Fonction pour rafra√Æchir l'affichage JC
def refresh_jc_display():
    if not jc_window or not jc_window.winfo_exists():
        return

    # Mettre √† jour les couleurs des cellules
    for frame in jc_table_frames:
        for widget in frame.winfo_children():
            if hasattr(widget, 'num'):
                if widget.num in jc_highlighted:
                    widget.config(bg="green", fg="white")
                else:
                    widget.config(bg="lightgray", fg="black")

    # Mettre √† jour l'affichage des cibles
    refresh_jc_cibles_display()


# Fonction pour rafra√Æchir l'affichage des cibles
def refresh_jc_cibles_display():
    if not jc_window or not jc_window.winfo_exists():
        return

    # Vider le frame des cibles
    for widget in jc_cibles_frame.winfo_children():
        widget.destroy()

    # Recr√©er les labels des cibles
    for n in jc_cibles:
        lbl = tk.Label(
            jc_cibles_frame,
            text=str(n),
            font=("Arial", 10, "bold"),
            bg="black", fg="lightgreen",
            width=5, height=1
        )
        lbl.pack()


# Fonction de r√©initialisation
def reset_jc():
    global jc_highlighted, jc_cibles
    jc_highlighted.clear()
    jc_cibles.clear()

    # Mettre √† jour l'affichage si la fen√™tre est ouverte
    if jc_window and jc_window.winfo_exists():
        refresh_jc_display()


# --- Bouton Aff/Cach (dans le cadre parent) ---
jc_button = tk.Button(
    buttons_frame,  # Plac√© dans le cadre parent
    text="Aff/Cach\nJC",
    font=("Arial", 10, "bold"),
    bg="lightgreen",
    fg="black",
    borderwidth=8,
    width=10,
    height=2,
    command=toggle_jc_window
)
jc_button.pack(side="left", padx=5, pady=5)  # Plac√© √† droite du bouton VFN

# ====================================================
# AJOUT : BLOC "LES 3 MARTYRS" - APPL + FUT KAC + FCCG
# ====================================================

# --- 1. Tableau FCCG ---
FCCG_TABLE = {
    1: [0, 1, 4, 7, 10, 19, 22, 25, 28, 30, 33],
    2: [0, 2, 5, 8, 11, 20, 21, 23, 25, 26, 29],
    3: [0, 3, 6, 9, 12, 21, 24, 26, 27, 30, 35],
    4: [0, 1, 4, 13, 16, 19, 21, 22, 31, 34],
    5: [0, 2, 5, 10, 14, 17, 20, 23, 24, 32, 35],
    6: [0, 3, 6, 15, 18, 21, 24, 27, 33, 34, 36],
    7: [0, 7, 10, 13, 16, 25, 28, 29, 31, 34],
    8: [0, 8, 11, 14, 17, 23, 26, 29, 30, 32, 35],
    9: [0, 9, 12, 15, 18, 22, 27, 30, 31, 33, 36]
}

# --- 2. Tableau FUTURING KAC ---
FUT_TABLE = {
    0: [1, 2, 3, 4],
    1: [20, 21, 23, 24],
    2: [20, 21, 23, 24],
    3: [23, 24, 26, 27],
    4: [32, 33, 35, 36],
    5: [32, 33, 35, 36],
    6: [22, 23, 25, 26],
    7: [32, 33, 35, 36],
    8: [32, 33, 35, 36],
    9: [31, 32, 34, 35],
    10: [26, 27, 29, 30],
    11: [28, 29, 31, 32],
    12: [29, 30, 32, 33],
    13: [29, 30, 32, 33],
    14: [25, 26, 28, 29],
    15: [23, 24, 26, 27],
    16: [19, 20, 22, 23],
    17: [31, 32, 34, 35],
    18: [26, 27, 29, 30],
    19: [16, 17, 19, 20],
    20: [2, 3, 5, 6],
    21: [1, 2, 4, 5],
    22: [5, 6, 8, 9],
    23: [2, 3, 5, 6],
    24: [14, 15, 17, 18],
    25: [14, 15, 17, 18],
    26: [10, 11, 13, 14],
    27: [17, 18, 20, 21],
    28: [11, 12, 14, 15],
    29: [13, 14, 16, 17],
    30: [11, 12, 14, 15],
    31: [17, 18, 20, 21],
    32: [5, 6, 8, 9],
    33: [4, 5, 7, 8],
    34: [8, 9, 11, 12],
    35: [8, 9, 11, 12],
    36: [7, 8, 10, 11]
}

# --- 3. Tableau APPL (1 √©quivalent par num√©ro) ---
APPL_TABLE = {
    0: 0, 1: 19, 2: 20, 3: 21, 4: 13, 5: 32, 6: 24, 7: 25, 8: 17, 9: 27,
    10: 28, 11: 29, 12: 30, 13: 4, 14: 23, 15: 33, 16: 34, 17: 8, 18: 36,
    19: 1, 20: 2, 21: 3, 22: 31, 23: 14, 24: 6, 25: 7, 26: 35, 27: 9,
    28: 10, 29: 11, 30: 12, 31: 22, 32: 5, 33: 15, 34: 16, 35: 26, 36: 18
}

# --- 4. Variables globales ---
appl_numbers = []
fut_numbers = []
fccg_numbers = []


# --- 6. Fonction pour jouer les num√©ros ---
def play_numbers(numbers):
    if not numbers:
        messagebox.showinfo("Jeu", "Aucun num√©ro √† jouer.")
        return
    try:
        click_speed = int(speed_entry.get())
    except ValueError:
        messagebox.showerror("Erreur", "Vitesse de clic invalide.")
        return
    for num in numbers:
        if num in coordinates:
            x, y = coordinates[num]
            if x > 0 and y > 0:
                pyautogui.click(x, y)
                time.sleep(click_speed / 1000)


# --- 7. Fonction de r√©duction √† un chiffre (1-9) ---
def reduce_to_digit(n):
    while n >= 10:
        n = sum(int(d) for d in str(n))
    return n if n != 0 else 9  # Si 0, on met 9 (ou adapte selon logique)


# --- 8. Fonctions de mise √† jour ---
def update_appl_display():
    global appl_numbers
    if len(history) < 4:
        appl_label.config(text="")
        appl_numbers = []
        return
    last_4 = history[-4:]
    appl_numbers = [APPL_TABLE[num] for num in last_4 if num in APPL_TABLE]
    seen = set()
    appl_numbers = [x for x in appl_numbers if not (x in seen or seen.add(x))]
    appl_label.config(text=" " + " ".join(map(str, appl_numbers)) + " ")


def update_fut_display():
    global fut_numbers
    if len(history) < 4:
        fut_label.config(text="")
        fut_numbers = []
        return
    last_4 = history[-4:]
    fut_numbers = []
    for num in last_4:
        if num in FUT_TABLE:
            fut_numbers.extend(FUT_TABLE[num])
    seen = set()
    fut_numbers = [x for x in fut_numbers if not (x in seen or seen.add(x))][:16]
    fut_label.config(text=" " + " ".join(map(str, fut_numbers)) + " ")


def update_fccg_display():
    global fccg_numbers
    if len(history) < 4:
        fccg_label.config(text="")
        fccg_numbers = []
        return
    total = sum(history[-4:])
    digit = reduce_to_digit(total)
    if digit in FCCG_TABLE:
        fccg_numbers = FCCG_TABLE[digit]
        fccg_label.config(text=" " + " ".join(map(str, fccg_numbers)) + " ")
    else:
        fccg_label.config(text="")
        fccg_numbers = []


# --- 9. Mise √† jour globale ---
def update_martyrs():
    update_appl_display()
    update_fut_display()
    update_fccg_display()


# --- 10. Int√©gration dans on_number_click ---
if 'update_detected_numbers' in globals():
    original_update_detected_numbers = update_detected_numbers
else:
    def original_update_detected_numbers(number):
        pass


def update_detected_numbers(number):
    original_update_detected_numbers(number)
    update_martyrs()


# =========================================================
# AJOUT : SYST√àME NINEVEH - VERSION FINALE ET FONCTIONNELLE
# =========================================================

# --- 1. Variables globales ---
nineveh_active = False
nineveh_numbers = []
nineveh_counter = 0  # Compte les tours depuis le dernier ajout

# --- 2. Cr√©ation du bloc principal ---
nineveh_frame = tk.Frame(martyrs_frame, bg="navy", borderwidth=3, relief="groove")
# Dans le code Nineveh, changez seulement cette ligne :
nineveh_frame.grid(row=5, column=0, padx=10, pady=10, sticky="ew")  # ‚Üê sticky="ew" au lieu de "nw"
nineveh_frame.columnconfigure(1, weight=1)  # ‚Üê Ajout√© pour permettre l'expansion


# --- 3. Bouton ON/OFF ---
def toggle_nineveh():
    global nineveh_active, nineveh_numbers, nineveh_counter
    if not nineveh_active:
        if len(history) < 1:
            messagebox.showinfo("NINEVEH", "Aucun num√©ro disponible.")
            return
        nineveh_active = True
        nineveh_numbers = [history[-1]]
        nineveh_counter = 0
        nineveh_var.set(" ".join(map(str, nineveh_numbers)))
        on_off_btn.config(bg="green", text="ON", fg="white")
        status_label.config(text="ACTIVE", fg="lime")
        # Mise √† jour du compteur
        counter_var.set(f"{len(nineveh_numbers)}/12")
        print(f"[NINEVEH] D√©marr√© avec {history[-1]}")
    else:
        nineveh_active = False
        on_off_btn.config(bg="red", text="OFF", fg="white")
        status_label.config(text="INACTIF", fg="gray")
        # R√©initialisation du compteur
        counter_var.set("0/12")
        print("[NINEVEH] Arr√™t√©")


on_off_btn = tk.Button(
    nineveh_frame,
    text="OFF",
    font=("Arial", 10, "bold"),
    bg="red",
    fg="white",
    borderwidth=4,
    width=6,
    command=toggle_nineveh
)
on_off_btn.grid(row=1, column=0, padx=5, pady=5)

# --- 4. Affichage des num√©ros ---
nineveh_var = tk.StringVar(value="---")
nineveh_label = tk.Label(
    nineveh_frame,
    textvariable=nineveh_var,
    font=("Courier", 10, "bold"),
    bg="black",
    fg="cyan",
    width=14,  # ‚Üê Vous pouvez r√©duire cette valeur si n√©cessaire
    height=1,
    relief="sunken",
    anchor="w",
    padx=5
)
nineveh_label.grid(row=1, column=1, padx=5, pady=5, sticky="ew")  # ‚Üê Ajout de sticky="ew"

# --- 5. Status (texte) ---
status_label = tk.Label(
    nineveh_frame,
    text="INACTIF",
    font=("Arial", 8),
    bg="navy",
    fg="gray",
    width=8
)
status_label.grid(row=0, column=1, sticky="w", padx=5)


# --- 6. Bouton "NINEVEH" ---
def on_nineveh_click():
    if not nineveh_numbers:
        messagebox.showinfo("NINEVEH", "Aucun num√©ro √† jouer.")
        return
    try:
        click_speed = int(speed_entry.get())
    except ValueError:
        messagebox.showerror("Erreur", "Vitesse de clic invalide.")
        return
    for num in nineveh_numbers:
        if num in coordinates:
            x, y = coordinates[num]
            if x > 0 and y > 0:
                pyautogui.click(x, y)
                time.sleep(click_speed / 1000)


nineveh_button = tk.Button(
    nineveh_frame,
    text="NINEVEH",
    font=("Arial", 10, "bold"),
    bg="DarkTurquoise",
    fg="white",
    borderwidth=6,
    width=8,
    command=on_nineveh_click
)
nineveh_button.grid(row=0, column=0, padx=5, pady=5)

# --- 7. Compteur de num√©ros ---
counter_var = tk.StringVar(value="0/12")
counter_label = tk.Label(
    nineveh_frame,
    textvariable=counter_var,
    font=("Arial", 10, "bold"),
    bg="navy",
    fg="white",
    width=5
)
counter_label.grid(row=0, column=2, padx=5, pady=5)


# --- 8. Fonction de mise √† jour ---
def update_nineveh_display():
    """Appel√©e depuis on_number_click pour mettre √† jour NINEVEH"""
    global nineveh_counter, nineveh_numbers
    if not nineveh_active:
        return
    # ‚úÖ INCR√âMENT DU COMPTEUR
    nineveh_counter += 1
    print(f"[DEBUG] NINEVEH active={nineveh_active}, counter={nineveh_counter}")
    # Tous les 9 tours, ajouter le dernier num√©ro (si < 12)
    if nineveh_counter >= 9 and len(nineveh_numbers) < 12:
        last_num = history[-1]
        if last_num not in nineveh_numbers:
            nineveh_numbers.append(last_num)
            nineveh_counter = 0
            nineveh_var.set(" ".join(map(str, nineveh_numbers)))
            # Mise √† jour du compteur
            counter_var.set(f"{len(nineveh_numbers)}/12")
            print(f"[NINEVEH] ‚úÖ Ajout de {last_num} ‚Üí {len(nineveh_numbers)} num√©ros")
    # Mise √† jour de l'affichage m√™me sans ajout
    else:
        nineveh_var.set(" ".join(map(str, nineveh_numbers)))
        # Mise √† jour du compteur
        counter_var.set(f"{len(nineveh_numbers)}/12")


# =========================================================
# CADRE DET - D√âPLAC√â VERS LES 3 MARTYRS
# =========================================================

# --- Cadre principal Det ---
detection_frame = tk.Frame(martyrs_frame, bg="lightyellow", height=100, borderwidth=2, relief="groove")
detection_frame.grid(row=7, column=0, padx=10, pady=(0, 10), sticky="ew")

# Bouton D√©t
det_button = tk.Button(detection_frame, text="D√©t", command=play_detected_numbers, width=5)
det_button.pack(side="left", padx=5)

# Label pour afficher les num√©ros d√©tect√©s
detected_numbers_label = tk.Label(detection_frame, text="", bg="lightyellow", fg="blue", font=default_font)
detected_numbers_label.pack(side="left", padx=5)

# --- Label √©cart (D√âPLAC√â ICI) ---
ecart_label = tk.Label(detection_frame, text="0", bg="lightyellow", font=default_font, width=5)
ecart_label.pack(side="right", padx=5)   # ‚Üê J'ai gard√© "side="right"" comme dans votre code original







# ====================================================
# SYSTEME MYTHIQUE : WIN R - VERSION ULTIME (CORRIG√âE)
# ====================================================

# --- 1. Donn√©es des 15 tableaux (6x6) ---
win_r_tables = [
    [[17, 1, 35, 34, 3, 32], [6, 30, 8, 28, 27, 11], [7, 24, 23, 15, 16, 14], [19, 13, 2, 21, 10, 20],
     [18, 12, 26, 9, 22, 29], [25, 31, 36, 4, 33, 5]],
    [[36, 14, 4, 13, 22, 31], [23, 34, 29, 32, 9, 3], [8, 25, 28, 1, 10, 12], [17, 16, 11, 19, 20, 21],
     [26, 7, 2, 27, 18, 30], [35, 5, 33, 24, 15, 6]],
    [[2, 34, 10, 21, 13, 28], [6, 9, 19, 5, 36, 32], [27, 35, 23, 26, 14, 11], [20, 31, 25, 16, 7, 3],
     [12, 4, 17, 1, 15, 24], [22, 33, 8, 30, 18, 29]],
    [[2, 1, 35, 16, 21, 34], [4, 32, 6, 20, 17, 7], [29, 25, 26, 9, 10, 23], [18, 12, 11, 27, 28, 14],
     [19, 8, 30, 24, 13, 31], [5, 33, 3, 15, 22, 36]],
    [[26, 14, 22, 6, 25, 2], [34, 30, 3, 17, 23, 5], [11, 29, 35, 21, 9, 13], [33, 15, 18, 20, 28, 31],
     [27, 7, 24, 4, 1, 16], [10, 36, 12, 19, 32, 8]],
    [[31, 14, 36, 8, 22, 15], [9, 24, 30, 35, 28, 21], [12, 6, 33, 17, 27, 13], [10, 23, 2, 7, 20, 34],
     [11, 32, 5, 18, 4, 26], [19, 3, 16, 29, 1, 25]],
    [[1, 13, 30, 22, 24, 17], [12, 14, 5, 18, 15, 32], [26, 34, 10, 33, 3, 9], [20, 28, 8, 6, 29, 19],
     [23, 11, 4, 27, 31, 7], [16, 36, 35, 25, 2, 21]],
    [[7, 32, 15, 19, 4, 21], [2, 13, 27, 6, 34, 17], [25, 36, 11, 30, 8, 23], [10, 20, 1, 33, 16, 24],
     [5, 14, 31, 9, 22, 18], [29, 26, 3, 35, 12, 28]],
    [[14, 23, 10, 11, 1, 34], [5, 7, 24, 18, 16, 27], [12, 15, 19, 36, 9, 13], [21, 28, 33, 4, 26, 29],
     [17, 8, 20, 32, 25, 3], [35, 6, 2, 30, 22, 31]],
    [[36, 35, 34, 33, 32, 31], [30, 29, 28, 27, 26, 25], [24, 23, 22, 21, 20, 19], [18, 17, 16, 15, 14, 13],
     [12, 11, 10, 9, 8, 7], [6, 5, 4, 3, 2, 1]],
    [[19, 25, 7, 3, 26, 20], [24, 2, 32, 31, 8, 27], [12, 33, 13, 14, 30, 4], [1, 34, 16, 15, 29, 9],
     [23, 11, 35, 36, 5, 28], [18, 22, 6, 10, 21, 17]],
    [[4, 30, 9, 19, 7, 33], [11, 24, 2, 35, 21, 25], [12, 27, 32, 5, 15, 17], [16, 14, 6, 31, 28, 13],
     [26, 22, 34, 3, 23, 20], [36, 8, 18, 10, 29, 1]],
    [[18, 31, 17, 1, 4, 9], [3, 10, 20, 24, 15, 7], [36, 5, 23, 11, 33, 25], [14, 35, 8, 26, 22, 28],
     [19, 13, 6, 16, 32, 21], [30, 12, 34, 29, 27, 2]],
    [[31, 28, 15, 24, 36, 18], [12, 10, 32, 6, 23, 4], [29, 33, 19, 11, 5, 27], [8, 9, 21, 1, 2, 22],
     [34, 17, 25, 7, 14, 30], [16, 13, 20, 26, 35, 3]],
    [[25, 10, 19, 9, 4, 14], [36, 5, 15, 20, 18, 29], [8, 35, 27, 31, 21, 32], [22, 30, 17, 16, 26, 7],
     [33, 3, 12, 6, 2, 28], [23, 24, 34, 13, 11, 1]]
]

# --- 2. S√©ries Diagonales (A √† P) ---
DIAGO_SERIES = [
    [25, 12, 2, 15, 27, 32], [17, 30, 23, 21, 22, 5],  # DIAGO A
    [19, 32, 2, 17, 28, 15], [31, 24, 33, 7, 4, 25],  # DIAGO B
    [18, 11, 16, 14, 8, 20], [19, 2, 13, 15, 5, 17],  # DIAGO C
    [5, 8, 11, 9, 17, 34], [2, 32, 26, 27, 13, 36],  # DIAGO D
    [35, 8, 33, 36, 16, 34], [14, 7, 19, 4, 25, 31],  # DIAGO E
    [16, 17, 21, 11, 23, 18], [31, 10, 19, 1, 14, 3],  # DIAGO F
    [36, 22, 6, 5, 21, 33], [4, 24, 32, 31, 23, 1],  # DIAGO H
    [22, 4, 25, 26, 36, 28], [2, 9, 23, 16, 15, 29],  # DIAGO I
    [29, 14, 1, 30, 34, 21], [7, 13, 11, 33, 22, 28],  # DIAGO J
    [36, 7, 11, 1, 9, 31], [36, 34, 28, 19, 18, 6],  # DIAGO K
    [16, 11, 8, 33, 15, 17], [1, 14, 10, 6, 31, 21],  # DIAGO L
    [30, 13, 8, 11, 15, 9], [18, 10, 23, 26, 32, 2],  # DIAGO M
    [10, 7, 18, 21, 23, 2], [26, 30, 35, 20, 1, 8],  # DIAGO N
    [6, 11, 16, 21, 26, 31], [36, 29, 22, 15, 8, 1],  # DIAGO O
    [23, 3, 17, 31, 18, 14], [25, 5, 27, 16, 2, 1]  # DIAGO P
]


# --- 3. Variables globales ---
captured_numbers = []
win_r_colored = [[set() for _ in range(6)] for _ in range(15)]  # Cases colori√©es saumon par tableau
diago_colored = [set() for _ in range(30)]  # Num√©ros saisis par s√©rie diagonale
diago_captured = [set() for _ in range(30)]  # Num√©ros bleus captur√©s par s√©rie diagonale
win_r_window = None
last_highlighted_number = None
mises_cumulees = 0  # Mises cumul√©es perdues
pertes_cumulees = 0  # Total des pertes accumul√©es
mise_unitaire_actuelle = 1  # Mise unitaire courante
historique_Nc = []  # Historique des valeurs Nc
historique_pertes = []  # Historique des pertes
# --- 4. Variables Tkinter ---
mise_value_var = tk.StringVar(value="")
nc_value_var = tk.StringVar(value="")
profit_net_value_var = tk.StringVar(value="0")
mises_cumulees_value_var = tk.StringVar(value="0")
# --- 5. Fonction : Calcul de la mise id√©ale (VERSION CORRIG√âE) ---
def calculer_mise_ideale():
    global mises_cumulees, pertes_cumulees, mise_unitaire_actuelle, historique_Nc, historique_pertes
    if not captured_numbers:
        mise_value_var.set("")
        nc_value_var.set("")
        profit_net_value_var.set("0")
        mises_cumulees_value_var.set("0")
        return
    n = len(captured_numbers)  # Nombre de num√©ros √† jouer (Nc)
    # M√©moriser Nc dans l'historique
    historique_Nc.append(n)
    # Calculer la perte du tour pr√©c√©dent et l'ajouter aux pertes cumul√©es
    if len(historique_Nc) > 1:
        perte_precedente = historique_Nc[-2] * mise_unitaire_actuelle
        pertes_cumulees += perte_precedente
        historique_pertes.append(perte_precedente)
    else:
        # Premier tour - pas de perte pr√©c√©dente
        historique_pertes.append(0)
    # R√©initialiser la mise unitaire pour le calcul
    Mu = 1
    profit_net = -1  # Initialisation √† une valeur n√©gative
    max_attempts = 1000  # üî• Limite de s√©curit√©
    attempts = 0
    # Trouver la mise unitaire minimale pour un profit net positif
    while profit_net < 0 and attempts < max_attempts:
        mise_actuelle = n * Mu
        total_investi = pertes_cumulees + mise_actuelle
        profit_net = (Mu * 36) - total_investi
        if profit_net >= 0:
            # Mise valide trouv√©e
            mise_unitaire_actuelle = Mu
            mises_cumulees = total_investi
            # Mise √† jour de l'affichage
            mise_value_var.set(str(Mu))
            nc_value_var.set(str(n))
            profit_net_value_var.set(str(profit_net))
            mises_cumulees_value_var.set(str(total_investi))
            break
        Mu += 1  # Augmenter la mise unitaire si profit n√©gatif
        attempts += 1
    # üî¥ Si on atteint la limite
    if attempts >= max_attempts:
        print("[WIN R] √âchec: calcul de mise trop long. R√©initialisation.")
        mise_value_var.set("??")
        nc_value_var.set(str(n))
        profit_net_value_var.set("??")
        mises_cumulees_value_var.set(str(pertes_cumulees))
def reset_win_r_mises():
    global mises_cumulees, pertes_cumulees, mise_unitaire_actuelle, historique_Nc, historique_pertes
    print("Bouton R cliqu√©!")  # Debug
    # R√©initialiser seulement les variables de mises
    mises_cumulees = 0
    pertes_cumulees = 0
    mise_unitaire_actuelle = 1
    historique_Nc = []
    historique_pertes = []
    # Recalculer comme si c'√©tait la premi√®re apparition
    if captured_numbers:
        n = len(captured_numbers)
        # Pour la premi√®re apparition, le calcul est simple
        mise_unitaire_actuelle = 1
        mise_actuelle = n * mise_unitaire_actuelle
        profit_net = (mise_unitaire_actuelle * 36) - mise_actuelle
        # Mise √† jour de l'affichage
        mise_value_var.set("1")
        nc_value_var.set(str(n))
        profit_net_value_var.set(str(profit_net))
        mises_cumulees_value_var.set(str(mise_actuelle))
        print(f"Reset r√©ussi: Mise=1, Nc={n}, Pn={profit_net}, Mc={mise_actuelle}")  # Debug
    else:
        # Si aucun num√©ro captur√©
        mise_value_var.set("")
        nc_value_var.set("")
        profit_net_value_var.set("0")
        mises_cumulees_value_var.set("0")
        print("Reset: aucun num√©ro captur√©")  # Debug
# --- 6. Fonction d'affichage Wcap ---
def update_wcap_display():
    if captured_numbers:
        lines = []
        for i in range(0, len(captured_numbers), 10):
            lines.append("  ".join(map(str, captured_numbers[i:i + 10])))
        wcap_display.config(text="\n".join(lines))
    else:
        wcap_display.config(text="")
# --- 7. Fonction principale de capture ---
def update_win_r_system(number):
    global captured_numbers, win_r_colored, diago_colored, diago_captured, last_highlighted_number
    global mises_cumulees, pertes_cumulees, mise_unitaire_actuelle, historique_Nc, historique_pertes
    # 1. M√©moriser le dernier num√©ro pour la surbrillance jaune
    last_highlighted_number = number
    # 2. Colorier en saumon dans les 15 tableaux
    for table_idx in range(15):
        for row in range(6):
            for col in range(6):
                if win_r_tables[table_idx][row][col] == number:
                    win_r_colored[table_idx][row].add(col)
    # 3. R√©initialisation si un num√©ro captur√© est saisi
    if number in captured_numbers:
        captured_numbers.clear()
        mises_cumulees = 0
        pertes_cumulees = 0
        mise_unitaire_actuelle = 1
        historique_Nc = []
        historique_pertes = []
        win_r_colored = [[set() for _ in range(6)] for _ in range(15)]
        diago_colored = [set() for _ in range(30)]
        diago_captured = [set() for _ in range(30)]
        mise_value_var.set("")
        nc_value_var.set("")
        profit_net_value_var.set("0")
        mises_cumulees_value_var.set("0")
        update_wcap_display()
        if win_r_window:
            refresh_win_r_window()
        return
    # 4. Colorier en saumon dans les s√©ries diagonales
    for idx, series in enumerate(DIAGO_SERIES):
        if number in series:
            diago_colored[idx].add(number)
    # 5. V√©rifier les 15 tableaux (lignes ET colonnes)
    new_captures = []
    for table_idx in range(15):
        table = win_r_tables[table_idx]
        for row in range(6):
            free_cells = [table[row][col] for col in range(6) if col not in win_r_colored[table_idx][row]]
            if len(free_cells) == 2:
                new_captures.extend(free_cells)
        for col in range(6):
            free_cells = [table[row][col] for row in range(6) if col not in win_r_colored[table_idx][row]]
            if len(free_cells) == 2:
                new_captures.extend(free_cells)
    # 6. V√©rifier les s√©ries diagonales : 4 saumon ‚Üí 2 bleus ‚Üí capture
    for idx, series in enumerate(DIAGO_SERIES):
        if len(diago_colored[idx]) == 4 and len(diago_captured[idx]) == 0:
            uncolored = [num for num in series if num not in diago_colored[idx]]
            if len(uncolored) == 2:
                diago_captured[idx].update(uncolored)
                for num in uncolored:
                    if num not in captured_numbers and num != number:
                        captured_numbers.append(num)
    # 7. Ajouter les nouvelles captures
    for num in new_captures:
        if num not in captured_numbers and num != number:
            captured_numbers.append(num)
    # 8. Supprimer les doublons
    captured_numbers[:] = list(dict.fromkeys(captured_numbers))
    # 9. Mettre √† jour l'affichage
    update_wcap_display()
    # 10. Calculer la nouvelle mise id√©ale
    calculer_mise_ideale()
    # 11. Rafra√Æchir la fen√™tre Win R si ouverte
    if win_r_window and win_r_window.winfo_exists():
        refresh_win_r_window()
# --- 8. Fen√™tre interactive ---
def toggle_win_r_window():
    global win_r_window
    if win_r_window is None or not win_r_window.winfo_exists():
        create_win_r_window()
    else:
        win_r_window.lift()
def create_win_r_window():
    global win_r_window
    win_r_window = tk.Toplevel(root)
    win_r_window.title("Win R - Tableaux Interactifs")
    win_r_window.geometry("1300x900")
    win_r_window.configure(bg="black")
    for i in range(3):
        for j in range(5):
            idx = i * 5 + j
            if idx >= 15:
                break
            frame = tk.Frame(win_r_window, bg="white", borderwidth=1, relief="solid")
            frame.grid(row=i, column=j, padx=5, pady=5)
            tk.Label(frame, text=f"T{idx + 1}", font=("Arial", 10, "bold"), bg="lightgray").grid(row=0, column=0,
                                                                                                 columnspan=6)
            for r in range(6):
                for c in range(6):
                    num = win_r_tables[idx][r][c]
                    label = tk.Label(frame, text=str(num), font=("Arial", 10), width=3, height=1, relief="solid",
                                     borderwidth=1)
                    label.grid(row=r + 1, column=c, padx=1, pady=1)
                    label.win_r_table = idx
                    label.win_r_row = r
                    label.win_r_col = c
                    label.number = num
    diago_frame = tk.Frame(win_r_window, bg="gray")
    diago_frame.grid(row=3, column=0, columnspan=6, padx=5, pady=10, sticky="ew")
    for j in range(6):
        diago_frame.columnconfigure(j, weight=1)
    diago_names = [
        "DIAGO A-1", "DIAGO A-2", "DIAGO B-1", "DIAGO B-2", "DIAGO C-1", "DIAGO C-2",
        "DIAGO D-1", "DIAGO D-2", "DIAGO E-1", "DIAGO E-2", "DIAGO F-1", "DIAGO F-2",
        "DIAGO H-1", "DIAGO H-2", "DIAGO I-1", "DIAGO I-2", "DIAGO J-1", "DIAGO J-2",
        "DIAGO K-1", "DIAGO K-2", "DIAGO L-1", "DIAGO L-2", "DIAGO M-1", "DIAGO M-2",
        "DIAGO N-1", "DIAGO N-2", "DIAGO O-1", "DIAGO O-2", "DIAGO P-1", "DIAGO P-2"
    ]
    for i in range(5):
        for j in range(6):
            idx = i * 6 + j
            if idx >= 30:
                break
            series = DIAGO_SERIES[idx]
            name = diago_names[idx]
            s_frame = tk.Frame(diago_frame, bg="lightblue", borderwidth=1, relief="solid")
            s_frame.grid(row=i, column=j, padx=3, pady=3, sticky="ew")
            s_frame.columnconfigure(0, weight=1)
            tk.Label(s_frame, text=name, font=("Arial", 8, "bold"), bg="lightgray").pack(fill="x", padx=1, pady=1)
            numbers_frame = tk.Frame(s_frame, bg="white")
            numbers_frame.pack(pady=2)
            for num in series:
                lbl = tk.Label(numbers_frame, text=str(num), font=("Arial", 9, "bold"), width=2, height=1, bg="white",
                               fg="black")
                lbl.pack(side="left", padx=1)
                lbl.diago_idx = idx
                lbl.diago_num = num
def refresh_win_r_window():
    global last_highlighted_number
    if not win_r_window or not win_r_window.winfo_exists():
        return
    for widget in win_r_window.winfo_children():
        for subwidget in widget.winfo_children():
            if hasattr(subwidget, 'number'):
                num = subwidget.number
                table_idx = subwidget.win_r_table
                r = subwidget.win_r_row
                c = subwidget.win_r_col
                if num in captured_numbers:
                    subwidget.config(bg="green", fg="white")
                elif num == last_highlighted_number:
                    subwidget.config(bg="yellow", fg="black")
                elif c in win_r_colored[table_idx][r]:
                    subwidget.config(bg="salmon", fg="black")
                else:
                    subwidget.config(bg="white", fg="black")
    for widget in win_r_window.winfo_children():
        if isinstance(widget, tk.Frame) and widget.cget("bg") == "gray":
            for s_frame in widget.winfo_children():
                for numbers_frame in s_frame.winfo_children():
                    if isinstance(numbers_frame, tk.Frame):
                        for lbl in numbers_frame.winfo_children():
                            if hasattr(lbl, 'diago_num'):
                                num = lbl.diago_num
                                idx = lbl.diago_idx
                                if num in diago_captured[idx]:
                                    lbl.config(bg="blue", fg="white")
                                elif num == last_highlighted_number:
                                    lbl.config(bg="yellow", fg="black")
                                elif num in diago_colored[idx]:
                                    lbl.config(bg="salmon", fg="black")
                                else:
                                    lbl.config(bg="white", fg="black")

# --- NOUVELLE FONCTION PLAC√âE AVANT SON UTILISATION ---
def play_captured_numbers_with_repet():
    if not captured_numbers:
        messagebox.showinfo("Information", "Aucun num√©ro captur√© √† jouer.")
        return
    # R√©cup√©rer la valeur de REPET
    try:
        repetitions = int(repet_mollette.get())
    except ValueError:
        messagebox.showerror("Erreur", "La valeur de r√©p√©tition doit √™tre un nombre entier.")
        return
    # R√©cup√©rer la vitesse de clic
    try:
        click_speed = int(speed_entry.get())
    except ValueError:
        messagebox.showerror("Erreur", "La vitesse de clic doit √™tre un nombre entier.")
        return
    # Jouer chaque num√©ro avec r√©p√©tition
    for num in captured_numbers:
        if num in coordinates:
            x, y = coordinates[num]
            if x > 0 and y > 0:
                for _ in range(repetitions):
                    pyautogui.click(x, y)
                    time.sleep(click_speed / 1000)
            else:
                messagebox.showwarning("Avertissement", f"Coordonn√©es manquantes pour le num√©ro {num}.")
        else:
            messagebox.showwarning("Avertissement", f"Coordonn√©es manquantes pour le num√©ro {num}.")

# --- 9. NOUVELLE DISPOSITION - Int√©gration dans l'interface principale ---
control_frame = tk.Frame(rectangulo_frame, bg="darkgreen")
control_frame.grid(row=14, column=0, columnspan=7, pady=5, sticky="ew")

# --- BLOC UNIQUE √Ä GAUCHE ---
bloc_unique_frame = tk.Frame(control_frame, bg="darkgreen")
bloc_unique_frame.pack(side="left", padx=5)

# Libell√© Wcap au-dessus du bloc
tk.Label(
    bloc_unique_frame,
    text="Wcap",
    font=("Arial", 10, "bold"),
    bg="darkgreen",
    fg="white"
).pack(side="top", pady=(0, 2))

# Cadre pour les √©l√©ments en grille
elements_frame = tk.Frame(bloc_unique_frame, bg="darkgreen")
elements_frame.pack(side="top")

# Premi√®re ligne : ZFD, WC, R, Mise (cadre jaune), Pn (cadre blanc)
tk.Button(
    elements_frame,
    text="ZFD",
    font=("Arial", 10, "bold"),
    bg="orange",
    fg="black",
    width=3,
    relief="raised",
    overrelief="sunken",
    borderwidth=7,
    command=play_captured_numbers_with_repet
).grid(row=0, column=0, padx=2, pady=2)

tk.Button(
    elements_frame,
    text="WC",
    font=("Arial", 10, "bold"),
    bg="blue",
    fg="white",
    borderwidth=7,
    command=lambda: toggle_win_r_window()
).grid(row=0, column=1, padx=2, pady=2)

tk.Button(
    elements_frame,
    text="R",
    font=("Arial", 10, "bold"),
    bg="red",
    fg="white",
    borderwidth=6,
    width=2,
    command=reset_win_r_mises
).grid(row=0, column=2, padx=2, pady=2)

# Mise avec cadre jaune
tk.Label(
    elements_frame,
    text="Mise:",
    font=("Arial", 9, "bold"),
    bg="darkgreen",
    fg="white"
).grid(row=0, column=3, padx=(5, 2), pady=2)

mise_label = tk.Label(
    elements_frame,
    textvariable=mise_value_var,
    font=("Arial", 9, "bold"),
    bg="yellow",
    fg="black",
    width=4,
    relief="sunken"
)
mise_label.grid(row=0, column=4, padx=2, pady=2)

# Pn avec cadre blanc
tk.Label(
    elements_frame,
    text="Pn:",
    font=("Arial", 9, "bold"),
    bg="darkgreen",
    fg="white"
).grid(row=0, column=5, padx=(5, 2), pady=2)

pn_label = tk.Label(
    elements_frame,
    textvariable=profit_net_value_var,
    font=("Arial", 9, "bold"),
    bg="white",
    fg="black",
    width=4,
    relief="sunken"
)
pn_label.grid(row=0, column=6, padx=2, pady=2)

# Deuxi√®me ligne : Mc (cadre vert clair), Nc (cadre bleu ciel)
tk.Label(
    elements_frame,
    text="Mc:",
    font=("Arial", 9, "bold"),
    bg="darkgreen",
    fg="white"
).grid(row=1, column=3, padx=(5, 2), pady=2)

mc_label = tk.Label(
    elements_frame,
    textvariable=mises_cumulees_value_var,
    font=("Arial", 9, "bold"),
    bg="lightgreen",
    fg="black",
    width=4,
    relief="sunken"
)
mc_label.grid(row=1, column=4, padx=2, pady=2)

tk.Label(
    elements_frame,
    text="Nc:",
    font=("Arial", 9, "bold"),
    bg="darkgreen",
    fg="white"
).grid(row=1, column=5, padx=(5, 2), pady=2)

nc_label = tk.Label(
    elements_frame,
    textvariable=nc_value_var,
    font=("Arial", 9, "bold"),
    bg="lightblue",
    fg="black",
    width=4,
    relief="sunken"
)
nc_label.grid(row=1, column=6, padx=2, pady=2)

wcap_display = tk.Label(
    rectangulo_frame,
    text="",
    font=("Arial", 11),
    bg="white",
    fg="black",
    width=30,
    height=3,
    anchor="nw",
    justify="left",
    relief="sunken"
)
wcap_display.grid(row=15, column=0, columnspan=7, pady=(0, 5), padx=5, sticky="ew")
# --- 10. Connexion au syst√®me principal ---
global original_on_number_click
original_on_number_click = on_number_click
def new_on_number_click(number):
    original_on_number_click(number)
    update_win_r_system(number)
on_number_click = new_on_number_click

# ===========================================
# LES TOUTS DERNIERS SYSTEMES AJOUTES
# ===========================================

# ===========================================
# SYST√àMES 150, 500, 1000
# ===========================================

# Variables globales pour les nouveaux syst√®mes
n0_150_numbers = []
n13_500_numbers = []
t29_1000_numbers = []
pld_numbers = {"P1": None, "P2": None, "non_sortis": []}

# ===========================================
# CADRE PRINCIPAL POUR LES NOUVEAUX SYST√àMES
# ===========================================

# Cr√©ation du cadre principal qui contiendra tous les syst√®mes
systems_frame = tk.Frame(rectangulo_frame, bg="lightgray", borderwidth=3, relief="ridge")
systems_frame.grid(row=16, column=0, padx=10, pady=10, sticky="nw")


# Fonction pour mettre √† jour tous les syst√®mes automatiquement
def update_all_systems():
    """Met √† jour tous les syst√®mes automatiquement"""
    if len(history) >= 150:
        systeme_150()
    if len(history) >= 500:
        systeme_500()
    if len(history) >= 1000:
        systeme_1000()


# ========================
# SYST√àME 150 - N0-150
# ========================

def update_n0_150_display():
    """Met √† jour l'affichage des num√©ros avec largeur fixe"""
    # Effacer les anciens labels
    for widget in n0_150_display_frame.winfo_children():
        widget.destroy()

    # Cr√©er un cadre conteneur avec largeur fixe
    container = tk.Frame(n0_150_display_frame, width=180, height=30)
    container.pack(side="left", fill="y")
    container.pack_propagate(False)  # Emp√™che le redimensionnement

    # Cr√©er les nouveaux labels pour chaque num√©ro
    if n0_150_numbers:
        for num in n0_150_numbers:
            color = "red" if num in [1, 3, 5, 7, 9, 12, 14, 16, 18, 19, 21, 23, 25, 27, 30, 32, 34, 36] else "black"
            bg_color = "lightpink" if num % 2 == 0 else "lightblue"

            tk.Label(
                container,
                text=f"{num:2d}",
                font=("Courier", 9, "bold"),
                bg=bg_color,
                fg=color,
                relief="raised",
                width=3
            ).pack(side="left", padx=1)
    else:
        tk.Label(
            container,
            text="Aucun",
            font=("Courier", 9),
            bg="white",
            fg="black"
        ).pack()


def systeme_150():
    global n0_150_numbers
    if len(history) < 150:
        n0_150_numbers = list(range(37))
    else:
        derniers_150 = history[-150:]
        n0_150_numbers = [num for num in range(37) if num not in derniers_150]

    # Mettre √† jour l'affichage
    update_n0_150_display()


# Cadre pour N0-150
n0_150_frame = tk.Frame(systems_frame, bg="lightblue", borderwidth=2, relief="sunken")
n0_150_frame.pack(fill="x", pady=(0, 5))

# Bouton N0-150
tk.Button(
    n0_150_frame,
    text="N0-150",
    font=("Arial", 10, "bold"),
    bg="orange",
    fg="white",
    borderwidth=6,
    command=lambda: [systeme_150(), play_numbers(n0_150_numbers)]
).pack(side="left", padx=5, pady=5)

# Cadre d'affichage pour N0-150 avec largeur fixe
n0_150_display_frame = tk.Frame(n0_150_frame, bg="white", relief="sunken", width=180, height=30)
n0_150_display_frame.pack(side="right", padx=5, pady=5)
n0_150_display_frame.pack_propagate(False)  # Emp√™che le redimensionnement


# ========================
# SYST√àME 500 - N13*500
# ========================
def update_n13_500_display():
    """Met √† jour l'affichage des num√©ros avec largeur fixe"""
    # Effacer les anciens labels
    for widget in n13_500_display_frame.winfo_children():
        widget.destroy()
    # Cr√©er un cadre conteneur avec largeur fixe
    container = tk.Frame(n13_500_display_frame, width=300, height=30)
    container.pack(side="left", fill="y")
    container.pack_propagate(False)  # Emp√™che le redimensionnement
    # Cr√©er les nouveaux labels pour chaque num√©ro
    if n13_500_numbers:
        for num in n13_500_numbers:
            color = "red" if num in [1, 3, 5, 7, 9, 12, 14, 16, 18, 19, 21, 23, 25, 27, 30, 32, 34, 36] else "black"
            bg_color = "lightpink" if num % 2 == 0 else "lightblue"
            tk.Label(
                container,
                text=f"{num:2d}",
                font=("Courier", 9, "bold"),
                bg=bg_color,
                fg=color,
                relief="raised",
                width=3
            ).pack(side="left", padx=1)
    else:
        tk.Label(
            container,
            text="Aucun",
            font=("Courier", 9),
            bg="white",
            fg="black"
        ).pack()

def systeme_500():
    global n13_500_numbers
    if len(history) < 500:
        n13_500_numbers = list(range(37))
    else:
        derniers_500 = history[-500:]
        compteurs_500 = {num: derniers_500.count(num) for num in range(37)}
        n13_500_numbers = [num for num in range(37) if compteurs_500.get(num, 0) < 13]
    # Mettre √† jour l'affichage
    update_n13_500_display()

def play_n13_500_numbers():
    if not n13_500_numbers:
        messagebox.showinfo("Information", "Aucun num√©ro √† jouer pour N13*500.")
        return
    play_numbers(n13_500_numbers)

# Nouvelle fonction pour jouer les num√©ros N13*500 avec REPET
def play_n13_500_numbers_with_repet():
    # D'abord calculer les num√©ros √† jouer
    systeme_500()

    if not n13_500_numbers:
        messagebox.showinfo("Information", "Aucun num√©ro √† jouer pour N13*500.")
        return

    # R√©cup√©rer la valeur de REPET
    try:
        repetitions = int(repet_mollette.get())
    except ValueError:
        messagebox.showerror("Erreur", "La valeur de r√©p√©tition doit √™tre un nombre entier.")
        return

    # R√©cup√©rer la vitesse de clic
    try:
        click_speed = int(speed_entry.get())
    except ValueError:
        messagebox.showerror("Erreur", "La vitesse de clic doit √™tre un nombre entier.")
        return

    # Jouer chaque num√©ro avec r√©p√©tition
    for num in n13_500_numbers:
        if num in coordinates:
            x, y = coordinates[num]
            if x > 0 and y > 0:
                for _ in range(repetitions):
                    pyautogui.click(x, y)
                    time.sleep(click_speed / 1000)
            else:
                messagebox.showwarning("Avertissement", f"Coordonn√©es manquantes pour le num√©ro {num}.")
        else:
            messagebox.showwarning("Avertissement", f"Coordonn√©es manquantes pour le num√©ro {num}.")

# Cadre pour N13*500
n13_500_frame = tk.Frame(systems_frame, bg="lightgreen", borderwidth=2, relief="sunken")
n13_500_frame.pack(fill="x", pady=(0, 5))

# Bouton pour calculer les num√©ros N13*500
tk.Button(
    n13_500_frame,
    text="Calc N13*500",
    font=("Arial", 10, "bold"),
    bg="blue",
    fg="white",
    borderwidth=6,
    command=systeme_500
).pack(side="left", padx=5, pady=5)

# Bouton N13*500 modifi√© pour utiliser la nouvelle fonction
tk.Button(
    n13_500_frame,
    text="N13*500",
    font=("Arial", 10, "bold"),
    bg="green",
    fg="white",
    borderwidth=6,
    command=play_n13_500_numbers_with_repet
).pack(side="left", padx=5, pady=5)

# Cadre d'affichage pour N13*500 avec largeur fixe
n13_500_display_frame = tk.Frame(n13_500_frame, bg="white", relief="sunken", width=180, height=30)
n13_500_display_frame.pack(side="right", padx=5, pady=5)
n13_500_display_frame.pack_propagate(False)  # Emp√™che le redimensionnement


# ========================
# SYST√àME 1000 - T29*1000
# ========================
def update_t29_1000_display():
    """Met √† jour l'affichage des num√©ros avec largeur fixe"""
    # Effacer les anciens labels
    for widget in t29_1000_display_frame.winfo_children():
        widget.destroy()
    # Cr√©er un cadre conteneur avec largeur fixe
    container = tk.Frame(t29_1000_display_frame, width=300, height=30)
    container.pack(side="left", fill="y")
    container.pack_propagate(False)  # Emp√™che le redimensionnement
    # Cr√©er les nouveaux labels pour chaque num√©ro
    if t29_1000_numbers:
        for num in t29_1000_numbers:
            color = "red" if num in [1, 3, 5, 7, 9, 12, 14, 16, 18, 19, 21, 23, 25, 27, 30, 32, 34, 36] else "black"
            bg_color = "lightpink" if num % 2 == 0 else "lightblue"
            tk.Label(
                container,
                text=f"{num:2d}",
                font=("Courier", 9, "bold"),
                bg=bg_color,
                fg=color,
                relief="raised",
                width=3
            ).pack(side="left", padx=1)
    else:
        tk.Label(
            container,
            text="Aucun",
            font=("Courier", 9),
            bg="white",
            fg="black"
        ).pack()

def systeme_1000():
    global t29_1000_numbers
    if len(history) < 1000:
        t29_1000_numbers = []
    else:
        derniers_1000 = history[-1000:]
        compteurs_1000 = {num: derniers_1000.count(num) for num in range(37)}
        t29_1000_numbers = [num for num in range(37) if compteurs_1000.get(num, 0) >= 29]  # Corrig√© de 30 √† 29
    # Mettre √† jour l'affichage
    update_t29_1000_display()

def play_t29_1000_numbers():
    if not t29_1000_numbers:
        messagebox.showinfo("Information", "Aucun num√©ro √† jouer pour T29*1000.")
        return
    play_numbers(t29_1000_numbers)

# Nouvelle fonction pour jouer les num√©ros T29*1000 avec REPET
def play_t29_1000_numbers_with_repet():
    # D'abord calculer les num√©ros √† jouer
    systeme_1000()

    if not t29_1000_numbers:
        messagebox.showinfo("Information", "Aucun num√©ro √† jouer pour T29*1000.")
        return

    # R√©cup√©rer la valeur de REPET
    try:
        repetitions = int(repet_mollette.get())
    except ValueError:
        messagebox.showerror("Erreur", "La valeur de r√©p√©tition doit √™tre un nombre entier.")
        return

    # R√©cup√©rer la vitesse de clic
    try:
        click_speed = int(speed_entry.get())
    except ValueError:
        messagebox.showerror("Erreur", "La vitesse de clic doit √™tre un nombre entier.")
        return

    # Jouer chaque num√©ro avec r√©p√©tition
    for num in t29_1000_numbers:
        if num in coordinates:
            x, y = coordinates[num]
            if x > 0 and y > 0:
                for _ in range(repetitions):
                    pyautogui.click(x, y)
                    time.sleep(click_speed / 1000)
            else:
                messagebox.showwarning("Avertissement", f"Coordonn√©es manquantes pour le num√©ro {num}.")
        else:
            messagebox.showwarning("Avertissement", f"Coordonn√©es manquantes pour le num√©ro {num}.")

# Cadre pour T29*1000
t29_1000_frame = tk.Frame(systems_frame, bg="lightcoral", borderwidth=2, relief="sunken")
t29_1000_frame.pack(fill="x", pady=(0, 5))

# Bouton pour calculer les num√©ros T29*1000
tk.Button(
    t29_1000_frame,
    text="Calc T29*1000",
    font=("Arial", 10, "bold"),
    bg="blue",
    fg="white",
    borderwidth=6,
    command=systeme_1000
).pack(side="left", padx=5, pady=5)

# Bouton T29*1000 modifi√© pour utiliser la nouvelle fonction
tk.Button(
    t29_1000_frame,
    text="T29*1000",
    font=("Arial", 10, "bold"),
    bg="red",
    fg="white",
    borderwidth=6,
    command=play_t29_1000_numbers_with_repet
).pack(side="left", padx=5, pady=5)

# Cadre d'affichage pour T29*1000 avec largeur fixe
t29_1000_display_frame = tk.Frame(t29_1000_frame, bg="white", relief="sunken", width=180, height=30)
t29_1000_display_frame.pack(side="right", padx=5, pady=5)
t29_1000_display_frame.pack_propagate(False)  # Emp√™che le redimensionnement



# Mettre √† jour tous les syst√®mes au d√©marrage
update_all_systems()


# =====================================================================
# NOUVEAU BALANCED SYSTEM - PLD (Logique STRICTE & CORRIGEE pour 2 PL)
# =====================================================================

def balanced_system():
    global pld_numbers
    # R√©initialisation
    pld_numbers = {"P1": None, "P2": None, "non_sortis": []}

    if len(history) < 1:
        pld_display.config(text="Historique\nvide")
        return

    # 1. COMPTER LES SORTIES
    compteurs_histo = {num: history.count(num) for num in range(37)}
    max_sorties = max(compteurs_histo.values()) if compteurs_histo else 0

    # 2. TROUVER LES CANDIDATS POIDS LOURDS (Ceux qui ont le maximum de sorties)
    # On cr√©e une liste de tous les num√©ros, tri√©e par nombre de sorties (d√©croissant)
    nombres_tries = sorted(compteurs_histo.items(), key=lambda x: x[1], reverse=True)

    # S'il n'y a pas de sorties, on arr√™te
    if not nombres_tries or nombres_tries[0][1] == 0:
        pld_display.config(text="")
        return

    # 3. TROUVER LE(S) POIDS LOURD(S) - LOGIQUE CORRIG√âE
    poids_lourds = []
    sorties_principales = nombres_tries[0][1] if nombres_tries else 0

    # Trouver le nombre de sorties du premier num√©ro qui n'est pas un poids lourd potentiel
    sorties_premier_non_pl = 0
    for num, count in nombres_tries:
        if count < sorties_principales:
            sorties_premier_non_pl = count
            break
    else:
        # Si tous les num√©ros ont le m√™me nombre de sorties
        sorties_premier_non_pl = sorties_principales

    # Condition ABSOLUE : Les poids lourds doivent avoir au moins 2 sorties d'avance
    if sorties_principales - sorties_premier_non_pl >= 2:
        # Ajouter TOUS les num√©ros qui ont le maximum de sorties (sorties_principales)
        for num, count in nombres_tries:
            if count == sorties_principales:
                poids_lourds.append((num, count))
            else:
                break  # On s'arr√™te d√®s qu'on trouve un num√©ro avec moins de sorties

    # Appliquer la limite de 2 poids lourds maximum
    poids_lourds = poids_lourds[:2]

    # 4. TROUVER LES NUM√âROS NON SORTIS
    non_sortis = [num for num in range(37) if compteurs_histo[num] == 0]

    # 5. METTRE √Ä JOUR LA VARIABLE GLOBALE
    p1 = poids_lourds[0][0] if len(poids_lourds) >= 1 else None
    p2 = poids_lourds[1][0] if len(poids_lourds) >= 2 else None
    pld_numbers = {"P1": p1, "P2": p2, "non_sortis": non_sortis}


    # 6. METTRE √Ä JOUR L'AFFICHAGE
    if p1 is not None:
        # PARTIE FIXE - P1 et P2 TOUJOURS VISIBLES √Ä GAUCHE
        display_text = f"     [{p1}]:[{p2 if p2 is not None else '  '}] :"

        # PARTIE VARIABLE - On ajoute seulement le D√âBUT des num√©ros non sortis
        if non_sortis:
            # Convertir en string pour calculer la longueur
            non_sortis_str = ','.join(str(num) for num in non_sortis)

            # Calculer l'espace disponible (environ 15-20 caract√®res apr√®s "P1 : P2 : ")
            espace_disponible = 20  # Ajuste ce nombre selon la largeur de ton cadre

            # Prendre seulement le d√©but de la liste pour ne pas cacher P1 et P2
            if len(non_sortis_str) > espace_disponible:
                # Trouver o√π couper pour ne pas couper au milieu d'un num√©ro
                preview_str = non_sortis_str[:espace_disponible]
                # Couper √† la derni√®re virgule propre
                derniere_virgule = preview_str.rfind(',')
                if derniere_virgule > 0:
                    preview_str = preview_str[:derniere_virgule]
                display_text += f"[{preview_str}...]"  # Ajouter "..." pour indiquer la suite
            else:
                display_text += f"[{non_sortis_str}]"
        else:
            display_text += "[Aucun]"

        pld_display.config(text=display_text)
    else:
        pld_display.config(text="")


def jouer_pld():
    numbers_to_play = []
    if pld_numbers["P1"] is not None:
        numbers_to_play.append(pld_numbers["P1"])
    if pld_numbers["P2"] is not None:
        numbers_to_play.append(pld_numbers["P2"])
    numbers_to_play.extend(pld_numbers["non_sortis"])
    play_numbers(numbers_to_play)


def update_balanced_system(number):
    global pld_numbers
    # Condition CRITIQUE : on ne met √† jour QUE si le syst√®me est actif (P1 existe)
    # et si le num√©ro tir√© est dans la liste des non-sortis.
    if pld_numbers["P1"] is not None and pld_numbers["non_sortis"] and number in pld_numbers["non_sortis"]:
        pld_numbers["non_sortis"].remove(number)

        # On reconstruit l'affichage mis √† jour
        display_text = f"[{pld_numbers['P1']}] : "
        display_text += f"[{pld_numbers['P2'] if pld_numbers['P2'] is not None else '  '}] : "
        non_sortis_str = ','.join(str(num) for num in pld_numbers["non_sortis"])
        display_text += f"[{non_sortis_str}]"

        pld_display.config(text=display_text)
    # Note : Si le num√©ro est un poids lourd (P1 ou P2), on ne fait rien, comme sp√©cifi√©.


# Cadre pour PLD (UN SEUL CADRE - MODIFIABLE)
pld_frame = tk.Frame(systems_frame, bg="lightyellow", borderwidth=8, relief="sunken")
pld_frame.pack(fill="x", pady=(0, 5))



# =============================================
# BLOC D√âPLAC√â : ANNONCIATEUR, MAT, MontCG
# =============================================



# --- D√âFINITION DES MATRICES ---
MATRICES = {
    "M9": [
[13, 35, 8, 32, 10, 1, 34, 28, 24],
[35, 20, 6, 3, 0, 29, 30, 16, 33],
[12, 11, 28, 10, 35, 23, 30, 33, 1],
[35, 36, 8, 2, 14, 10, 23, 34, 20],
[4, 0, 35, 30, 1, 3, 22, 17, 32],
[13, 36, 35, 8, 2, 15, 16, 19, 31],
[8, 32, 12, 15, 1, 16, 25, 17, 4],
[29, 33, 12, 19, 8, 24, 15, 1, 28],
[32, 12, 35, 26, 6, 11, 7, 29, 4],
[35, 22, 4, 15, 29, 17, 33, 34, 14],
[14, 21, 35, 33, 3, 13, 8, 34, 2],
[14, 35, 22, 24, 6, 33, 2, 9, 4],
[35, 11, 2, 31, 29, 8, 14, 22, 36],
[35, 3, 8, 17, 22, 1, 6, 27, 36],
[35, 6, 12, 14, 36, 8, 32, 28, 7],
[35, 17, 19, 22, 29, 28, 23, 13, 8],
[1, 22, 35, 36, 33, 11, 7, 13, 14],
[35, 29, 30, 21, 1, 15, 10, 27, 19],
[23, 10, 35, 24, 17, 1, 11, 12, 6],
[35, 6, 13, 29, 3, 26, 9, 11, 36],
[1, 35, 24, 29, 6, 19, 31, 14, 17],
[33, 35, 3, 29, 15, 4, 1, 20, 36],
[13, 8, 21, 35, 14, 7, 6, 12, 23],
[8, 0, 2, 35, 24, 3, 7, 28, 32],
[32, 35, 20, 8, 2, 29, 36, 21, 10],
[8, 35, 29, 28, 1, 6, 2, 22, 17],
[35, 29, 17, 0, 36, 10, 32, 12, 22],
[35, 8, 17, 3, 33, 36, 31, 4, 0],
[6, 4, 1, 3, 8, 32, 14, 15, 33],
[35, 4, 8, 28, 32, 33, 25, 11, 0],
[25, 36, 2, 34, 28, 15, 35, 31, 32],
[35, 26, 8, 14, 15, 6, 28, 4, 25],
[29, 25, 36, 10, 15, 16, 4, 35, 24],
[6, 8, 35, 30, 0, 10, 14, 19, 1],
[12, 1, 27, 8, 35, 32, 36, 33, 7],
[28, 35, 6, 22, 36, 32, 12, 16, 9],
[4, 29, 25, 14, 8, 3, 32, 30, 2]
    ],
    "M12": [
[13, 4, 32, 8, 35, 14, 10, 24, 9, 33, 28, 1],
[35, 20, 3, 32, 0, 4, 12, 6, 24, 30, 31, 29],
[35, 12, 10, 28, 30, 32, 11, 33, 1, 24, 23, 22],
[35, 8, 12, 36, 10, 22, 19, 23, 26, 32, 0, 2],
[30, 22, 4, 0, 35, 1, 17, 28, 13, 9, 3, 8],
[36, 13, 8, 2, 35, 0, 19, 23, 16, 12, 10, 31],
[8, 32, 16, 6, 33, 15, 4, 35, 29, 1, 13, 25],
[29, 24, 8, 28, 35, 33, 36, 1, 12, 14, 16, 23],
[35, 12, 32, 11, 6, 29, 26, 4, 7, 1, 28, 8],
[35, 22, 14, 15, 33, 4, 36, 17, 10, 19, 6, 13],
[14, 21, 1, 2, 35, 34, 33, 3, 13, 12, 8, 6],
[6, 35, 14, 22, 24, 4, 3, 11, 2, 8, 9, 16],
[36, 35, 8, 11, 22, 14, 2, 29, 24, 3, 25, 6],
[35, 3, 8, 1, 22, 17, 6, 27, 36, 12, 23, 5],
[35, 8, 6, 12, 14, 36, 1, 9, 32, 29, 5, 7],
[35, 17, 29, 4, 19, 8, 13, 22, 6, 14, 23, 12],
[1, 22, 2, 33, 30, 35, 11, 6, 34, 7, 36, 21],
[35, 9, 1, 21, 33, 29, 15, 22, 13, 30, 19, 12],
[35, 11, 24, 23, 20, 1, 17, 14, 13, 10, 25, 22],
[6, 35, 13, 3, 29, 11, 2, 24, 23, 25, 15, 33],
[1, 35, 6, 24, 14, 2, 29, 19, 12, 33, 3, 8],
[3, 35, 33, 4, 29, 20, 36, 24, 31, 11, 9, 7],
[13, 12, 35, 14, 8, 21, 23, 26, 6, 17, 15, 16],
[8, 0, 2, 35, 32, 33, 26, 10, 24, 28, 1, 3],
[35, 21, 8, 32, 7, 29, 20, 1, 2, 36, 33, 34],
[35, 1, 29, 28, 8, 36, 22, 6, 2, 12, 0, 24],
[35, 32, 29, 36, 17, 10, 34, 28, 12, 6, 0, 33],
[35, 0, 8, 17, 3, 33, 31, 1, 36, 28, 4, 22],
[4, 6, 8, 3, 0, 1, 35, 32, 28, 15, 26, 14],
[35, 28, 0, 32, 1, 4, 33, 8, 6, 2, 25, 10],
[34, 35, 36, 2, 25, 15, 31, 10, 32, 28, 14, 6],
[8, 35, 26, 15, 12, 4, 28, 11, 6, 14, 25, 32],
[29, 35, 36, 15, 10, 12, 33, 16, 3, 14, 21, 4],
[6, 35, 30, 3, 8, 32, 13, 36, 14, 1, 4, 19],
[35, 1, 3, 8, 12, 32, 22, 29, 17, 36, 27, 7],
[35, 28, 8, 16, 6, 22, 32, 36, 29, 25, 12, 26],
[29, 34, 4, 25, 32, 14, 23, 2, 28, 8, 3, 6]


    ],
    "M13": [
[13, 32, 35, 4, 14, 8, 28, 33, 24, 21, 1, 10, 9],
[35, 32, 3, 20, 30, 0, 2, 4, 6, 24, 12, 31, 1],
[35, 10, 12, 28, 30, 32, 33, 1, 11, 4, 22, 24, 23],
[35, 12, 8, 0, 23, 10, 36, 27, 22, 24, 19, 11, 26],
[35, 30, 4, 1, 22, 0, 3, 8, 32, 28, 9, 13, 17],
[36, 13, 8, 0, 2, 16, 23, 19, 35, 12, 4, 10, 31],
[8, 32, 4, 15, 6, 13, 16, 23, 35, 25, 33, 1, 22],
[35, 8, 29, 24, 28, 36, 33, 12, 1, 14, 23, 3, 16],
[12, 35, 11, 32, 29, 6, 26, 4, 8, 18, 28, 14, 1],
[35, 22, 15, 19, 14, 17, 4, 36, 33, 27, 8, 12, 10],
[14, 21, 2, 3, 35, 33, 34, 13, 1, 8, 12, 6, 22],
[6, 35, 14, 22, 4, 24, 3, 2, 11, 9, 8, 19, 16],
[35, 8, 36, 11, 14, 24, 2, 29, 22, 3, 6, 9, 25],
[35, 3, 8, 22, 1, 17, 6, 28, 36, 12, 27, 0, 23],
[35, 8, 14, 6, 1, 36, 12, 5, 32, 13, 7, 9, 28],
[35, 17, 4, 29, 13, 19, 22, 6, 8, 14, 33, 23, 1],
[1, 22, 2, 35, 33, 6, 11, 30, 34, 7, 3, 21, 13],
[35, 9, 29, 1, 21, 15, 22, 33, 30, 13, 19, 12, 8],
[35, 23, 6, 11, 24, 17, 1, 20, 25, 13, 10, 14, 12],
[6, 35, 13, 29, 11, 24, 23, 3, 19, 2, 25, 16, 8],
[1, 35, 6, 24, 2, 19, 14, 29, 12, 8, 36, 33, 3],
[3, 35, 33, 29, 4, 20, 36, 30, 31, 12, 9, 1, 24],
[13, 15, 35, 12, 14, 26, 8, 21, 6, 23, 7, 17, 16],
[8, 0, 2, 32, 35, 24, 33, 26, 10, 34, 3, 29, 28],
[35, 8, 21, 36, 7, 20, 32, 2, 34, 29, 28, 33, 1],
[29, 35, 28, 1, 8, 36, 12, 22, 6, 0, 17, 2, 10],
[35, 36, 32, 29, 28, 10, 12, 17, 6, 34, 14, 2, 11],
[35, 0, 8, 33, 17, 3, 1, 22, 31, 36, 28, 32, 5],
[4, 6, 8, 32, 3, 35, 0, 1, 14, 26, 2, 15, 16],
[35, 28, 0, 32, 33, 1, 4, 6, 10, 8, 29, 2, 14],
[35, 34, 36, 15, 31, 25, 10, 2, 28, 14, 3, 6, 1],
[35, 8, 4, 15, 26, 12, 11, 28, 32, 6, 19, 3, 14],
[29, 35, 33, 3, 15, 36, 10, 4, 12, 16, 14, 32, 25],
[6, 35, 30, 36, 8, 3, 32, 14, 13, 4, 1, 19, 12],
[35, 3, 8, 1, 29, 22, 32, 12, 17, 7, 9, 36, 15],
[35, 28, 16, 22, 29, 6, 12, 8, 26, 36, 30, 32, 25],
[4, 32, 34, 29, 25, 8, 30, 28, 3, 23, 6, 14, 2]
    ],
    "M15": [
[13, 35, 32, 14, 10, 4, 8, 21, 1, 24, 9, 28, 3, 7, 25],
[35, 32, 0, 30, 14, 3, 4, 2, 6, 20, 1, 24, 12, 22, 31],
[35, 1, 10, 12, 28, 30, 22, 4, 32, 13, 11, 33, 2, 7, 29],
[35, 8, 12, 10, 0, 9, 23, 22, 24, 36, 26, 21, 27, 19, 11],
[30, 35, 22, 1, 3, 28, 4, 32, 8, 0, 14, 29, 9, 2, 17],
[8, 36, 0, 2, 4, 13, 12, 19, 33, 23, 35, 16, 11, 14, 3],
[32, 8, 4, 12, 13, 35, 16, 23, 15, 26, 10, 22, 6, 17, 14],
[8, 35, 24, 33, 28, 29, 1, 12, 36, 3, 23, 14, 6, 0, 18],
[35, 12, 29, 11, 32, 6, 28, 4, 26, 1, 8, 16, 23, 24, 19],
[35, 22, 15, 8, 19, 17, 14, 24, 27, 36, 10, 21, 29, 6, 4],
[14, 21, 2, 35, 13, 3, 1, 34, 33, 8, 12, 6, 22, 5, 11],
[35, 6, 14, 22, 8, 3, 24, 2, 9, 12, 4, 1, 31, 29, 33],
[8, 36, 35, 2, 22, 24, 14, 11, 29, 3, 12, 25, 6, 9, 1],
[35, 22, 3, 8, 1, 6, 17, 28, 36, 27, 12, 5, 26, 21, 0],
[35, 8, 14, 1, 6, 5, 12, 36, 11, 13, 28, 7, 9, 32, 29],
[35, 4, 6, 17, 29, 8, 13, 19, 11, 14, 33, 22, 23, 28, 36],
[1, 35, 22, 2, 6, 11, 33, 30, 23, 36, 3, 21, 34, 13, 7],
[35, 15, 9, 1, 29, 33, 8, 21, 4, 22, 30, 13, 23, 3, 19],
[35, 24, 23, 12, 10, 6, 11, 13, 16, 3, 17, 20, 22, 25, 14],
[6, 35, 13, 25, 29, 8, 23, 3, 11, 15, 33, 24, 20, 5, 2],
[24, 1, 35, 6, 12, 19, 29, 14, 8, 2, 36, 33, 3, 31, 5],
[3, 35, 29, 33, 4, 20, 36, 30, 12, 22, 6, 31, 24, 11, 8],
[15, 35, 12, 13, 8, 17, 14, 6, 16, 26, 28, 7, 23, 33, 5],
[8, 0, 35, 10, 33, 2, 32, 28, 24, 3, 29, 26, 6, 34, 1],
[21, 36, 35, 8, 7, 32, 2, 33, 29, 34, 20, 1, 15, 28, 10],
[29, 35, 28, 8, 1, 2, 36, 12, 6, 10, 13, 32, 22, 0, 21],
[35, 32, 36, 29, 10, 17, 12, 28, 14, 25, 6, 5, 34, 33, 0],
[35, 3, 0, 8, 17, 31, 33, 32, 29, 22, 36, 1, 6, 28, 5],
[4, 8, 6, 3, 35, 1, 15, 29, 32, 0, 14, 26, 34, 13, 30],
[35, 28, 0, 1, 4, 32, 8, 33, 2, 6, 29, 10, 7, 14, 25],
[35, 34, 15, 31, 25, 28, 36, 2, 10, 32, 1, 12, 6, 20, 11],
[35, 8, 4, 26, 6, 15, 11, 12, 1, 36, 32, 14, 3, 28, 29],
[29, 35, 33, 36, 3, 4, 10, 12, 32, 14, 15, 13, 25, 8, 7],
[6, 35, 36, 32, 30, 3, 14, 13, 8, 19, 22, 1, 29, 34, 4],
[35, 22, 1, 32, 3, 8, 29, 7, 10, 27, 17, 12, 15, 16, 36],
[35, 28, 16, 6, 26, 29, 22, 12, 8, 11, 32, 13, 5, 3, 14],
[32, 25, 8, 4, 29, 34, 14, 28, 19, 6, 2, 30, 35, 3, 12]
    ]
}



# --- CR√âATION DU CADRE "ANNONCIATEUR" ---
frame_annonce = tk.LabelFrame(rectangulo_frame, text="ANNONCIATEUR", padx=10, pady=10, bg="#f0f8ff", font=("Arial", 10, "bold"))
frame_annonce.grid(row=17, column=0, columnspan=7, padx=10, pady=5, sticky="ew")

# Variable pour choisir la matrice
matrice_var = tk.StringVar(value="M9")

# Ligne 1 : Choix de la matrice
tk.Label(frame_annonce, text="Type Matrice:", bg="#f0f8ff").grid(row=0, column=0, sticky="w")
tk.Radiobutton(frame_annonce, text="M9", variable=matrice_var, value="M9", bg="#f0f8ff").grid(row=0, column=1)
tk.Radiobutton(frame_annonce, text="M12", variable=matrice_var, value="M12", bg="#f0f8ff").grid(row=0, column=2)
tk.Radiobutton(frame_annonce, text="M13", variable=matrice_var, value="M13", bg="#f0f8ff").grid(row=0, column=3)
tk.Radiobutton(frame_annonce, text="M15", variable=matrice_var, value="M15", bg="#f0f8ff").grid(row=0, column=4)

# Ligne 2 : Nombre de tirages
tk.Label(frame_annonce, text="Nb tirages:", bg="#f0f8ff").grid(row=1, column=0, sticky="w")
entry_tirages = tk.Entry(frame_annonce, width=5)
entry_tirages.grid(row=1, column=1, sticky="w")

# === VARIABLES GLOBALES POUR M√âMOIRE INTER-FONCTIONS ===
resultats_ann = None  # Stockera les num√©ros √† jouer apr√®s analyse

# === BOUTON "AFF" : AFFICHER LA POPUP SANS JOUER ===
def on_click_aff():
    global resultats_ann
    resultats_ann = None  # R√©initialiser

    try:
        n = int(entry_tirages.get())
        if n <= 0 or n > 100:
            raise ValueError
    except:
        messagebox.showerror("Erreur", "Nombre invalide (1-100)")
        return

    selected_matrix_key = matrice_var.get()
    matrix = MATRICES[selected_matrix_key]

    global history
    if not isinstance(history, list) or len(history) == 0:
        messagebox.showerror("Erreur", "Historique vide ou non d√©fini.")
        return

    derniers = history[-n:]
    if len(derniers) < n:
        messagebox.showerror("Erreur", f"Pas assez de donn√©es. Demand√©: {n}, Disponible: {len(derniers)}")
        return

    numeros_valides = [num for num in derniers if 0 <= num <= 36]
    if not numeros_valides:
        messagebox.showinfo("ANN", "Aucun num√©ro valide entre 0 et 36.")
        return

    tous_numeros = []
    for idx in numeros_valides:
        try:
            ligne = matrix[idx]
            tous_numeros.extend(ligne)
        except IndexError:
            print(f"‚ö†Ô∏è Ligne {idx} non d√©finie dans {selected_matrix_key}")

    if not tous_numeros:
        messagebox.showinfo("ANN", "Aucune donn√©e trouv√©e dans les lignes s√©lectionn√©es.")
        return

    from collections import Counter
    freq = Counter(tous_numeros)
    tri√© = sorted(freq.items(), key=lambda x: (-x[1], x[0]))
    selectionnes = [num for num, count in tri√© if count >= 2]

    # Sauvegarder pour jouer plus tard
    resultats_ann = selectionnes

    # === AFFICHAGE POPUP ===
    result_text = "N¬∞ ANN\t\tNB fois sortis\n" + "-" * 40 + "\n"
    for num, count in tri√©:
        result_text += f"{num}\t\t{count} fois\n"

    popup = tk.Toplevel(root)
    popup.title("Num√©ros Annonc√©s")
    popup.geometry("650x600")
    tk.Label(popup, text=result_text, font=("Courier", 12, "bold"), justify="left", bg="white").pack(padx=10, pady=10)

# === BOUTON "JOUER" : JOUE SEULEMENT SI ANALYSE FAITE ===
def on_click_jouer():
    global resultats_ann
    if resultats_ann is None:
        messagebox.showwarning("Attention", "Veuillez d'abord cliquer sur 'AFF' pour analyser.")
        return
    if not resultats_ann:
        messagebox.showinfo("ANN", "Aucun num√©ro avec 2+ occurrences √† jouer.")
        return
    play_numbers(resultats_ann)

# === BOUTONS DANS LE CADRE ===
tk.Button(frame_annonce, text="AFF", command=on_click_aff, bg="lightblue", fg="black", borderwidth=6, font=("Arial", 10, "bold")).grid(row=1, column=2, padx=5)
tk.Button(frame_annonce, text="JOUER", command=on_click_jouer, bg="orange", fg="white", borderwidth=6, font=("Arial", 10, "bold")).grid(row=1, column=3, padx=5)

#=================================================================
# --- Cadre principal MAT ---
#=================================================================
frame_mat = tk.LabelFrame(rectangulo_frame, text="MAT", padx=10, pady=10, bg="#f0f8ff", font=("Arial", 10, "bold"))
frame_mat.grid(row=18, column=0, columnspan=7, padx=10, pady=5, sticky="ew")

# --- Variables globales ---
mat_popup = None
mat_labels = {}  # {num: label} pour mise √† jour dynamique
mat_buttons = {}  # {num: button}
mat_ecart = {}  # {num: √©cart de la s√©rie associ√©e}

# --- Initialisation des √©carts ---
for num in range(37):
    mat_ecart[num] = 0  # √âcart de la s√©rie d√©marr√©e par ce num√©ro

# --- Choix de la matrice ---
tk.Label(frame_mat, text="Type Matrice:", bg="#f0f8ff").grid(row=0, column=0, sticky="w")
matrice_var_mat = tk.StringVar(value="M9")  # Ind√©pendant de ANNONCIATEUR

tk.Radiobutton(frame_mat, text="M9", variable=matrice_var_mat, value="M9", bg="#f0f8ff").grid(row=0, column=1)
tk.Radiobutton(frame_mat, text="M12", variable=matrice_var_mat, value="M12", bg="#f0f8ff").grid(row=0, column=2)
tk.Radiobutton(frame_mat, text="M13", variable=matrice_var_mat, value="M13", bg="#f0f8ff").grid(row=0, column=3)
tk.Radiobutton(frame_mat, text="M15", variable=matrice_var_mat, value="M15", bg="#f0f8ff").grid(row=0, column=4)

# --- Champ d'alerte ---
tk.Label(frame_mat, text="Alerte Ec:", bg="#f0f8ff").grid(row=1, column=0, sticky="w")
entry_alerte_mat = tk.Entry(frame_mat, width=5)
entry_alerte_mat.grid(row=1, column=1, sticky="w")
entry_alerte_mat.insert(0, "6")  # Valeur par d√©faut

# --- Indicateur visuel d'alerte (‚óè) ‚Äî taille augment√©e
alerte_label = tk.Label(frame_mat, text="‚óè", font=("Arial", 20), bg="#f0f8ff", fg="green")
alerte_label.grid(row=1, column=4, padx=(20, 0), sticky="w")

# --- Bouton d'affichage ---
def on_click_aff_mat():
    global mat_popup

    if mat_popup is not None:
        try:
            mat_popup.destroy()
        except:
            pass

    selected = matrice_var_mat.get()
    n = {"M9": 9, "M12": 12, "M13": 13, "M15": 15}[selected]
    matrix = MATRICES[selected]

    derniers = history[-n:] if len(history) >= n else history[:]
    uniques = []
    seen = set()
    for num in reversed(derniers):
        if num not in seen and 0 <= num <= 36:
            uniques.append(num)
            seen.add(num)
    uniques = list(reversed(uniques))[-n:]

    # Cr√©ation de la popup
    mat_popup = tk.Toplevel(root)
    mat_popup.title(f"S√©ries Matricielles - {selected}")
    mat_popup.geometry("700x600")
    mat_popup.resizable(False, False)

    canvas = tk.Canvas(mat_popup, bg="white")
    scrollbar = tk.Scrollbar(mat_popup, orient="vertical", command=canvas.yview)
    scrollable_frame = tk.Frame(canvas, bg="white")

    scrollable_frame.bind("<Configure>", lambda e: canvas.configure(scrollregion=canvas.bbox("all")))
    canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
    canvas.configure(yscrollcommand=scrollbar.set)

    canvas.pack(side="left", fill="both", expand=True)
    scrollbar.pack(side="right", fill="y")

    # Titre
    tk.Label(scrollable_frame, text=f"{selected}", font=("Arial", 16, "bold"), bg="white").pack(pady=(10, 5))

    # Stocker les boutons/labels
    mat_labels.clear()
    mat_buttons.clear()

    def make_play_func(nums):
        return lambda: play_numbers(nums)

    for num in uniques:
        try:
            serie = matrix[num]
        except:
            continue

        line_frame = tk.Frame(scrollable_frame, bg="white", relief="ridge", bd=1, padx=5, pady=2)
        line_frame.pack(fill="x", pady=2)

        # √âcart Ec
        ec = mat_ecart[num]
        color = "red" if ec >= int(entry_alerte_mat.get() or 6) else "black"
        ec_label = tk.Label(line_frame, text=f"Ec:{ec:>2} ", font=("Courier", 12, "bold"), bg="white", fg=color)
        ec_label.pack(side="left")
        mat_labels[num] = ec_label

        # Num√©ro + bouton
        btn = tk.Button(line_frame, text=f"{num:2d}", font=("Courier", 14, "bold"), bg="lightblue", width=4, command=make_play_func(serie))
        btn.pack(side="left", padx=(5, 2))
        mat_buttons[num] = btn

        # S√©rie associ√©e
        nums_text = ", ".join([f"{x:2d}" for x in serie])
        tk.Label(line_frame, text=nums_text, font=("Helvetica", 13, "bold"), bg="white", fg="Darkblue", wraplength=500).pack(side="left", padx=5)

    # Fermeture propre
    def on_close():
        global mat_popup
        if mat_popup is not None:
            try:
                mat_popup.destroy()
            except:
                pass
            mat_popup = None

    mat_popup.protocol("WM_DELETE_WINDOW", on_close)

# Bouton AFF
tk.Button(frame_mat, text="AFF", command=on_click_aff_mat, bg="lightgreen", fg="black", borderwidth=6, font=("Arial", 10, "bold")).grid(row=1, column=2, padx=5)

# === MISE √Ä JOUR DES √âCARTS MATRICIELS √Ä CHAQUE TIRAGE ===
def update_mat_system(last_number):
    """Met √† jour les √©carts MAT : incr√©mente toutes les s√©ries, r√©initialise si un num√©ro de la s√©rie sort"""
    global mat_ecart

    # Incr√©menter l'√©cart de chaque s√©rie
    for num in range(37):
        mat_ecart[num] += 1

    # V√©rifier dans quelle(s) s√©rie(s) le num√©ro sorti appara√Æt
    for idx in range(37):
        try:
            matrix_key = matrice_var_mat.get()
            serie = MATRICES[matrix_key][idx]
            if last_number in serie:
                mat_ecart[idx] = 0  # R√©initialiser l'√©cart de la s√©rie du num√©ro idx
        except:
            continue

    # === MISE √Ä JOUR DE L'INDICATEUR VISUEL DANS LE CADRE PRINCIPAL ===
    try:
        seuil = int(entry_alerte_mat.get())
        if seuil < 2:
            alerte_label.config(fg="gray")
        else:
            selected = matrice_var_mat.get()
            n = {"M9": 9, "M12": 12, "M13": 13, "M15": 15}.get(selected, 9)
            derniers = history[-n:] if len(history) >= n else history[:]
            uniques = []
            seen = set()
            for num in reversed(derniers):
                if num not in seen and 0 <= num <= 36:
                    uniques.append(num)
                    seen.add(num)
            uniques = list(reversed(uniques))[-n:]
            if any(mat_ecart[num] >= seuil for num in uniques):
                alerte_label.config(fg="red")
            else:
                alerte_label.config(fg="green")
    except:
        alerte_label.config(fg="gray")

    # === MISE √Ä JOUR DE LA POPUP SI OUVERTE ===
    if mat_popup is not None and mat_popup.winfo_exists():
        try:
            selected = matrice_var_mat.get()
            n = {"M9": 9, "M12": 12, "M13": 13, "M15": 15}[selected]
            derniers = history[-n:] if len(history) >= n else history[:]
            uniques = []
            seen = set()
            for num in reversed(derniers):
                if num not in seen and 0 <= num <= 36:
                    uniques.append(num)
                    seen.add(num)
            uniques = list(reversed(uniques))[-n:]

            # Mettre √† jour les labels d'√©cart
            for num in mat_labels:
                if num in mat_ecart:
                    ec = mat_ecart[num]
                    color = "red" if ec >= int(entry_alerte_mat.get() or 6) else "black"
                    mat_labels[num].config(text=f"Ec:{ec:>2} ", fg=color)

            # Si changement de liste ‚Üí recharger
            current_nums = set(mat_labels.keys())
            new_nums = set(uniques)
            if current_nums != new_nums:
                on_click_aff_mat()

        except Exception as e:
            print(f"[MAT] Erreur mise √† jour live: {e}")


#==============================================
# --- Cadre principal MontCG ---
#=============================================

frame_montcg = tk.LabelFrame(rectangulo_frame, text="MontCG", padx=10, pady=10, bg="#f0f8ff", font=("Arial", 10, "bold"))
frame_montcg.grid(row=19, column=0, columnspan=7, padx=10, pady=5, sticky="ew")

# --- Variables globales pour MontCG autonome ---
montcg_spin_counter = 0          # Compteur local ind√©pendant
montcg_active = False            # √âtat ON/OFF du syst√®me
montante_sequence_complete = []  # S√©quence charg√©e selon type et nb

# --- Ligne 1: Current Gap et Num√©ro ---
gap_frame = tk.Frame(frame_montcg, bg="#f0f8ff")
gap_frame.pack(fill="x", pady=2)

tk.Label(gap_frame, text="Current Gap =", bg="#f0f8ff").pack(side="left")
tk.Entry(gap_frame, textvariable=montcg_current_gap, width=3, font=("Arial", 10, "bold"), justify="center", state="readonly").pack(side="left", padx=2)
tk.Label(gap_frame, text="N¬∞", bg="#f0f8ff").pack(side="left", padx=(10, 2))
tk.Entry(gap_frame, textvariable=montcg_numero_max, width=3, font=("Arial", 10, "bold"), justify="center", state="readonly").pack(side="left", padx=2)

# --- Ligne 2: Choix de montante ---
choix_frame = tk.Frame(frame_montcg, bg="#f0f8ff")
choix_frame.pack(fill="x", pady=5)

tk.Label(choix_frame, text="Choix Mt:", bg="#f0f8ff").pack(side="left")

# Menu d√©roulant pour le type de montante
montante_type_var = tk.StringVar(value="CLASS")
montante_type_menu = tk.OptionMenu(choix_frame, montante_type_var, "CLASS", "PR", "LIGHT N", "PRX LIGHT", "FIBONA", "DER DOUB")
montante_type_menu.config(width=3)
montante_type_menu.pack(side="left", padx=2)

# Menu d√©roulant pour le nombre de num√©ros
montante_nb_var = tk.StringVar(value="8")
montante_nb_menu = tk.OptionMenu(choix_frame, montante_nb_var, *map(str, range(1, 26)))
montante_nb_menu.config(width=2)
montante_nb_menu.pack(side="left", padx=2)

# Affichage de la s√©quence
montcg_sequence_var = tk.StringVar(value="S√©quence")
tk.Entry(choix_frame, textvariable=montcg_sequence_var, width=10, font=("Arial", 9), justify="center", state="readonly").pack(side="left", padx=5)

# --- Ligne 3: Spin + Contr√¥les (Spin, Reset, ON/OFF) ---
control_frame = tk.Frame(frame_montcg, bg="#f0f8ff")
control_frame.pack(fill="x", pady=2)

tk.Label(control_frame, text="Spin:", bg="#f0f8ff").pack(side="left")

montcg_spin_var = tk.StringVar(value="0")
spin_display = tk.Entry(control_frame, textvariable=montcg_spin_var, width=3, font=("Arial", 10, "bold"), justify="center", state="readonly")
spin_display.pack(side="left", padx=2)

# --- Bouton RESET ---
def reset_montcg_spin():
    global montcg_spin_counter
    montcg_spin_counter = 0
    montcg_spin_var.set("0")
    montcg_sequence_var.set("S√©quence")
    update_montcg()

tk.Button(control_frame, text="R", font=("Arial", 9, "bold"), bg="orange", fg="white", borderwidth=6, width=3, command=reset_montcg_spin).pack(side="left", padx=5)

# --- Bouton ON/OFF ---
montcg_on_off_btn = None

def toggle_montcg():
    global montcg_active
    montcg_active = not montcg_active
    if montcg_active:
        montcg_on_off_btn.config(bg="green", text="ON", fg="white")
    else:
        montcg_on_off_btn.config(bg="red", text="OFF", fg="white")
    update_montcg()

montcg_on_off_btn = tk.Button(control_frame, text="OFF", font=("Arial", 9, "bold"), bg="red", fg="white", borderwidth=6, width=4, command=toggle_montcg)
montcg_on_off_btn.pack(side="left")

# --- Fonction pour mettre √† jour la s√©quence ---
def update_montante_sequence(*args):
    montante_type = montante_type_var.get()
    try:
        nb = int(montante_nb_var.get())
        if montante_type in MONTANTES and nb in MONTANTES[montante_type]:
            global montante_sequence_complete
            montante_sequence_complete = MONTANTES[montante_type][nb]
        else:
            montante_sequence_complete = []
    except Exception as e:
        print(f"[MontCG] Erreur lecture s√©quence: {e}")
        montante_sequence_complete = []

# Lier les changements des menus
montante_type_var.trace("w", update_montante_sequence)
montante_nb_var.trace("w", update_montante_sequence)

# Initialiser
update_montante_sequence()

# --- Fonction pour trouver le plus grand √©cart ---
def find_max_gap():
    max_gap = 0
    max_num = 0
    for num in range(37):
        if num in ecart and ecart[num] > max_gap:
            max_gap = ecart[num]
            max_num = num
    return max_gap, max_num

# --- Fonction pour incr√©menter le compteur local ---
def increment_montcg_spin():
    global montcg_spin_counter
    if montcg_active and montcg_spin_counter < 999:
        montcg_spin_counter += 1
        update_montcg()

# --- Fonction pour mettre √† jour MontCG ---
def update_montcg():
    # --- Mettre √† jour Current Gap (inchang√©) ---
    max_gap, max_num = find_max_gap()
    montcg_current_gap.set(str(max_gap))
    montcg_numero_max.set(str(max_num))

    if max_gap >= 150:
        for widget in gap_frame.winfo_children():
            if isinstance(widget, tk.Entry):
                widget.config(bg="red", fg="white")
    else:
        for widget in gap_frame.winfo_children():
            if isinstance(widget, tk.Entry):
                widget.config(bg="white", fg="black")

    # --- Mettre √† jour le SPIN LOCAL ---
    if montcg_active:
        montcg_spin_var.set(str(montcg_spin_counter))
    else:
        montcg_spin_var.set("0")

    # --- Mettre √† jour la SEQUENCE selon le SPIN LOCAL ---
    if montante_sequence_complete and montcg_spin_counter > 0:
        idx = min(montcg_spin_counter - 1, len(montante_sequence_complete) - 1)
        sequence_value = montante_sequence_complete[idx]
        montcg_sequence_var.set(str(sequence_value))
    else:
        montcg_sequence_var.set("S√©quence")

# --- Int√©gration avec le syst√®me principal ---
def new_update_counters_with_montcg(number):
    # Appeler l'ancienne fonction
    if 'original_update_counters' in globals():
        original_update_counters(number)
    else:
        global history
        history.append(number)
        update_history()

    # Incr√©menter le compteur MontCG si activ√©
    increment_montcg_spin()

# Sauvegarder la fonction originale
if 'update_counters' in globals() and not hasattr(update_counters, '_is_montcg_version'):
    global_original_update_counters = update_counters
    update_counters = new_update_counters_with_montcg
    update_counters._is_montcg_version = True

# --- Connexion au syst√®me global ---
original_update_all = update_all_systems

def new_update_all_systems():
    original_update_all()
    if history:
        update_mat_system(history[-1])

update_all_systems = new_update_all_systems





# Bouton PLD
tk.Button(
    pld_frame,
    text="PLD",
    font=("Arial", 10, "bold"),
    bg="purple",
    fg="white",
    command=jouer_pld  # On appelle seulement jouer_pld maintenant
).pack(side="left", padx=5, pady=5)

# Cadre d'affichage pour PLD (UN SEUL CADRE - MODIFIABLE)
pld_display = tk.Label(
    pld_frame,
    text="",
    font=("Courier", 12, "bold"),
    bg="white",
    fg="black",
    width=30,  # Largeur en caract√®res
    height=2,  # Hauteur en lignes
    relief="sunken",  # Style: sunken, raised, groove, ridge, flat
    justify="left"  # Alignement: left, center, right
)
pld_display.pack(side="right", padx=5, pady=5)

# ================================
# INT√âGRATION DANS ON_NUMBER_CLICK
# ================================

# Sauvegarder la fonction originale
if 'original_on_number_click' not in globals():
    original_on_number_click = on_number_click


# Nouvelle fonction unifi√©e QUI APPELLE AUTOMATIQUEMENT balanced_system()
def new_on_number_click(number):
    original_on_number_click(number)  # Traite l'historique, etc.
    update_str8v_counters(number)
    update_win_r_system(number)
    balanced_system()  # <-- C'EST LA CL√â ! On recalcule et affiche AUTOMATIQUEMENT apr√®s chaque tirage.


# Remplacer la fonction
on_number_click = new_on_number_click

# =============================================================================
# SYST√àME 3DEN - VERSION FINALE CORRECTE
# =============================================================================

# Variables pour le syst√®me 3DEN (√† mettre avec les autres variables globales)
det_ecart_3den = 0  # √âcart sp√©cifique au syst√®me 3DEN
det_ecart_max_3den = 0  # √âcart max sp√©cifique au syst√®me 3DEN
det_alerte_seuil_3den = 1  # Seuil d'alerte sp√©cifique au syst√®me 3DEN
det_m3n_value = 0  # Valeur du compteur M3N

# Table de correspondance Ec -> M3N
M3N_TABLE = {
    1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1, 7: 1, 8: 1,
    9: 2, 10: 2, 11: 2, 12: 2,
    13: 3, 14: 3, 15: 3, 16: 3, 17: 3,
    18: 4, 19: 4, 20: 4,
    21: 5, 22: 5,
    23: 6, 24: 6,
    25: 7,
    26: 8, 27: 8,
    28: 9,
    29: 10,
    30: 11,
    31: 12,
    32: 13,
    33: 14,
    34: 15,
    35: 17,
    36: 19,
    37: 21,
    38: 25,
    39: 28,
    40: 33
}


def update_m3n_value():
    """Met √† jour la valeur du compteur M3N en fonction de l'√©cart Ec"""
    global det_m3n_value

    if det_ecart_3den == 0:
        det_m3n_value = 0
    else:
        # Trouver la valeur correspondante dans la table
        # Si l'√©cart d√©passe 40, on utilise la derni√®re valeur (33)
        if det_ecart_3den > 40:
            det_m3n_value = 33
        else:
            det_m3n_value = M3N_TABLE.get(det_ecart_3den, 0)

    # Mettre √† jour l'affichage
    m3n_label.config(text=str(det_m3n_value))


# Fonctions pour le syst√®me 3DEN
def jouer_3_derniers():
    """Joue les 3 derniers num√©ros saisis sur la table de jeu"""
    if len(history) < 3:
        messagebox.showwarning("3DEN", "Pas assez de num√©ros dans l'historique (minimum 3).")
        return

    # R√©cup√©rer la vitesse de clic
    try:
        click_speed = int(speed_entry.get())
    except ValueError:
        messagebox.showerror("Erreur", "La vitesse de clic doit √™tre un nombre entier.")
        return

    # R√©cup√©rer le nombre de r√©p√©titions
    try:
        repetitions = int(repet_mollette.get())
    except ValueError:
        messagebox.showerror("Erreur", "La valeur de r√©p√©tition doit √™tre un nombre entier.")
        return

    # R√©cup√©rer seulement les 3 derniers num√©ros (pas tout l'historique)
    trois_derniers = history[-3:]

    # message = f"Jouer les 3 derniers num√©ros: {', '.join(map(str, trois_derniers))}"
    # messagebox.showinfo("3DEN", message)

    # Cliquer sur chaque num√©ro des 3 derniers, r√©p√©t√© selon la valeur de REPET
    for num in trois_derniers:
        if num in coordinates:
            x, y = coordinates[num]
            if x > 0 and y > 0:  # V√©rifier que les coordonn√©es sont valides
                for _ in range(repetitions):  # R√©p√©ter le clic selon la valeur de REPET
                    pyautogui.click(x, y)  # Cliquer sur les coordonn√©es (X, Y)
                    time.sleep(click_speed / 1000)  # D√©lai entre les clics
            else:
                messagebox.showwarning("Avertissement", f"Coordonn√©es manquantes pour le num√©ro {num}.")
        else:
            messagebox.showwarning("Avertissement", f"Coordonn√©es manquantes pour le num√©ro {num}.")


def update_alerte_seuil_3den():
    """Met √† jour le seuil d'alerte depuis l'entry"""
    global det_alerte_seuil_3den
    try:
        new_seuil = int(alerte_entry.get())
        if 1 <= new_seuil <= 500:
            det_alerte_seuil_3den = new_seuil
            check_ecart_alerte_3den()
            messagebox.showinfo("Alerte", f"Seuil d'alerte r√©gl√© √† {det_alerte_seuil_3den}")
        else:
            messagebox.showerror("Erreur", "Valeur doit √™tre entre 1 et 500")
            alerte_entry.delete(0, tk.END)
            alerte_entry.insert(0, str(det_alerte_seuil_3den))
    except ValueError:
        alerte_entry.delete(0, tk.END)
        alerte_entry.insert(0, str(det_alerte_seuil_3den))


def check_ecart_alerte_3den():
    """V√©rifie si l'√©cart atteint le seuil d'alerte et change la couleur"""
    if det_ecart_3den >= det_alerte_seuil_3den:
        ecart_label.config(bg="red", fg="white")
    else:
        ecart_label.config(bg="white", fg="black")


def update_3den_system(number):
    """Met √† jour le syst√®me 3DEN √† chaque nouveau num√©ro"""
    global det_ecart_3den, det_ecart_max_3den

    # Le syst√®me n'est actif qu'avec au moins 4 num√©ros
    if len(history) < 4:
        # R√©initialiser tout √† 0 tant qu'on n'a pas 4 num√©ros
        det_ecart_3den = 0
        det_ecart_max_3den = 0
        ecart_label.config(text="0")
        ecart_max_label.config(text="0")
        m3n_label.config(text="0")
        return

    # V√©rifier si le num√©ro est dans les 3 derniers (les 3 avant le dernier)
    derniers_3 = history[-4:-1]  # Les 3 num√©ros avant le dernier

    if number in derniers_3:
        det_ecart_3den = 0  # R√©initialiser l'√©cart
        print("‚úÖ 3DEN: √âcart r√©initialis√© √† 0")
    else:
        det_ecart_3den += 1  # Incr√©menter l'√©cart
        print(f"‚û°Ô∏è 3DEN: √âcart incr√©ment√© √† {det_ecart_3den}")

        # Mettre √† jour l'√©cart maximum si n√©cessaire
        if det_ecart_3den > det_ecart_max_3den:
            det_ecart_max_3den = det_ecart_3den
            ecart_max_label.config(text=str(det_ecart_max_3den))
            print(f"üìà 3DEN: Nouveau max: {det_ecart_max_3den}")

    # Mettre √† jour l'affichage
    ecart_label.config(text=str(det_ecart_3den))
    check_ecart_alerte_3den()

    # Mettre √† jour la valeur M3N
    update_m3n_value()


def update_all_systems():
    """Met √† jour tous les syst√®mes"""
    # Ajoutez ici tous vos autres syst√®mes qui doivent se mettre √† jour

    # Syst√®me 3DEN
    if history:  # S'il y a un historique
        update_3den_system(history[-1])


# Cr√©ation du cadre 3DEN
tden_frame = tk.Frame(distance_tden_container, bg='black', width=75, relief="ridge", borderwidth=4)
tden_frame.pack(pady=(5, 0))
tden_frame.pack_propagate(True)

# Cadre interne pour organiser les √©l√©ments verticalement
tden_inner_frame = tk.Frame(tden_frame, bg='lightgray')
tden_inner_frame.pack(fill="both", expand=True, padx=2, pady=2)



# 1. Bouton "3DEN"
tden_button = tk.Button(tden_inner_frame, text="3DEN", font=("Arial", 10, "bold"),borderwidth=8,
                        command=jouer_3_derniers, bg="peachpuff")
tden_button.pack(fill="x", pady=(5, 2))

# 2. Case Ec avec son compteur
ecart_frame = tk.Frame(tden_inner_frame, bg='lightgray')
ecart_frame.pack(fill="x", pady=2)
tk.Label(ecart_frame, text="Ec:", font=("Arial", 12, "bold"), bg='lightgray').pack(side="left")
ecart_label = tk.Label(ecart_frame, text="0", font=("Arial", 12, "bold"), bg="white", width=5, relief="sunken")
ecart_label.pack(side="right", padx=5)

# 3. Case Ecmx avec son compteur
ecart_max_frame = tk.Frame(tden_inner_frame, bg='lightgray')
ecart_max_frame.pack(fill="x", pady=2)
tk.Label(ecart_max_frame, text="Ecmx:", font=("Arial", 12, "bold"), bg='lightgray').pack(side="left")
ecart_max_label = tk.Label(ecart_max_frame, text="0", font=("Arial", 12, "bold"), bg="white", width=5, relief="sunken")
ecart_max_label.pack(side="right", padx=5)

# 4. Case de r√©glage d'alerte
alerte_frame = tk.Frame(tden_inner_frame, bg='lightgray')
alerte_frame.pack(fill="x", pady=2)
tk.Label(alerte_frame, text="Alerte:", font=("Arial", 11, "bold"), bg='lightgray').pack(side="left")



# Entry pour le seuil d'alerte avec validation
def validate_alerte_input(new_value):
    return new_value.isdigit() and 1 <= int(new_value) <= 500 or new_value == ""


vcmd = (tden_inner_frame.register(validate_alerte_input), '%P')

alerte_frame_right = tk.Frame(alerte_frame, bg='lightgray')
alerte_frame_right.pack(side="right")

alerte_entry = tk.Entry(alerte_frame_right, font=("Arial", 12, "bold"), width=4, justify="center",
                        validate="key", validatecommand=vcmd)
alerte_entry.insert(0, "1")
alerte_entry.pack(side="left", padx=(2, 0))

# Bouton de validation
valider_btn = tk.Button(alerte_frame_right, text="‚úì", font=("Arial", 7),
                        command=update_alerte_seuil_3den, bg="lightgreen", width=2)
valider_btn.pack(side="right", padx=(2, 0))

# 5. Case M3N avec son compteur (ajout√© en derni√®re position)
m3n_frame = tk.Frame(tden_inner_frame, bg='lightgray')
m3n_frame.pack(fill="x", pady=(2, 5))
tk.Label(m3n_frame, text="M3N:", font=("Arial", 12, "bold"), bg='lightgray').pack(side="left")
m3n_label = tk.Label(m3n_frame, text="0", font=("Arial", 12, "bold"), bg="white", width=5, relief="sunken")
m3n_label.pack(side="right", padx=5)

# ... [ton code 3DEN existant] ...

# 5. Case M3N avec son compteur (ajout√© en derni√®re position)
#m3n_frame = tk.Frame(tden_inner_frame, bg='lightgray')
#m3n_frame.pack(fill="x", pady=(2, 5))
#tk.Label(m3n_frame, text="M3N:", font=("Arial", 12, "bold"), bg='lightgray').pack(side="left")
#m3n_label = tk.Label(m3n_frame, text="0", font=("Arial", 12, "bold"), bg="white", width=5, relief="sunken")
#m3n_label.pack(side="right", padx=5)

# =============================================================================
# ICI TU COLLES LE CODE DES BOUTONS RADIOS
# =============================================================================

# === CADRE BOUTONS RADIO ===
mode_frame = tk.Frame(distance_tden_container, bg="lightgray", relief="groove", borderwidth=2)
mode_frame.pack(pady=(5, 0))





# === D√âPLACEMENT DU CADRE REDUC : sous les boutons radios ===
# === CADRE REDUC - plac√© sous les boutons radios ===
reduc_frame = tk.Frame(distance_tden_container, borderwidth=4, relief="groove", bg="lightblue")
reduc_frame.pack(pady=(0, 10), fill="x")  # ‚Üê M√™me largeur que mode_frame

# Titre "REDUC"
tk.Label(reduc_frame, text="REDUC", font=default_font, bg="lightblue").pack(pady=(0, 5))

# Cadre int√©rieur pour aligner Entry + boutons
inner_reduc = tk.Frame(reduc_frame, bg="lightblue")
inner_reduc.pack()

# Case compteur
reduc_entry = tk.Entry(inner_reduc, width=5, font=default_font)
reduc_entry.grid(row=1, column=1, padx=5, pady=5)

# Bouton REDUC
tk.Button(inner_reduc, text="REDUC", font=default_font, command=reduc_spins).grid(row=0, column=1, padx=5)
# Bouton OFF1
tk.Button(inner_reduc, text="OFF1", font=default_font, command=reset_reduc).grid(row=0, column=2, padx=5)
# Bouton P18
tk.Button(inner_reduc, text="P18", borderwidth= 6 ,bg="Orange", fg="black", font=default_font, command=play_P18).grid(row=1, column=2, padx=5)





# Liste des boutons radio : (Texte, Valeur)
radio_buttons = [
    ("R/B", "RB"),
    ("E/O", "EO"),
    ("L/H", "LH"),
    ("S1/S2", "S1S2"),
    ("T1/T2", "T1T2"),
    ("DZ", "DZ"),
    ("CL", "CL")
]

# Cr√©ation des boutons radio en colonne unique
for i, (text, value) in enumerate(radio_buttons):
    tk.Radiobutton(
        mode_frame,
        text=text,
        variable=mode_var,
        value=value,
        font=default_font,
        bg="lightgray",
        fg="black",
        selectcolor="lightblue",
        indicatoron=1,
        width=8,
        command=update_history
    ).grid(row=i, column=0, padx=5, pady=2, sticky="w")

# =============================================================================
# FIN DU CODE BOUTONS RADIOS
# =============================================================================
# ... le reste du code 3DEN reste identique ...

# =============================================================================
# AJOUT : SYST√àME NUM√âROS ANNONC√âS - "ANNONCIATEUR"
# =============================================================================


# ========================
# R√âINITIALISATION DES SYST√àMES (Ajust√©e)
# ========================

def reset_systems():
    global n0_150_numbers, n13_500_numbers, t29_1000_numbers, pld_numbers
    n0_150_numbers = []
    n13_500_numbers = []
    t29_1000_numbers = []
    pld_numbers = {"P1": None, "P2": None, "non_sortis": []}

    n0_150_display.config(text="")
    n13_500_display.config(text="")
    t29_1000_display.config(text="")
    pld_display.config(text="")  # <-- On r√©initialise aussi l'affichage


# ========================
# LANCEMENT DE L'APPLICATION
# ========================
root.mainloop()